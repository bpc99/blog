<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>记录生活中的点点滴滴</subtitle>
  <link href="https://www.bipch.cn/atom.xml" rel="self"/>
  
  <link href="https://www.bipch.cn/"/>
  <updated>2021-03-10T09:16:43.760Z</updated>
  <id>https://www.bipch.cn/</id>
  
  <author>
    <name>Xiaopc767d</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Github主页美化</title>
    <link href="https://www.bipch.cn/use-github-styles/"/>
    <id>https://www.bipch.cn/use-github-styles/</id>
    <published>2021-03-10T05:22:15.000Z</published>
    <updated>2021-03-10T09:16:43.760Z</updated>
    
    <content type="html"><![CDATA[<p>Github 默认展示仓库和提交信息等字段，却没有汇总或一些自定义连接功能，不过其提供了创建同名仓库的形式自定义主页。比如我的用户名为 bpc99，那么我们只需新建一个相同名的仓库即可。下面便通过此仓库中的 README 文件，自定义 Github 的主页。<br>那么 README 能玩出什么花样呢？</p><h2 id="装修效果"><a href="#装修效果" class="headerlink" title="装修效果"></a>装修效果</h2><p>首先贴出本人的个人主页修改后的样式：</p><p><img src="https://img.bipch.cn/2021/03/10/627185a4aa616.png" alt=""></p><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>最上面中的数据统计和评分都是依靠外部的一个服务，我们只需要调用相应服务即可：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;https://github-readme-stats.vercel.app/api?username=bpc99&amp;show_icons=true&quot;</span> <span class="attribute">alt</span>=<span class="string">&quot;logo&quot;</span> <span class="attribute">height</span>=<span class="string">&quot;160&quot;</span> <span class="attribute">align</span>=<span class="string">&quot;right&quot;</span> <span class="attribute">style</span>=<span class="string">&quot;margin: 5px; margin-bottom: 20px;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>当然需要把上面的<code>username</code>字段修改为自己 Github 的用户名，这样才能正确的统计自己本人的仓库信息。</p><h2 id="自动更新博客列表"><a href="#自动更新博客列表" class="headerlink" title="自动更新博客列表"></a>自动更新博客列表</h2><p>例如上面最终展示的 5 条最先的文章，并不是写死的，而是由 Github 每个一段时间自动统计文章中最新的 5 篇。<br>当然如果你也需要该功能，可以将 README 添加下面的代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Latest Blog Posts</span></span><br><span class="line"></span><br><span class="line">&lt;!-- BLOG-POST-LIST:START --&gt;</span><br><span class="line">&lt;!-- BLOG-POST-LIST:END --&gt;</span><br></pre></td></tr></table></figure><p>其实只是一个标题，和一些代码的注释声明，之后 Github 统计的数据会自动统计到注释代码块中，也就是<code>可以通过修改注释的位置，可以将其放置到任意位置</code>。<br>当然我们还需要实现一个<code>每段时间自动统计的功能</code>，该功能才是重中之重，我们需要 Github 的 Github Action 来进行实现。</p><p>点击下面的按钮，可进行添加操作：</p><p><img src="https://img.bipch.cn/2021/03/10/3740e196f980b.png" alt=""></p><p>然后我们将下面内容粘贴进去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Blog</span> <span class="string">Posts</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># Run workflow automatically</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="comment"># Runs every hour, on the hour</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 * * * *&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">update-readme-with-blog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Update</span> <span class="string">this</span> <span class="string">repo&#x27;s</span> <span class="string">README</span> <span class="string">with</span> <span class="string">latest</span> <span class="string">blog</span> <span class="string">posts</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">gautamkrishnar/blog-post-workflow@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># comma-separated list of RSS feed urls</span></span><br><span class="line">          <span class="attr">feed_list:</span> <span class="string">&quot;https://bipch.cn/atom.xml&quot;</span></span><br></pre></td></tr></table></figure><p>当然上面的<code>cron: &quot;0 * * * *&quot;</code>表示多长时间执行一次，这里为每小时 0 分的时候去执行，所以执行整点我们才能看到结果，当然事件可能有几分钟的延迟，所以耐心等待一段时间即可。<br>另一个关键的字段为<code>feed_list</code>文章的 RSS 订阅地址，多个的话后面使用逗号分割，所以使用该功能一定要拥有文章的 RSS 地址，如果并没有或者忘记都不能使用该功能，由于本人博客是使用 Hexo 生成的，所以根据文章生成 RSS 非常简单，当然如果是其它的肯定也有方法，根据技术的不同，生成的方式也不会相同，这里就不多叙述了，大家可以去网上查阅。</p><h2 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h2><p>当然上面只是一些简单的功能，但是其是 Mackdown 类型的文档，我们可以任意添加一些自己需要的代码。</p><p>最后贴出本人的仓库地址：<a href="https://github.com/bpc99/bpc99">https://github.com/bpc99/bpc99</a></p><p>大家也可以根据自己需求去添加，最后祝大家都有一个高大上的 Github 主页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Github 默认展示仓库和提交信息等字段，却没有汇总或一些自定义连接功能，不过其提供了创建同名仓库的形式自定义主页。比如我的用户名为 bpc99，那么我们只需新建一个相同名的仓库即可。下面便通过此仓库中的 README 文件，自定义 Github 的主页。&lt;br&gt;那么 R</summary>
      
    
    
    
    <category term="Github" scheme="https://www.bipch.cn/categories/Github/"/>
    
    
    <category term="Github美化" scheme="https://www.bipch.cn/tags/Github%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>vercel</title>
    <link href="https://www.bipch.cn/vercel/"/>
    <id>https://www.bipch.cn/vercel/</id>
    <published>2021-03-09T09:29:56.000Z</published>
    <updated>2021-03-09T11:46:07.931Z</updated>
    
    <content type="html"><![CDATA[<p>当项目完成后，最重要的便是部署了，一般需要挑选一个访问速度比较快的、花钱比较少的、部署比较方便…这些因素同时考虑比较好用的便是  GitHub Pages 了，但是其国内一般访问较慢，如果比较着重考虑国内访问的话，可以考虑另一款和 Github 比较契合的工具 <a href="https://github.com/vercel/vercel">Vercel</a>。</p><span id="more"></span><h2 id="Why-Vercel"><a href="#Why-Vercel" class="headerlink" title="Why Vercel"></a>Why Vercel</h2><p>Vercel 国内的访问速度也是比较快，而且无需科学上网，相同的项目对比 <strong>Vercel 托管的程序(图左)</strong> 和 <strong>直接部署的程序(图右)</strong> 的请求速度：</p><p><img src="https://img.bipch.cn/2021/03/09/36debd291265f.png" alt="对比"></p><p>可以看到其速度加快了 2 倍多，并且 Vercel 和 Github 也是比较契合的，其还能直接导入 hexo、vue、next等项目，其会自动为我们构建。</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>我们可以在 Github 新增一个仓库，然后可以在 Vercel 设置该仓库，这样一旦仓库数据数据更新 Vercel 中的数据也会更新，并且可以查看仓库的操作日志等信息。<br>在 <a href="https://vercel.com/">vercel</a> 新增 Project，然后选择 <strong>Add Github Org or Account</strong>：</p><p><img src="https://img.bipch.cn/2021/03/09/ad9cc13670fed.png" alt=""></p><p>选中所需的仓库之后，会根据我们的项目自动判断项目的类型，例如我们导入 Hexo 项目：</p><p><img src="https://img.bipch.cn/2021/03/09/11f1beab57f78.png" alt=""></p><p>可以看出其自动判断了项目类型，当然如果不准确可以自行修改，选择类型之后会自动生成<strong>打包命令(Build and Output Settings)</strong>、<strong>项目根目录(ROOT DIRECTORY)</strong>、<strong>环境变量(Environment Variables)</strong>等配置，根据需求配置完成后，会根据命令和项目类型自动部署，成功后可以看到下面界面：</p><p><img src="https://img.bipch.cn/2021/03/09/9b2b1f25a9427.png" alt=""></p><p>这样便完成了部署，如果是其它类型的项目，那么部署方式也是同样的。</p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>项目部署成功后系统会自动为其分配一个域名，但是其并不是太好记，所以我们一般需要将自己域名设置为项目的访问路径。<br>进入项目的详情界面，点击 <strong>View Domains</strong> 可配置项目的各个属性，但是其域名必须经过 <strong>CNAME</strong> 解析，不然会报出下面的错误：</p><p><img src="https://img.bipch.cn/2021/03/09/cd27435497ac9.png" alt=""></p><p>我们解析时添加解析，例如案例云的界面为：</p><p><img src="https://img.bipch.cn/2021/03/09/9fc718e43ddc7.png" alt=""></p><p>这样即可添加域名，并且其添加成功后会自动为我们的域名申请 SSL 证书，并为项目使用 https 协议。<br>添加域名之后，可以在详情页查看其各个域名信息，与项目日志、启动时间等字段：</p><p><img src="https://img.bipch.cn/2021/03/09/d2ed842120fe1.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然一个项目的部署方式有许多种的，而 Vercel 只是其中之一，并且开发中也不能拘束与一种部署方式，而是需要根据实际的情况选择不同的方式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当项目完成后，最重要的便是部署了，一般需要挑选一个访问速度比较快的、花钱比较少的、部署比较方便…这些因素同时考虑比较好用的便是  GitHub Pages 了，但是其国内一般访问较慢，如果比较着重考虑国内访问的话，可以考虑另一款和 Github 比较契合的工具 &lt;a href=&quot;https://github.com/vercel/vercel&quot;&gt;Vercel&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="项目部署" scheme="https://www.bipch.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Hexo多种部署方式</title>
    <link href="https://www.bipch.cn/hexo-aliyun/"/>
    <id>https://www.bipch.cn/hexo-aliyun/</id>
    <published>2021-02-03T16:43:35.000Z</published>
    <updated>2021-03-09T11:44:02.908Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Hexo 搭建完成博客，平常会更新一些文章，但是如果只是打包按照静态文件部署会显得非常的麻烦，并且每次修改文章，都要重新登陆服务器全部覆盖，这样每次都消耗大量的时间，为了简化文章的部署，也出现了很多中方法，这里记录下本人使用的两种。</p><span id="more"></span><h2 id="Git-Nginx"><a href="#Git-Nginx" class="headerlink" title="Git + Nginx"></a>Git + Nginx</h2><p><a href="https://hexo.io/zh-cn/docs/commands#deploy">官网介绍</a>，简单来说便是通过<code>deploy</code>指令读取配置文件(<strong>_config.yml</strong>)中的<code>deploy</code>属性配置，然后根据配置，将我们打包之后的静态文件推送到服务器中的 <strong>Git钩子</strong> 上，最后根据钩子的配置，将客户端与服务端代码合并，然后保存到服务端指定路径下，最后通过 Nginx 对指定的路径进行反向代理，即可使用命令将代码合并，并自动完成代码部署的功能。</p><p>通过上面描述，大致对 Hexo deploy 指令有了些大致印象，其关键的一步便是在服务端建立 <strong>Git钩子</strong> 以响应客户端的代码提交。我们可以这么做：</p><h3 id="建立-Git-钩子"><a href="#建立-Git-钩子" class="headerlink" title="建立 Git 钩子"></a>建立 Git 钩子</h3><p>首先创建钩子文件夹，并分配 755 类型权限：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /<span class="keyword">var</span>/repo/</span><br><span class="line">chown -R hexo /<span class="keyword">var</span>/repo/</span><br><span class="line">chmod -R <span class="number">755</span> /<span class="keyword">var</span>/repo/</span><br></pre></td></tr></table></figure><p>创建完成后，我们还需要初始化钩子文件：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/var/repo/</span></span><br><span class="line">git init <span class="params">--bare</span> hexo_static.git</span><br></pre></td></tr></table></figure><p>名称可以随意，初始化完成后，执行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/var/</span>repo<span class="regexp">/hexo_static.git/</span>hooks/post-receive</span><br></pre></td></tr></table></figure><p>打开文件之后，保存下面的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=<span class="regexp">/var/</span>www/blog --git-dir=<span class="regexp">/var/</span>repo/hexo_static.git checkout -f</span><br></pre></td></tr></table></figure><p>请注意上面的路径，保存完成后。只需把该文件变为可执行文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>这样基本的 Git钩子 便建立完成了，当客户端提交代码向该钩子时，便会将代码传输到指定的路径下。</p><h3 id="deploy-配置"><a href="#deploy-配置" class="headerlink" title="deploy 配置"></a>deploy 配置</h3><p>我们只需在配置文件(<strong>_config.yml</strong>)中编辑<code>deploy</code>属性，便能很简单的完成一键部署：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line">  <span class="symbol">type:</span> git</span><br><span class="line">  <span class="symbol">repo:</span> hexo<span class="variable">@47</span>.<span class="number">110.125</span>.<span class="number">228</span><span class="symbol">:/var/repo/hexo_static</span>.git</span><br><span class="line">  <span class="symbol">branch:</span> master</span><br></pre></td></tr></table></figure><p>这样只需把属性的 <strong>repo</strong> 字段指向刚刚创建的 Git钩子 即可。当然 Hexo 还需要一个依赖，执行下面命令按照依赖：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>按照完成后 Hexo 配置完成，为了简便我们可以在 package.json 中添加一行命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g -d &amp;&amp; hexo deploy&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样运行<code>yarn build</code>，便会将代码提交到服务端的配置文件下，然后通过 Nginx 反向代理便能完成了一键部署。</p><h2 id="vercel"><a href="#vercel" class="headerlink" title="vercel"></a>vercel</h2><p>vercel 不论是和 Github的契合度，还是国内的镜像的加速，都是比较好用的，具体项目的部署，可以看 <a href="/vercel">vercel</a> 的部署。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然介绍了两种的部署方式但是其如果依照结果来看如果要托管博客，其方式太多太多，除此之外肯定还有很多的方法都能达成相同的目的，这里就当是抛砖引玉了，最后附带上<a href="https://bipch.cn/">个人的博客</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 Hexo 搭建完成博客，平常会更新一些文章，但是如果只是打包按照静态文件部署会显得非常的麻烦，并且每次修改文章，都要重新登陆服务器全部覆盖，这样每次都消耗大量的时间，为了简化文章的部署，也出现了很多中方法，这里记录下本人使用的两种。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.bipch.cn/categories/Linux/"/>
    
    
    <category term="项目部署" scheme="https://www.bipch.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    <category term="Hexo" scheme="https://www.bipch.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>pm2 + Nginx 部署 Koa2</title>
    <link href="https://www.bipch.cn/linux-pm2-nginx-Koa2/"/>
    <id>https://www.bipch.cn/linux-pm2-nginx-Koa2/</id>
    <published>2021-01-30T18:10:03.000Z</published>
    <updated>2021-03-08T19:49:23.509Z</updated>
    
    <content type="html"><![CDATA[<p>因为自己需要空闲的时候总结一些个人项目等，之前通过 hexo 搭建的博客，但是接触了 koa2 决定使其搭建一个后台接口服务，为前端界面提供相应数据。</p><p>本篇主要讲解客户端一键将 koa2 项目部署到服务器，服务器端使用 pm2 管理 koa2 服务及 Nginx 反向代理服务到另一个接口。</p><p>首先网站大致为：koa2 默认占用本地<code>6060</code>端口，然后通过 nginx 反向代理到<code>80</code>端口，同时 nginx 将<code>80</code>端口转发到<code>443</code>强制使用 https 协议。</p><span id="more"></span><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>本人服务器系统为<code>CentOS7.0</code>，系统不同执行的命令也会有些许差别。部署之前要安装必备的软件：<code>Node</code>、<code>npm</code>、<code>pm2</code>、<code>Nginx</code>。安装的方法这里就不多说了，其方式有太多。</p><p><strong>下面的配置都是为了服务器安全，如果不需要可以不用配置。后面用户直接设置为 root 即可</strong>。</p><h3 id="创建新用户-可选"><a href="#创建新用户-可选" class="headerlink" title="创建新用户(可选)"></a>创建新用户(可选)</h3><p>为了服务器的安全起见，不推荐用 root 用户管理所有权限，只有需要 root 权限时，在使用<code>su</code>切换为 root。<br>创建一个新用户：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useradd bpc</span></span><br></pre></td></tr></table></figure><p>对新用户初始化密码：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">passwd bpc</span></span><br></pre></td></tr></table></figure><p>将该用户添加到<code>wheel</code>组中，设置为管理员用户：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">usermod -aG wheel bpc</span></span><br></pre></td></tr></table></figure><h3 id="关闭-root-用户访问-ssh-可选"><a href="#关闭-root-用户访问-ssh-可选" class="headerlink" title="关闭 root 用户访问 ssh(可选)"></a>关闭 root 用户访问 ssh(可选)</h3><p>为了服务器的安全，我们也需要关闭 root 的 ssh 访问权限。<br>打开配置文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>ssh/sshd_config</span><br></pre></td></tr></table></figure><p>找到下面配置，并将 yes 修改为 no：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">PermitRootLogin</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><p>保存文件后，重启sshd服务：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">service sshd restart</span></span><br></pre></td></tr></table></figure><p>这样 root 用户便不能直接登陆了，我们退出服务，使用新用户登陆，当权限不足时使用<code>su</code>切换到指定用户即可。</p><h3 id="文件读写权限-可选"><a href="#文件读写权限-可选" class="headerlink" title="文件读写权限(可选)"></a>文件读写权限(可选)</h3><p>因为我们自定义了用户进行管理，其并不会向 root 一样有着所有文件的读写权限，我们需要对指定路径设置新用户的访问权限。<br>比如我在服务器中将最终代码放置在 <strong>/var/api/blog</strong> 路径下，那么我们通过下面方式分配权限：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R bpc <span class="regexp">/var/</span>api</span><br><span class="line">chmod -R <span class="number">755</span> <span class="regexp">/var/</span>api</span><br></pre></td></tr></table></figure><p>这样通过<code>chown</code>命令分配指定用户权限，通过<code>chmod</code>分配给文件夹详细权限(755表示拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限)。</p><h2 id="SSH-上传代码"><a href="#SSH-上传代码" class="headerlink" title="SSH 上传代码"></a>SSH 上传代码</h2><p>客户和服务器端同步代码需要建立一个 github 的私人仓库，我的命名为 react_blog_api。</p><h3 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h3><p>由于需要使用 ssh 读写私人仓库内容，所以需要配置私人仓库中的 <strong>Deploy keys</strong>。这就需要我们在客户端和服务器端生成<code>id_rsa.pub</code>(默认名称)文件，并查询其内容：</p><p>首先我们查看是否已经生成该文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub  <span class="comment"># cat 命令查看文件</span></span><br></pre></td></tr></table></figure><p>当然如果<code>cat</code>命令没有查找文件，那么可以使用下面命令生成：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;你的个人邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>复制成功后，将内容粘贴到私人仓库中的 <strong>Deploy keys</strong> ：</p><p><img src="https://img.bipch.cn/2021/02/06/c05da0bf0d3e6.png" alt=""></p><p>并将 Allow write access 勾选上添加即可。</p><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>私人仓库配置完成后，我们便有权限操作私人仓库了，我们将客户端代码传入到仓库中：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> init</span><br><span class="line"><span class="symbol">git</span> remote <span class="keyword">add</span> origin https:<span class="comment">//github.com/bpc99/blog_api.git</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">add</span> .</span><br><span class="line"><span class="symbol">git</span> commit -m <span class="string">&quot;项目初始化&quot;</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push</span> -u origin master</span><br></pre></td></tr></table></figure><p>这样便将客户端代码提交至 Github 私人仓库。</p><h2 id="pm2-配置"><a href="#pm2-配置" class="headerlink" title="pm2 配置"></a>pm2 配置</h2><p>使用 pm2 可以使 node 程序永远保持活动状态，无需停机便可以重新加载它们，并简化常见的任务管理。并且其还为我们提供了 deploy 配置，可以让我们在本地一键将项目部署到服务端。</p><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p>关于 pm2 的基本操作和配置这里就不介绍了，具体可以查看其<a href="https://github.com/Unitech/pm2">官方文档</a>，当 koa2 本地运行无误时，我们需要配置 pm2 中的<code>deploy</code>属性，其默认的模板文件为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [...],</span><br><span class="line">  deploy : &#123;</span><br><span class="line">    production : &#123;</span><br><span class="line">      user : <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      host : <span class="string">&quot;212.83.163.1&quot;</span>,</span><br><span class="line">      ref  : <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">      repo : <span class="string">&quot;git@github.com:repo.git&quot;</span>,</span><br><span class="line">      path : <span class="string">&quot;/var/www/production&quot;</span>,</span><br><span class="line">      <span class="string">&quot;post-deploy&quot;</span> : <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些基础的配置，其各个属性也都很简单：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;production&quot;: &#123;</span><br><span class="line">  &quot;user&quot;: &quot;登录远程服务器的用户名(例如 root)&quot;,</span><br><span class="line">  &quot;host&quot;: &quot;IP&quot;,</span><br><span class="line">  &quot;ref&quot;: &quot;远端名称及分支名&quot;,</span><br><span class="line">  &quot;repo&quot;: &quot;git仓库地址&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;远程服务器部署目录，需要填写user具备写入权限的目录&quot;,</span><br><span class="line">  &quot;post-deploy&quot; : &quot;部署后需要执行的命令&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们根据自己服务器的信息填入即可，最后贴出本人的配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [...],</span><br><span class="line">  production: &#123;</span><br><span class="line">    user: <span class="string">&quot;bpc&quot;</span>,</span><br><span class="line">    host: <span class="string">&quot;47.110.125.228&quot;</span>,</span><br><span class="line">    ref: <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">    repo: <span class="string">&quot;git@github.com:bpc99/blog_api.git&quot;</span>,</span><br><span class="line">    path: <span class="string">&quot;/var/api/blog&quot;</span>,</span><br><span class="line">    <span class="string">&quot;post-deploy&quot;</span>: <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样便完成了 pm2 的基本配置，贴出<code>ecosystem.config.js</code>所有配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;</span><br><span class="line">    name: <span class="string">&#x27;api&#x27;</span>,</span><br><span class="line">    script: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    watch: <span class="literal">true</span>,</span><br><span class="line">    ignore_watch: [ <span class="string">&quot;node_modules&quot;</span> ]</span><br><span class="line">  &#125;],</span><br><span class="line">  deploy: &#123;</span><br><span class="line">    production: &#123;</span><br><span class="line">      user: <span class="string">&quot;bpc&quot;</span>,</span><br><span class="line">      host: <span class="string">&quot;47.110.125.228&quot;</span>,</span><br><span class="line">      ref: <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">      repo: <span class="string">&quot;git@github.com:bpc99/blog_api.git&quot;</span>,</span><br><span class="line">      path: <span class="string">&quot;/var/api/blog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;post-deploy&quot;</span>: <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后我们在根目录下，以<code>ecosystem.config.js</code>为配置文件，启动 pm2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.<span class="built_in">config</span>.js production <span class="built_in">setup</span></span><br></pre></td></tr></table></figure><p>此时会出现一个错误：</p><blockquote><p>Host key verification failed.<br>fatal: Could not read from remote repository.</p></blockquote><p>主要是因为在远程服务器中，并未将 <a href="https://github.com">github.com</a> 加入known_hosts，在服务器端通过如下命令设置：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; ~<span class="regexp">/.ssh/</span>known_hosts</span><br></pre></td></tr></table></figure><p>如果成功，会在<strong>/home/用户名/.ssh</strong>目录下生成<code>known_hosts</code>文件。然后客户端重新执行部署的指令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem.<span class="built_in">config</span>.js production <span class="built_in">setup</span></span><br></pre></td></tr></table></figure><p>如果传输成功 pm2 便将 GitHub 私人仓库中的文件，都传输到了我们服务器指定路径下，我们打开指定文件夹，发现其多了 3 个文件夹：</p><ul><li><code>current</code>：当前运行的文件夹。</li><li><code>source</code>：真正的项目源代码。</li><li><code>shared</code>：项目日志文件。</li></ul><h3 id="部署代码"><a href="#部署代码" class="headerlink" title="部署代码"></a>部署代码</h3><p>当一键传输配置完成，客户端项目代码可以一键传输到服务器上，这样我们便可以开始部署服务器上的项目了。</p><p>在开始部署之前，我们需要确保本地和 Github 私人仓库代码的同步，先将本地文件同步到 Github：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 和仓库代码同步</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta"># 代码添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m <span class="string">&quot;update ecosystem&quot;</span></span><br><span class="line"><span class="meta"># 传本地指定分支到远程仓库</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样提交完成后，在本地的根目录下执行命令，将代码向生产环境下部署：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 deploy ecosystem<span class="selector-class">.config</span><span class="selector-class">.js</span> production</span><br></pre></td></tr></table></figure><p>如果项目部署成功，配置文件中的<code>post-deploy</code>中的命令会自动执行(当然运行速度慢了可以将 npm 切换为 cnpm 或 yarn)，那么便可以看出 pm2 给出的提示：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">PM2</span>][<span class="symbol">WARN</span>] <span class="symbol">Applications</span> api not running, starting...</span><br><span class="line">[<span class="symbol">PM2</span>][<span class="symbol">WARN</span>] <span class="symbol">Environment</span> [production] is not defined in process file</span><br><span class="line">[<span class="symbol">PM2</span>] <span class="symbol">App</span> [api] launched (<span class="number">1</span> instances)</span><br><span class="line">┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐</span><br><span class="line">│ id  │ name   │ namespace   │ version │ mode    │ pid      │ uptime │ ?    │ status    │ cpu      │ mem      │ user     │ watching │</span><br><span class="line">├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤</span><br><span class="line">│ <span class="number">0</span>   │ api    │ default     │ <span class="number">1.0</span><span class="number">.0</span>   │ fork    │ <span class="number">9438</span>     │ <span class="number">0</span>s     │ <span class="number">0</span>    │ online    │ <span class="number">0</span><span class="comment">%       │ 9.1mb    │ bpc      │ disabled │</span></span><br><span class="line">└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘</span><br><span class="line">  ○ successfully deployed origin/master</span><br><span class="line">--&gt; <span class="symbol">Success</span></span><br></pre></td></tr></table></figure><p>这样便表示代码部署成功，我们可以在服务器上所有端口使用清空：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">netstat -antp</span></span><br></pre></td></tr></table></figure><p>可以查看端口开发情况，例如本人的6060端口：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tcp</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">127.0.0.1:6060</span>    <span class="number">0.0.0.0</span>:*    LISTEN    <span class="number">2657</span>/node /var/www/</span><br></pre></td></tr></table></figure><p><code>注意</code>：此时端口为<strong>127.0.0.1</strong>表明局域网可以访问，公网是不能访问到的，我们还需要 nginx 进行代理。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>上面基本运行完成，但是只有局域网可以访问，我们需要将其使用 nginx 代理至公网上，至于 nginx 下载和配置便不多提了，我们可以新建一个配置文件，最终贴出我的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> api.bipch.cn;</span><br><span class="line">    <span class="attribute">access_log</span>  /www/wwwlogs/api.bipch.cn.log;</span><br><span class="line">    <span class="attribute">error_log</span>  /www/wwwlogs/api.bipch.cn.<span class="literal">error</span>.log;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:6060;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其原理也很简单，其拦截了<strong>80</strong>端口，并代理到本地的<strong>6060</strong>，并配置了相应的域名，日志，端口等信息，配置完成后，使用<code>./nginx -s reload</code>重启服务。</p><p>最后如果配置正确，并且相应端口的安全组已经打开，那么我们便可以正常访问相应的API了。</p><h3 id="配置-https"><a href="#配置-https" class="headerlink" title="配置 https"></a>配置 https</h3><p>https 配置肯定需要相应的证书的，由于本人服务器为阿里云，免费证书申请可以看<a href="/nginx-https">这篇</a>，申请成功后，修改我们的配置文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> api.bipch.cn;</span><br><span class="line">    <span class="attribute">access_log</span>  /www/wwwlogs/api.bipch.cn.log;</span><br><span class="line">    <span class="attribute">error_log</span>  /www/wwwlogs/api.bipch.cn.<span class="literal">error</span>.log;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTP_TO_HTTPS_START</span></span><br><span class="line">    <span class="attribute">if</span> ($server_port !<span class="regexp">~ 443)</span>&#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(/.*)$</span> https://$host<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># HTTP_TO_HTTPS_END</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTP_CONFIG_START</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    /www/server/panel/vhost/cert/api.bipch.cn/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>    /www/server/panel/vhost/cert/api.bipch.cn/privkey.pem;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">    <span class="comment"># HTTP_CONFIG_END</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:6060;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样接口便强制使用 https 协议，其重点在于<code>ssl_certificate</code>和<code>ssl_certificate_key</code>分别指向两个证书的路径。当所有属性配置完成后，重启指定的 nginx 便完成了反向代理。<br>最后 pm2 便在本地<code>6060</code>运行，nginx 将<code>80</code>端口代理到<code>6060</code>端口，并且将<code>80</code>端口转发到<code>443</code>端口，使用 https 协议，这样便结合了 pm2 + nginx 完成了 node 项目的部署。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为自己需要空闲的时候总结一些个人项目等，之前通过 hexo 搭建的博客，但是接触了 koa2 决定使其搭建一个后台接口服务，为前端界面提供相应数据。&lt;/p&gt;
&lt;p&gt;本篇主要讲解客户端一键将 koa2 项目部署到服务器，服务器端使用 pm2 管理 koa2 服务及 Nginx 反向代理服务到另一个接口。&lt;/p&gt;
&lt;p&gt;首先网站大致为：koa2 默认占用本地&lt;code&gt;6060&lt;/code&gt;端口，然后通过 nginx 反向代理到&lt;code&gt;80&lt;/code&gt;端口，同时 nginx 将&lt;code&gt;80&lt;/code&gt;端口转发到&lt;code&gt;443&lt;/code&gt;强制使用 https 协议。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.bipch.cn/categories/Nginx/"/>
    
    
    <category term="项目部署" scheme="https://www.bipch.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    <category term="Nginx" scheme="https://www.bipch.cn/tags/Nginx/"/>
    
    <category term="Koa2" scheme="https://www.bipch.cn/tags/Koa2/"/>
    
    <category term="pm2" scheme="https://www.bipch.cn/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>react导航守卫</title>
    <link href="https://www.bipch.cn/react-router/"/>
    <id>https://www.bipch.cn/react-router/</id>
    <published>2021-01-28T17:10:06.000Z</published>
    <updated>2021-03-08T19:52:24.143Z</updated>
    
    <content type="html"><![CDATA[<p>导航守卫在日常开发中经常会被使用到，比如一个界面需要登陆之后或需要某种权限才能进行访问，这样我们可以很简单的使用导航守卫实现。</p><span id="more"></span><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>vue 的导航守卫主要分为 3 种，分别为：<code>全局导航守卫</code>、<code>路由导航守卫</code>、<code>组件导航守卫</code>，而最为常用的便是全局导航守卫中的<code>beforeEach</code>，每次界面的跳转都会经过里面的逻辑，只有通过才会进行跳转。<br>例如一些组件需要登陆才能进行访问，否则进入登陆或者401界面，那么用 vue-router 可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: baseRouter</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Landing logic</span></span><br><span class="line">next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次界面的跳转都会执行里面的逻辑，只有调用<code>next()</code>才能跳转，否则我们可以为其跳转到其它界面。<br>那么 react-router 为什么不提供相应的 api 呢？其实是因为设计理念的区别，React 会选择让用户自己封装相应的功能，路由守卫功能在很久前也被人提出了<a href="https://github.com/ReactTraining/react-router/issues/4962">react-router路由拦截官方说明</a>，而作者更希望保证插件的灵活性，让用户自己封装相应代码的功能。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>项目中为了方便，我们要添加路由配置文件，然后根据配置文件生成路由.。<br>我们先定义路由数据类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> routersProps&#123;</span><br><span class="line"><span class="comment">// 路径</span></span><br><span class="line">    path: <span class="built_in">string</span>,</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    <span class="comment">// 是否需要登陆</span></span><br><span class="line">    auth?: <span class="built_in">boolean</span>,</span><br><span class="line">    <span class="comment">// 是否严格验证</span></span><br><span class="line">    exact?: <span class="built_in">boolean</span>,</span><br><span class="line">    <span class="comment">// 组件</span></span><br><span class="line">    component: React.FC&lt;<span class="built_in">any</span>&gt;,</span><br><span class="line">    <span class="comment">// 子路由</span></span><br><span class="line">    children?: <span class="built_in">Array</span>&lt;routersProps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样定义了一些路由的数据类型，然后我们的路由数组可以这么定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routers: <span class="built_in">Array</span>&lt;routersProps&gt; = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">        component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../layouts/UserLayout&#x27;</span>)),</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                exact: <span class="literal">true</span>,</span><br><span class="line">                name: <span class="string">&#x27;userLogin&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;/user/login&#x27;</span>,</span><br><span class="line">                component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/login/index&#x27;</span>)),</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">        auth: <span class="literal">true</span>,</span><br><span class="line">        component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../layouts/BasicLayout&#x27;</span>)),</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                exact: <span class="literal">true</span>,</span><br><span class="line">                name: <span class="string">&#x27;Article&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;/article&#x27;</span>,</span><br><span class="line">                component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/article/index&#x27;</span>)),</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样简单的定义了一些路由数组，其组件使用了<code>React.lazy</code>主要为了让组件使用的时候再去加载。</p><h2 id="遍历路由"><a href="#遍历路由" class="headerlink" title="遍历路由"></a>遍历路由</h2><p>既然组件已经定义完成了，下面我们需要根据配置文件遍历出组件，我们可以这样去封装组件的遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface RenderRoutesProps&#123;</span><br><span class="line">    routes: <span class="built_in">Array</span>&lt;routersProps&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RenderRoutesMap: React.FC&lt;RenderRoutesProps&gt; = <span class="function">(<span class="params">&#123; routes &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                routes.map(<span class="function">(<span class="params">route, index</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; render=&#123;<span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">                            &lt;RouterGuard router=&#123;route&#125; routerProps=&#123;props&#125; /&gt;</span><br><span class="line">                        )&#125; /&gt;</span><br><span class="line">                    )</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RenderRoutesMap;</span><br></pre></td></tr></table></figure><p>这样组件<code>RenderRoutesMap</code>接收一个路由数组，但是我们并没有着急使用<code>Route</code>渲染，而是引入了另一个组件<code>RouterGuard</code>，并传入了 route(当前路由信息)、props(react-router) 作为参数。</p><h2 id="HOC封装"><a href="#HOC封装" class="headerlink" title="HOC封装"></a>HOC封装</h2><p>组件逻辑的判断因为需要被大量的组件使用，所以为了代码更好的复用这里使用 HOC，封装组件真正的展示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> RouterGuardProps &#123;</span><br><span class="line">    router: routersProps,</span><br><span class="line">    routerProps: RouteComponentProps,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RouterGuard: React.FC&lt;RouterGuardProps&gt; = <span class="function">(<span class="params">&#123;router, routerProps&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, path, exact, auth, children = []&#125; = router;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Route name=&#123;name&#125; path=&#123;path&#125; key=&#123;path&#125; exact=&#123;exact&#125; render=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading....<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line">                &lt;router.component &#123;...routerProps&#125;&gt;</span><br><span class="line">                    &lt;RenderRoutesMap routes=&#123;children&#125; /&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">router.component</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">        &#125;&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RouterGuard;</span><br></pre></td></tr></table></figure><p>首先对组件进行渲染，因为使用了<code>React.lazy</code>包装组件，所以使用的时候要加上<code>React.Suspense</code>，然后对组件内容进行递归调用，遍历组件的 children 子元素，因为可能设计到多层嵌套，这里直接把 children 传递给<code>RenderRoutesMap</code>组件，让其循环遍历即可。</p><h3 id="添加逻辑处理"><a href="#添加逻辑处理" class="headerlink" title="添加逻辑处理"></a>添加逻辑处理</h3><p>上面我们基本路由已经遍历处理完成，我们可以直接在<code>RouterGuard</code>封装逻辑代码，因为我们所有路由都经过了它的封装，所以进入新的界面<code>RouterGuard</code>里面的逻辑都会执行，我们可以这样去封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RouterGuard: React.FC&lt;RouterGuardProps&gt; = <span class="function">(<span class="params">&#123;router, routerProps&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, path, exact, auth, children = []&#125; = router;</span><br><span class="line">    <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!!auth &amp;&amp; !<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>))&#123;</span><br><span class="line">            notification.error(&#123;</span><br><span class="line">                message: <span class="string">&#x27;令牌无效&#x27;</span>,</span><br><span class="line">                description:</span><br><span class="line">                <span class="string">&#x27;token 过期或失效，请重新登陆&#x27;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            routerProps.history.replace(<span class="string">&#x27;/user/login&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            setLoading(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        loading?<span class="xml"><span class="tag">&lt;<span class="name">PageLoading</span> /&gt;</span></span>:<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">...</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RouterGuard;</span><br></pre></td></tr></table></figure><p>这样我们添加 loading 属性，当界面还在加载或验证逻辑的时候会显示 loading 界面，处理完成才展示 router，如果不符合逻辑使用<code>history.replace</code>进行重定向。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>上面代码已经基本封装完成，我们在使用路由时通过下面代码引用即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">  &lt;RenderRoutesMap routes=&#123;routes&#125; /&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>将路由数组传入即可完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面代码可以满足基本的导航守卫的封装，但是代码还是有很多需要改进的地方，这里就先抛砖引玉了。如果需要实现较为好用的权限路由可以使用 <a href="https://umijs.org/">umi路由</a>，其内置了许多权限和路由相关的封装。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;导航守卫在日常开发中经常会被使用到，比如一个界面需要登陆之后或需要某种权限才能进行访问，这样我们可以很简单的使用导航守卫实现。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="React" scheme="https://www.bipch.cn/tags/React/"/>
    
    <category term="导航守卫" scheme="https://www.bipch.cn/tags/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"/>
    
  </entry>
  
  <entry>
    <title>Next.js</title>
    <link href="https://www.bipch.cn/react-next/"/>
    <id>https://www.bipch.cn/react-next/</id>
    <published>2021-01-27T15:29:22.000Z</published>
    <updated>2021-03-09T11:29:50.736Z</updated>
    
    <content type="html"><![CDATA[<p>一款轻量级的 React 服务端渲染框架，<a href="https://github.com/vercel/next.js">社区</a> 的活跃度也不错，如果需要使用 React 做一个轻量级的 SSR 类型的项目是个不错的选择(比如个人博客)，其使用起来也是非常的简便。</p><span id="more"></span><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>将组件或页面由服务端解析，服务端请求数据并填充得到最终的 html 字符串返回客户端。</p><p>这样做优势在于：</p><ol><li>利于SEO：平常界面信息都是通过客户端 JS 动态拼接生成的，需要服务端返回相应的数据才能正确显示，但浏览器爬虫并不会等界面完全加载之后才会抓取。而服务端渲染则更便于爬虫抓取整个网页的信息。</li><li>利于首屏渲染：因为服务端渲染完全由服务端返回客户端 HTML 字符串，客户端不需要解析 js 等文件，这样首屏的速度高于普通的方式。</li></ol><p>当然其也不是全是优点，缺点也非常多：</p><ol><li>服务器压力大：本来属于客户端的工作，现在统一交给服务端去做，如果出现高并发会对服务器造成不小负担。</li><li>开发条件受限：由于解析文件交给了服务端，所以一些代码的用法和以前有所区别。</li></ol><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>空文件下安装开发闭包插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react react-dom next</span><br></pre></td></tr></table></figure><p>修改<code>package.json</code>中的命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">  &quot;build&quot;: &quot; next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 个命令每个都有着自己作用，后面会介绍，新建一个文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;hello world&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br></pre></td></tr></table></figure><p>执行<code>yarn dev</code>运行项目，运行成功后，直接输入：<strong><a href="http://localhost:3000/home">http://localhost:3000/home</a></strong> 即可访问界面，不需再需要路由相关的封装，<code>page</code>下的所有文件都会自动创建路由。</p><h2 id="create-next-app"><a href="#create-next-app" class="headerlink" title="create-next-app"></a>create-next-app</h2><p>使用脚手架初始化项目可以更好的为我们组织代码，执行命令安装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">global</span> add create-next-app</span><br></pre></td></tr></table></figure><p>安装完成后，直接创建即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-next-app project-name</span><br></pre></td></tr></table></figure><p>完成后执行<code>yarn dev</code>启动，启动完成后可以看到默认界面。</p><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>项目创建完成后，默认有些项目的配置：</p><ul><li><strong>components</strong>：也其它的项目基本一样，也是用于存放组件的地方。</li><li><strong>pages</strong>：所有的前端界面，该目录下的所有界面都会自动生成相应的路由。</li><li><strong>pages/api</strong>：项目中所有网络请求</li><li><strong>public</strong>：项目静态文件，可以用于存放不需要打包的文件，里面的文件打包时都会复制到另一个目录，不会经过打包处理。</li><li><strong>styles</strong>：为项目提供初始化或界面的样式。</li><li><strong>.gitignore</strong>：再向 Git 提交代码时，忽略一些文件。</li></ul><p>很轻便的一种前端结构，并没有太复杂的配置。</p><h2 id="界面跳转"><a href="#界面跳转" class="headerlink" title="界面跳转"></a>界面跳转</h2><p>React 中跳转界面主要用 react-router-dom 等框架实现，但是 Next.js 并不需要在安装 react-router-dom 插件，我们跳转界面需要在 Next.js 中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样便可以实现界面跳转了，但是 <code>&lt;Link /&gt;</code> 组件，只能接收一个组件。除了组件跳转，我们也可以通过 JS 代码进行跳转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;next/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;router.push(<span class="string">&#x27;/home&#x27;</span>)&#125;&#125;&gt;home&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态生成-or-SSR"><a href="#静态生成-or-SSR" class="headerlink" title="静态生成 or SSR"></a>静态生成 or SSR</h2><p>这一点非常重要，Next 为界面提供了两种渲染的方式：</p><ol><li>静态生成：只有构建(build)时才获取数据，之后每次引用都是构建的数据。</li><li>SSR：每次请求界面都会生成新的 html。</li></ol><p>我们可以为每个界面选择一个渲染方式，两种区别便是获取数据的时机，具体结合实际使用，当然处于性能考虑最优选肯定为 <strong>静态生成</strong> 的方式。</p><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>根据不同的渲染方式获取数据的策略也不同，官网为我们提供了三个获取数据的方法：</p><ol><li><code>getStaticProps</code>(<strong>静态生成</strong>)：构建(build)时获取界面数据。</li><li><code>getStaticPaths</code>(<strong>静态生成</strong>)：构建(build)时根据数据渲染界面动态路由。</li><li><code>getServerSideProps</code>(<strong>SSR</strong>)：每次界面请求都获取数据。</li></ol><h3 id="getStaticProps"><a href="#getStaticProps" class="headerlink" title="getStaticProps"></a>getStaticProps</h3><p>根据介绍很容易发现其作用，为我们的静态生成界面获取数据，默认格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticProps</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Logic processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接导出该方法即可，方法中可以进行逻辑处理，例如可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticProps</span>(<span class="params">&#123; params &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//? 获取数据</span></span><br><span class="line">  <span class="keyword">const</span> detailedSource = <span class="keyword">await</span> postDetails(params.id);</span><br><span class="line">  <span class="comment">//? 返回数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      detailed: detailedSource</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出在<code>ctx.params</code>可以获取到动态路由的传参，然后利用<code>async/await</code>处理异步逻辑获取数据，最后 return 数据即可，组件中直接通过 props 即可获取到最后的数据。<br>如果您熟悉一些 Next.js 可执行<code>next build</code>然后在<code>.next/server/pages</code>可以找到该文件，例如：</p><p><img src="https://img.bipch.cn/2021/03/09/8a7d8db3f0681.png" alt="静态生成"></p><p>可以看出，当我们 build 时，其自动把含有<code>getStaticProps</code>界面和数据结合形成最终形成 html 静态界面，就算以后数据变化其也不会改变，除非重新 build 生成新的静态 html 界面。</p><h3 id="getStaticPaths"><a href="#getStaticPaths" class="headerlink" title="getStaticPaths"></a>getStaticPaths</h3><p>此方法只适用于含有动态路由的界面，例如一个界面的路径为<code>pages/detailed/[id].jsx</code>，转换为路由为：<code>detailed/***</code>，这是必须有一个<code>getStaticPaths</code>方法，表示那些 <strong>id</strong> 才能访问该界面。<br>默认的格式为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticPaths</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    paths: [</span><br><span class="line">      &#123; <span class="attr">params</span>: &#123; ... &#125; &#125; <span class="comment">// See the &quot;paths&quot; section below</span></span><br><span class="line">    ],</span><br><span class="line">    fallback: <span class="literal">true</span> or <span class="literal">false</span> <span class="comment">// See the &quot;fallback&quot; section below</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其两个熟悉必须按照指定格式返回：</p><ul><li><code>paths</code>：表示那些路径可以访问该界面。</li><li><code>fallback</code>：表示如果界面查找不到会不会生成备用界面(一般设置为 false 展示 404 界面)。</li></ul><p>例如我们接口返回下面的数据：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attribute">id:</span><span class="string"> 1, title</span>: <span class="string">&#x27;Next入门&#x27;</span>, ....&#125;,</span><br><span class="line">  &#123;<span class="attribute">id:</span><span class="string"> 2, title</span>: <span class="string">&#x27;Next踩坑&#x27;</span>, ....&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么只有访问<code>detailed/1</code>和<code>detailed/2</code>才能访问<code>pages/detailed/[id].jsx</code>界面，否则例如<code>detailed/3</code>都跳转至 404 界面，那么我们可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticPaths</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取数据</span></span><br><span class="line">  <span class="keyword">const</span> source = <span class="keyword">await</span> posts();</span><br><span class="line">  <span class="keyword">const</span> paths = source.data.map(<span class="function">(<span class="params">post</span>) =&gt;</span> <span class="string">`/detailed/<span class="subst">$&#123;post.id&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行接口获取数据，然后拼接 paths 数据，最后将拼接后的数据返回给 Next 完成，这样只有指定的路由才能访问该界面其余的都会到 404 界面。<br>当然我们也可以使用 build 打包，然后我们可以看到另一个由于的现象，也是在<code>.next/server/pages</code>目录下，我们动态路由 detailed 目录下：</p><p><img src="https://img.bipch.cn/2021/03/09/b8edfa7b95d9f.png" alt=""></p><p>可以清除看到<code>getStaticPaths</code>返回的每个数据都会生成一个 html 静态界面，开始有那味了。</p><h3 id="getServerSideProps"><a href="#getServerSideProps" class="headerlink" title="getServerSideProps"></a>getServerSideProps</h3><p>SSR 渲染时会执行的函数，其使用和上面的<code>getStaticProps</code>非常相似，但由于其是服务端渲染，每次请求都触发而不是静态生成界面，所以其有着更多的属性和配置，可以看下其 <a href="https://www.nextjs.cn/docs/basic-features/data-fetching#getserversideprops-server-side-rendering">官网的介绍</a> 这里不多介绍了，其使用方式也是老一套。</p><h2 id="自定义Head"><a href="#自定义Head" class="headerlink" title="自定义Head"></a>自定义Head</h2><p>界面的标题一般都需要虽然界面的跳转进行着修改，我们可以使用 <code>&lt;Head /&gt;</code>轻松做到这样的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Head&gt;</span><br><span class="line">        &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">      &lt;/Head&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>其部署也是非常的简单粗暴，我们可以看下其 webpack 提供的命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next dev&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">  &quot;export&quot;: &quot;next build &amp;&amp; next export&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>export</code>命令是本人添加的，正常只有前三个：</p><ul><li><code>dev</code>：项目的运行命令，进行本地开发使用的命令。</li><li><code>start</code>：启动打包之后代码的命令，Next build之后的代码必须依靠 start 才能启动，启动时也必须确保根目录下含有<code>.next</code>文件夹。</li><li><code>build</code>：上面多次提及此命令，其会将项目进行打包，生成<code>.next</code>文件夹，以供 start 命令运行。</li></ul><p>当然除了上述命令，其还未我们推出了<code>export</code>命令，其也必须依靠<code>.next</code>文件夹，运行之后可将<code>.next</code>文件转换为任何地方都可部署的静态文件，默认输出到<code>out</code>文件夹下，我们可以拿其和<code>.next</code>下的文件做一个对比：</p><p><img src="https://img.bipch.cn/2021/03/09/ac4f4b9724ae7.png" alt="out"></p><p>可以看出其完全是静态界面，我们可以任意将其部署到任意服务器上。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>Next 的部署方式也有多种多样。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>官方对这种方式也有 <a href="https://www.nextjs.cn/docs/deployment#nodejs-%E6%9C%8D%E5%8A%A1%E5%99%A8">介绍</a>，使用起来也是最为方便的一种，直接使用<code>build</code>命令进行打包，然后使用<code>start</code>命令运行其打包的内容，成功之后，我们将端口的安全组进行配置便可以公网访问。</p><h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>虽然 Node 可以直接托管项目，但是不管项目的管理，还是维护都并不是很方便，所以便有了 Node 的服务管理工具 pm2，其目的便是为了托管 Node 服务。<br>安装成功后，在项目的根目录下执行：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 <span class="literal">start</span> npm --name <span class="string">&quot;next&quot;</span> -- run <span class="literal">start</span></span><br></pre></td></tr></table></figure><p>这样也就相当于<code>npm run start</code>了，按照正常逻辑是可以执行的，但是由于 Node 可能无法找到 npm 具体的路径，所以会报出：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Created <span class="keyword">by</span> <span class="built_in">npm</span>, please don<span class="string">&#x27;t edit manually.</span></span><br></pre></td></tr></table></figure><p>该错误表示 npm 具体路径可能无法访问，我们修改其启动命令为：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 <span class="literal">start</span> npm-cli.js绝对路径 --name <span class="string">&quot;next&quot;</span> -- run <span class="literal">start</span></span><br></pre></td></tr></table></figure><p>这样便能指定 npm 运行了。</p><h3 id="vercel"><a href="#vercel" class="headerlink" title="vercel"></a>vercel</h3><p>由原班人马打包的部署的工具，同时也是官网比较推荐的，<a href="/vercel">vercel</a>中进行了一些简单的部署介绍，也可以看其 <a href="https://github.com/vercel/vercel">Github</a> 提供了更详细的部署。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一款轻量级的 React 服务端渲染框架，&lt;a href=&quot;https://github.com/vercel/next.js&quot;&gt;社区&lt;/a&gt; 的活跃度也不错，如果需要使用 React 做一个轻量级的 SSR 类型的项目是个不错的选择(比如个人博客)，其使用起来也是非常的简便。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="React" scheme="https://www.bipch.cn/tags/React/"/>
    
    <category term="服务端渲染" scheme="https://www.bipch.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置https</title>
    <link href="https://www.bipch.cn/nginx-https/"/>
    <id>https://www.bipch.cn/nginx-https/</id>
    <published>2021-01-27T12:17:41.000Z</published>
    <updated>2021-03-07T05:49:54.348Z</updated>
    
    <content type="html"><![CDATA[<p>项目部署的时候，默认遵守为 http 协议，也是应用最为广泛的一种网络协议，而 https 可以称之为安全版的 http，也就是 http + ssl，所以 https 安全的基础便是 ssl。而如果 http 请求需要添加 ssl 证书。</p><span id="more"></span><h2 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h2><p>申请证书的方式有许多，包括阿里云、腾讯云、华为云等都能申请到SSL相关免费的证书。<br>例如申请阿里云免费SSL证书，首先进入<strong>安全（云盾）—&gt; SSL证书</strong>界面：</p><p><img src="https://img.bipch.cn/2021/02/03/829bb4078a9b4.png" alt="SSL证书"></p><p>选择购买证书，然后进入到证书资源包，依次进行选择：</p><p><img src="https://img.bipch.cn/2021/02/03/36be0cd0cd86b.png" alt="证书资源包"></p><p>选择之后，20个资源包其费用为0，直接购买付款便可以，购买完成后，进入我们的SSL列表，便可以看到证书资源包数量以及变为20，点击左侧证书资源包，进行证书的申请：</p><p><img src="https://img.bipch.cn/2021/02/03/29c28a7e670e5.png" alt="证书的申请"></p><p>因为我已经使用过两个，默认是空列表，我们点击头部按钮的证书申请，按照自己的信息，填入域名、个人信息、所在地等完成后，会进行审核，一般不到一分钟便能完成审核，完成后根据服务器类型下载相应的证书(例如Nginx)，得到其压缩包，解压后得到：<code>******.key</code>、<code>******.pem</code>两个文件，这两个便是我们所要的证书文件。</p><h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p>上面得到SSL证书文件之后，使用起来也是很方便，在 Linux 中安装并配置完成 Nginx 配置后，就可以配置指定的端口为 https 协议：</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># HTTP_TO_HTTPS_START</span></span><br><span class="line">    if (<span class="variable">$server_port</span> !~ <span class="number">443</span>)&#123;</span><br><span class="line">        rewrite ^(/.*)$ https://<span class="variable">$host</span><span class="variable">$1</span> permanent<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># HTTP_TO_HTTPS_END</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP_CONFIG_START</span></span><br><span class="line">ssl_certificate    <span class="comment"># *****.pem 文件路径;</span></span><br><span class="line">    ssl_certificate_key     <span class="comment"># *****.key 文件路径;</span></span><br><span class="line">    ssl_protocols TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span><span class="comment">;</span></span><br><span class="line">    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+<span class="number">3</span>DES:RSA+<span class="number">3</span>DES:!MD5<span class="comment">;</span></span><br><span class="line">    ssl_prefer_server_ciphers <span class="literal">on</span><span class="comment">;</span></span><br><span class="line">    ssl_session_cache shared:SSL:<span class="number">10</span>m<span class="comment">;</span></span><br><span class="line">    ssl_session_timeout <span class="number">10</span>m<span class="comment">;</span></span><br><span class="line"><span class="comment"># HTTP_CONFIG_END</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也可以完成了SSL证书的配置，并强制使用 https 协议，注意便是<code>ssl_certificate</code>和<code>ssl_certificate_key</code>两个路径属性的配置，执行<code>nginx -s reload</code>重启 nginx 即可生效配置。生效后会代理 443 端口，然后进行请求转发。</p><h2 id="宝塔配置Https"><a href="#宝塔配置Https" class="headerlink" title="宝塔配置Https"></a>宝塔配置Https</h2><p>我们可以借助宝塔的 nginx 模块，很容易的对项目添加 https 协议，使用宝塔添加完成项目后，进入配置选择SSH，然后选择<code>其它证书</code>，将 .key 文件内容复制到<strong>密钥(KEY)</strong>，另一个内容复制到<strong>证书(PEM格式)</strong>中：</p><p><img src="https://img.bipch.cn/2021/02/03/3de2d5793b07d.png" alt="其它证书"></p><p>输入后直接保存，即可自动完成项目的配置，并且还可以配置强制项目使用 https 协议，如果不是，也会定向到 https 协议中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的方法便能免费申请到阿里云的SSL证书资源包，但是其只能有20个，如果域名过多那便需要进行收费了。不过申请SSL证书的方法也要很多，并不是只有通过阿里云才能实现，这里就先抛砖引玉了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目部署的时候，默认遵守为 http 协议，也是应用最为广泛的一种网络协议，而 https 可以称之为安全版的 http，也就是 http + ssl，所以 https 安全的基础便是 ssl。而如果 http 请求需要添加 ssl 证书。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.bipch.cn/categories/Nginx/"/>
    
    
    <category term="https" scheme="https://www.bipch.cn/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Linux top</title>
    <link href="https://www.bipch.cn/linux-top/"/>
    <id>https://www.bipch.cn/linux-top/</id>
    <published>2021-01-27T07:23:10.000Z</published>
    <updated>2021-03-08T18:45:04.435Z</updated>
    
    <content type="html"><![CDATA[<p>电脑运行时，如果需要查询正在运行的程序和内存占用情况，以及找出那个程序导致我们电脑卡顿，这些都是<code>top</code>命令可以胜任的工作，它能有效的监听电脑进程的运行情况，并提供<code>PID</code>字段可以让用户处理占用 cpu 消耗较大的应用。</p><span id="more"></span><p>首先我的服务器系统为<strong>Centos7.8</strong>，如果不一样那么打印出的信息可能会有些差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; top</span><br></pre></td></tr></table></figure><p>执行完毕后，界面打印出下面信息：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">top - 00:59:04 up 21:49, <span class="number"> 2 </span>users,  load average: 0.09, 0.25, 0.34</span><br><span class="line">Tasks:<span class="number"> 102 </span>total,  <span class="number"> 1 </span>running,<span class="number"> 101 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  7.4 us,  4.4 sy,  0.0 ni, 88.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : <span class="number"> 1014696 </span>total,  <span class="number"> 131908 </span>free,  <span class="number"> 366040 </span>used,  <span class="number"> 516748 </span>buff/cache</span><br><span class="line">KiB Swap: <span class="number"> 1049596 </span>total,  <span class="number"> 777980 </span>free,  <span class="number"> 271616 </span>used.  <span class="number"> 499336 </span>avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND </span><br></pre></td></tr></table></figure><p>可能第一次看着比较乱，但是这些信息将电脑的cpu、内存等资源的使用情况都提供出来了。</p><h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><p>首先其输出分作两部分，<strong>上部分</strong>(1 - 5行)为一些统计的信息，其余则是<strong>下部分</strong>包含所有服务信息的一个表格(由于太多没有列出来，只是列出一个表头)。</p><p>而我们解析只需要从这两部分入手。</p><h3 id="上部分"><a href="#上部分" class="headerlink" title="上部分"></a>上部分</h3><p><strong>第一行：</strong>主要用于显示当前事件、服务器登陆数、系统负载情况。</p><ul><li><code>top</code>：监测时的系统时间(会一直刷新)。</li><li><code>users</code>：系统登陆数。</li><li><code>load average</code>：三个值，分别为过去1分钟、5分钟、15分钟的系统负载。</li></ul><p><strong>第二行：</strong>主要用于显示系统中各个类型进程的个数。</p><ul><li><code>total</code>：系统总进程数。</li><li><code>running</code>：系统运行进程数。</li><li><code>sleeping</code>：系统等待的进程数。</li><li><code>stopped</code>：系统停止的进程数。</li><li><code>zombie</code>：系统被复原的进程数。</li></ul><p><strong>第三行：</strong>该行主要显示按类型划分 cpu 使用情况。</p><ul><li><code>us</code>：用户进程占比。</li><li><code>sy</code>：系统进程占比。</li><li><code>ni</code>：nice 用户进程占比，也就是改变过优先级类型的进程占比。</li><li><code>id</code>：cpu 空闲时间占比，该值越小说明 cpu 越忙。</li><li><code>wa</code>：等待异步操作完成的时间占比。</li><li><code>hi</code>：硬中断占用 cpu 的百分比。</li><li><code>si</code>：软中断占用 cpu 的百分比。</li><li><code>st</code>：”虚拟机管理程序从该虚拟机窃取的时间占比”。</li></ul><p>可以使用 <strong>t</strong>(toggle) 切换折叠 <strong>Task</strong>(第二行) 和 <strong>%Cpu(s)</strong>(第三行) 的展开和折叠。</p><p><strong>第四行与第五行：</strong>主要提供了内存、交换分区的信息。</p><ul><li><code>total</code>：总内存容量。</li><li><code>free</code>：空闲内存。</li><li><code>used</code>：已用内存。</li></ul><h3 id="下部分"><a href="#下部分" class="headerlink" title="下部分"></a>下部分</h3><p>系统中正在运行的进程，默认按照 cpu 使用频率降序排序，我们输入<code>M</code>进行按照内存排序，输入<code>P</code>按照 cpu 使用频率排序。当然如果 cpu 使用频率较高的话，表示程序消耗了许多的资源，也就是造成电脑卡顿的最终祸首。<br>其提供了下面关于服务的信息：</p><ul><li><code>PID</code>：进程的唯一标识符，可以借助 ID 关闭指定的服务。</li><li><code>USER</code>：运行进程的用户。</li><li><code>PR</code>：优先级。</li><li><code>NI</code>：Nice 值，表示进程的优先级。</li><li><code>VIRT</code>：虚拟内存的大小。</li><li><code>RES</code>：常驻内存的大小。</li><li><code>SHR</code>：共享内存的大小。</li><li><code>S</code>：进程的运行状态，<strong>I</strong> 代表空闲、<strong>R</strong> 代表运行、<strong>S</strong> 代表休眠、<strong>Z</strong>表示僵尸进程、<strong>T</strong> 或 <strong>t</strong> 代表停止等。</li><li><code>%CPU</code>：自上次屏幕更新 cpu 的使用率。</li><li><code>%MEM</code>：自上次屏幕更新，<strong>RES</strong>常用内存使用率。</li><li><code>TIME+</code>：自从程序启动后总的 CPU 使用时间。</li><li><code>COMMAND</code>：启动命令。</li></ul><h2 id="cpu使用率较高"><a href="#cpu使用率较高" class="headerlink" title="cpu使用率较高"></a>cpu使用率较高</h2><p>当 cpu 空闲时间较高时，服务器可以正常的工作，当 cpu 空闲较低时，我们的服务器会变得非常的卡，甚至会影像到我们部署到服务器上的各个服务。<br>例如我服务器为阿里云最基础的配置，如果同时在服务器下载多个文件，那么便会出现：</p><p><img src="https://img.bipch.cn/2021/02/03/fadf5610c2839.png" alt="cpu 空闲较小"></p><p>这种情况，可以看到<code>id</code>已经为0，此时服务器会非常的卡，甚至我们部署在服务器上的服务也都是无法进行访问的，此时需要在 top 命令行中输入<code>k</code>，此时程序会给出提示：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID <span class="keyword">to</span> <span class="keyword">signal</span>/kill [<span class="keyword">default</span> pid = <span class="number">30</span>] </span><br></pre></td></tr></table></figure><p>其默认关闭排行第一的服务，也可以自己输入指定程序的<code>PID</code>字段，回车便可以关闭指定的程序，关闭成功后，服务器恢复正常：</p><p><img src="https://img.bipch.cn/2021/02/03/aa81b31b64157.png" alt="cpu 恢复"></p><p>我们可以借助 top 命令查询当前系统的运行状态，其也为我们提供了很多配置帮助我们更好的进行工作，查找指定指定配置我们可以看其为我们提供的<a href="https://man7.org/linux/man-pages/man1/top.1.html">手册</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;电脑运行时，如果需要查询正在运行的程序和内存占用情况，以及找出那个程序导致我们电脑卡顿，这些都是&lt;code&gt;top&lt;/code&gt;命令可以胜任的工作，它能有效的监听电脑进程的运行情况，并提供&lt;code&gt;PID&lt;/code&gt;字段可以让用户处理占用 cpu 消耗较大的应用。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.bipch.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.bipch.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>redux-saga</title>
    <link href="https://www.bipch.cn/react-redux-saga/"/>
    <id>https://www.bipch.cn/react-redux-saga/</id>
    <published>2021-01-26T10:56:17.000Z</published>
    <updated>2021-03-08T19:53:40.738Z</updated>
    
    <content type="html"><![CDATA[<p><code>redux-saga</code> 是一个用于管理应用程序副作用的 redux 中间件，它的目标是让副作用集中处理，然后方便以后的维护和扩展。它和其他解决异步中间件不同，它像进程一样可以主应用程序启动，暂停和取消，也能访问完整的 redux state、dispatch、redux action。</p><span id="more"></span><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>redux-saga 通过监听 action，只需我们发送了指定的 action，便会进行拦截。转换为流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/bpc99/assets@master/redux/flow/redux-saga.jpg" alt="redux-saga流程图.JPG"></p><p>基本可以把 saga 分解为 Worker 和 Watcher：<code>Saga = Worker + Watcher</code>。</p><h2 id="简单的Hello-Word"><a href="#简单的Hello-Word" class="headerlink" title="简单的Hello Word"></a>简单的Hello Word</h2><p>虽然上面说的很难理解，但是通过下面代码可以很好的理解：</p><h3 id="创建-Store-添加中间件"><a href="#创建-Store-添加中间件" class="headerlink" title="创建 Store 添加中间件"></a>创建 Store 添加中间件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入saga中间件</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span>;</span><br><span class="line"><span class="comment">// 创建saga</span></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line"><span class="comment">// 项目添加 saga 中间件</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducer,</span><br><span class="line">    composeWithDevTools(</span><br><span class="line">        applyMiddleware(sagaMiddleware)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="创建监听"><a href="#创建监听" class="headerlink" title="创建监听"></a>创建监听</h3><p>redux-saga 主要工作方式便是监听指定的 action，这一步还是比较重要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery, put, delay &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="comment">// 创建新的任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建监听函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watchIncrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听 INCREMENT_ASYNC ，派发到 incrementAsync 任务</span></span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>, incrementAsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动监听"><a href="#启动监听" class="headerlink" title="启动监听"></a>启动监听</h3><p>简单创建完成后，需要在根目录启动 redux-saga 的监听：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收集到所有的监听</span></span><br><span class="line"><span class="keyword">import</span> &#123; all, fork &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> userSagas <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> all([</span><br><span class="line">        ...Object.values(userSagas)</span><br><span class="line">    ].map(fork));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根目录启动监听</span></span><br><span class="line">sagaMiddleware.run(rootSaga);</span><br></pre></td></tr></table></figure><h2 id="es6-Generator"><a href="#es6-Generator" class="headerlink" title="es6 Generator"></a>es6 Generator</h2><p>主要解决异步执行造成的 <code>地狱回调</code> 问题，可以暂时让函数的执行流挂起。</p><p>在线验证工具：<a href="https://jsbin.com/?js,console">jsbin</a></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>简单的一个示例了解下 Generator 执行过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;start&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello word&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Gen = Generator();</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br></pre></td></tr></table></figure><p>其打印结果为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;start&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;hello word&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="string">&quot;end&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到当我们创建函数时不会立即执行，当我们调用 <code>next</code> 方法时，函数会开始执行，一直到<code>yield</code> 暂停执行，挂起函数，直到下次调用 <code>next</code> 方法。函数运行返回值为一个json，done 表示是否结束，value 是返回值。</p><h3 id="传递参数和接收参数"><a href="#传递参数和接收参数" class="headerlink" title="传递参数和接收参数"></a>传递参数和接收参数</h3><p>当我们代码为下面样子时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="keyword">yield</span> <span class="string">&#x27;start&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="keyword">let</span> age = <span class="keyword">yield</span> <span class="string">&#x27;hello word&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Gen = Generator();</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next(<span class="string">&#x27;blog&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next(<span class="number">23</span>));</span><br></pre></td></tr></table></figure><p>其打印结果为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;start&quot;</span>&#125;</span><br><span class="line"><span class="string">&quot;blog&quot;</span></span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;hello word&quot;</span>&#125;</span><br><span class="line"><span class="number">23</span></span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="string">&quot;end&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>next</code> 方法参数传递给 <strong>上一个</strong> <code>yield</code> 中，达到赋值的效果。</p><h3 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h3><p>那么我们为什么要使用 Generator，其实主要便是为了解决项目中异步代码很容易造成<code>地狱回调</code>，而我们使用 Generator 可以很好的处理异步：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> posts = <span class="keyword">yield</span> fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;posts&#x27;</span>, posts[<span class="number">0</span>].title);</span><br><span class="line">    <span class="keyword">var</span> users = <span class="keyword">yield</span> fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;users&#x27;</span>, users[<span class="number">0</span>].name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> myGen = generator();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">yielded</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!yielded.done) &#123;</span><br><span class="line">            yielded.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> response.json();</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> handle(myGen.next(json));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handle(myGen.next());</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="takeEvery"><a href="#takeEvery" class="headerlink" title="takeEvery"></a>takeEvery</h3><p>很基础的一个方法，用来监测监听 action，每次发送 action 都会进行监听，拦截指定的 action 并分配新的任务：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watchIncrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听拦截 INCREMENT_ASYNC action，派发新的任务</span></span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>, incrementAsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>用来发送新的 action 请求，内部是对 Redux 中 dispath 的一个封装，也是需要接收一个 action 参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; put &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>将程序延迟指定时间后执行，相当于一个延迟函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; put, delay &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样任务延迟 2 秒后会执行 put 发送一个 action。</p><h3 id="takeLatest"><a href="#takeLatest" class="headerlink" title="takeLatest"></a>takeLatest</h3><p>和上面的 <code>takeEvery</code> 基本相同，但是 <code>takeEvery</code> 如果这次异步还没有结束，此时若发送下一次请求，<code>takeEvery</code> 会累计放入执行队列中依次执行，而 <code>takeLatest</code> 不是，它会以取消前面的action，以最后一次发送的 action 为准：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watchIncrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> takeLatest(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>, incrementAsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式和 <code>takeEvery</code> 基本相同。</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>主要是为了帮我们的函数参数作为 call 的参数传入，返回值是一个 js对象。call 作用主要是为了方便我们测试代码，和规范我们项目代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; takeLatest, put, call &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 普通的函数</span></span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">yield</span> axios.get(<span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用call后</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">yield</span> call(axios.get, <span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><p>all 给我们提供了一种并发执行多个异步请求的操作。如果我们接口需要并发执行，则需要使用这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">yield</span> call(axios.get, <span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> all([</span><br><span class="line">        fetchUser(),</span><br><span class="line">        fetchUser(),</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>非阻塞式调用：上面介绍了 call 的使用方式，但是相对于 generator 来说，<strong>call是阻塞式</strong> 的，只有上一个 promise 返回才会执行下一个。而 <strong>fork是非阻塞式</strong> 的，是并发执行所有任务，不用等到上一个任务的promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeLatest, put, call, fork &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> delay = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> fork(delay, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据结果可以看出程序并不会延迟 2 秒后发送 action，而是延迟和发送并发执行，当我们把fork变为call时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> call(delay, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>程序会等待2秒后会发送请求。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>用于取消 fork 还未结束的任务，防止 fork 任务等待时间过长引起其他一些不必要的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">increment</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11111&#x27;</span>);</span><br><span class="line">        <span class="keyword">yield</span> delay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;22222&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="keyword">yield</span> fork(increment);</span><br><span class="line">    <span class="keyword">yield</span> cancel(task);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>当我们需要并发执行多个任务，并不一定需要等待所有操作完成，只需有一个操作完成即可继续执行下面的方法。这就是race方法的用处，它可以并发执行多个请求，只要有一个请求返回，race就正常返回请求，并且取消其余的请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a, b &#125; = <span class="keyword">yield</span> race(&#123;</span><br><span class="line">    a: call(axios.get, <span class="string">&#x27;https://jsonplaceholder.typicode.com/users&#x27;</span>),</span><br><span class="line">    b: call(axios.get, <span class="string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redux-saga 最为 redux 一个非常优秀的中间件，可以为 redux 解决很多问题，包括异步 action、分离逻辑等，在开发中还是很好用的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;redux-saga&lt;/code&gt; 是一个用于管理应用程序副作用的 redux 中间件，它的目标是让副作用集中处理，然后方便以后的维护和扩展。它和其他解决异步中间件不同，它像进程一样可以主应用程序启动，暂停和取消，也能访问完整的 redux state、dispatch、redux action。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="React" scheme="https://www.bipch.cn/tags/React/"/>
    
    <category term="Redux" scheme="https://www.bipch.cn/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Error-first</title>
    <link href="https://www.bipch.cn/error-first/"/>
    <id>https://www.bipch.cn/error-first/</id>
    <published>2021-01-16T17:50:47.000Z</published>
    <updated>2021-03-01T11:46:18.466Z</updated>
    
    <content type="html"><![CDATA[<p>在 Node 这么火的今天，其成功离不开内部高效的事件循环以及异步I/O，整个 Node 的设计从上到下都遵循着异步的概念。而 Node 处理异步指定的标准便是<code>error-first</code>也被称之为<code>错误优先</code>。</p><span id="more"></span><h2 id="error-first"><a href="#error-first" class="headerlink" title="error-first"></a>error-first</h2><p>因为 Node 中存在大量的异步，而处理异步最多的还是传入callback，对于异步任务，必须要指定任务完成后需要执行的回调函数，才能准确的接收到异步任务的执行结果。而随着callback回调越来越多，其传参也越来越多样化，Node 觉得必需对callback指定一个标准，这个标准便是<code>error-first</code>：</p><ol><li>callback函数的第一个参数为 error 对象保留。如果发生异常，异常信息会被放在第一个 err 参数返回。</li><li>callback函数的第二个参数保留给成功的响应数据。如果没发生异常，err参数会传递 null，第二个参数为成功后的返回数据。</li></ol><p>具体代码，可以看 Node fs 提供的回调方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;/foo.txt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error Handling Still Needed!</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们在使用一些 Node 异步的时候也需要注意其规范，这样才能正常接收数据和处理错误。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Node 这么火的今天，其成功离不开内部高效的事件循环以及异步I/O，整个 Node 的设计从上到下都遵循着异步的概念。而 Node 处理异步指定的标准便是&lt;code&gt;error-first&lt;/code&gt;也被称之为&lt;code&gt;错误优先&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://www.bipch.cn/categories/Node/"/>
    
    
    <category term="error-first" scheme="https://www.bipch.cn/tags/error-first/"/>
    
  </entry>
  
  <entry>
    <title>Koa2</title>
    <link href="https://www.bipch.cn/node-koa2/"/>
    <id>https://www.bipch.cn/node-koa2/</id>
    <published>2021-01-16T17:50:47.000Z</published>
    <updated>2021-03-07T06:12:25.734Z</updated>
    
    <content type="html"><![CDATA[<p>一个非常流行的基于 Node 平台的 web 开发框架，优点便是非常小，但是扩展性却极其强。非常的干净利落。和另外一个比较的开发框架 Express 作用是相同的。</p><span id="more"></span><h2 id="koa2-和-express-的区别"><a href="#koa2-和-express-的区别" class="headerlink" title="koa2 和 express 的区别"></a>koa2 和 express 的区别</h2><p>虽然 koa2 和 express 作用是相同的，并且都是原班人马打造的，但是两者使用的区别还是很大的。</p><ol><li><code>集成度</code>：koa2 是一个非常轻量级的开发框架，里面并没有继承太多的插件，例如实现 Router 还需要安装<code>koa-router</code>、加载文件需要<code>koa-static</code>，而 express 内置了大量的插件，包括router、文件等插件都进行了内置。</li><li><code>社区活跃度</code>：由于 express 是一款比较成熟的框架，其上手难度是比较小的，并且其社区活跃度远高于 koa2，截至本篇文章，在 npm 上对比其插件的数量如下：<br> <img src="https://img.bipch.cn/2021/02/03/9c0ccb441a373.png" alt="express"><br> <img src="https://img.bipch.cn/2021/02/03/4f5e28876c850.png" alt="koa"><br> 可以看出差别还是很大的。</li><li><code>中间件</code>：express 的中间件是一款典型的线性模型，也就是自上而下依次去执行，而 koa 中间件是洋葱模型。</li></ol><h2 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h2><p>关于 koa 中间件有一个很形象的图片：</p><p><img src="https://img.bipch.cn/2021/02/03/9a9139039a0d4.png" alt="koa"></p><p>可以看出其开始的时候，是依次开始执行，执行到<code>next</code>便会执行下一个中间件，而结束的时候是像<strong>栈</strong>操作一样，先进入的是最后去执行的。<br>例如我们可以方便的添加日志，记录每个接口的请求信息与时间：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一层 - 开始&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> ----------- <span class="subst">$&#123;ctx.url&#125;</span> ----------- <span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一层 - 结束&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二层 - 开始&#x27;</span>)</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二层 - 结束&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>这样便通过第一个中间件打印日志信息，当执行到<code>next</code>方法时，会执行下一个中间件直到结束碰到<code>ctx.body</code>，然后进行出栈操作。所以上面代码执行后打印出下面信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一层 - 开始</span><br><span class="line">第二层 - 开始</span><br><span class="line">第二层 - 结束</span><br><span class="line">打印第一次执行的结果： GET -------- / ------ 6ms</span><br><span class="line">第一层 - 结束</span><br></pre></td></tr></table></figure><h2 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h2><p>由于 koa 并未内置是一款小型轻量级的开发框架，并未内置过多的插件，所以一些功能需要借助一些插件来完成，例如路由的实现可以依靠<code>koa-router</code>。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 方式比较方便，并且动态路由传递方式也很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)();</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logs</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> url <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// post router</span></span><br><span class="line">router.get(<span class="string">&#x27;/:name&#x27;</span>, <span class="function">(<span class="params">&#123;params&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello &#x27;</span> + params.name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router middleware</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>这样可以直接 get 方式请求 <a href="http://localhost:3000/koa2">http://localhost:3000/koa2</a> 最后可以返回正确的数据。</p><h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3><p>上面的形式只能处理简单的路径传参，但是参数复杂或者通过别的形式传参，就需要通过<code>koa-bodyparser</code>中间件处理传递过来的数据了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add koa-bodyparser middleware</span></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line"><span class="comment">// logs</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> url <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// post params</span></span><br><span class="line">router.post(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> params = ctx.request.body;</span><br><span class="line">    ctx.response.body = <span class="string">`&lt;h1&gt;post，<span class="subst">$&#123;params.name&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get params</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> params = ctx.request.query;</span><br><span class="line">    ctx.response.body = <span class="string">`&lt;h1&gt;get，<span class="subst">$&#123;params.name&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router middleware</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用<code>Insomnia</code>可以测试我们的接口：</p><p><img src="https://img.bipch.cn/2021/02/08/c48f8de1480bf.png" alt="koa-bodyparser"></p><p>可以看出接口返回了正确的数据。</p><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><p>项目中会有些接口是需要一定的权限或者登陆后才能进行访问的，有些接口一些字段是不能重复的，但是如果将代码都重新写一遍会消耗大量的时间，同时也不利于维护，而解决方式便可以使用中间件去解决。<br>例如：一些接口需要登陆之后才能继续访问，否则返回前端<code>401</code>，那我们只需判断前端是否传入 token 和其正确性即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> checkUserMiddleware = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.request.headers[<span class="string">&quot;authorization&quot;</span>]) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> Authentication is also required</span></span><br><span class="line">        <span class="keyword">await</span> next()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 登陆失败，禁止继续执行，所以不需要执行 next()</span></span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        status: <span class="number">401</span>,</span><br><span class="line">        msg: <span class="string">&#x27;token 失效&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> checkUserMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">router.post(<span class="string">&#x27;/info&#x27;</span>, checkUserMiddleware, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样没有接口需要登陆拦截，添加上述中间件即可。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>API 开发完成后，可以直接再服务器通过 Node 运行项目完成部署，但是由于 Node 即不容易管理，并且相关 doc 窗口关闭服务便会停止，所以我们需要一个 Node 的服务管理工具，这里推荐 <a href="https://pm2.keymetrics.io/">pm2</a>。<br>启动命令很简单：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 <span class="literal">start</span> 启动文件</span><br></pre></td></tr></table></figure><p>也可以通过下面方式查看所有托管的服务：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p<span class="name">m2</span> list</span><br></pre></td></tr></table></figure><p>也可以使用<code>pm2 init</code>生成默认的配置文件 <strong>ecosystem.config.js</strong>，也可以配置启动命令，例如贴出我的简单配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;</span><br><span class="line"><span class="comment">// 启动名称</span></span><br><span class="line">    name: <span class="string">&#x27;api&#x27;</span>,</span><br><span class="line"><span class="comment">// 启动文件</span></span><br><span class="line">    script: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line"><span class="comment">// 监听改变</span></span><br><span class="line">    watch: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 忽略监听</span></span><br><span class="line">    ignore_watch: [ <span class="string">&quot;node_modules&quot;</span> ]</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment">// 部署配置</span></span><br><span class="line">  deploy: &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一个简单的 pm2 配置便完成了，然后使用下面命令启动：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ecosystem.<span class="built_in">config</span>.js</span><br></pre></td></tr></table></figure><p>即可完成服务托管。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个非常流行的基于 Node 平台的 web 开发框架，优点便是非常小，但是扩展性却极其强。非常的干净利落。和另外一个比较的开发框架 Express 作用是相同的。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://www.bipch.cn/categories/Node/"/>
    
    
    <category term="Koa2" scheme="https://www.bipch.cn/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>Vue $set</title>
    <link href="https://www.bipch.cn/vue-set/"/>
    <id>https://www.bipch.cn/vue-set/</id>
    <published>2021-01-14T10:25:49.000Z</published>
    <updated>2021-03-07T12:46:29.670Z</updated>
    
    <content type="html"><![CDATA[<p>在 Vue 中其核心便是<code>数据劫持-数据订阅</code>，数据劫持主要劫持 data 对象的所有 property，并使用 <code>Object.defineProperty</code> 把所有 property 添加  getter/setter 方法。但是由于 Object.defineProperty 不能劫持整个对象，只能劫持对象的一个个属性，并且不能监听数组、对象属性等，所以在 Vue 中数组或者对象属性改变是监听不到的，而<code>$set</code>便是为了解决这些问题。</p><span id="more"></span><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p>Object.defineProperty 方法主要用于劫持 JavaScript 对象，当我们访问相应对象时，会执行相应的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;123&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;......&#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;......&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.name = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.name);</span><br></pre></td></tr></table></figure><p>通过上述代码便监听了 object1 的 name 属性，一旦修改或读取便会调用相应的 getter/setter 方法，一旦数据有修改 defineProperty 便会监听到，执行一系列逻辑。</p><h2 id="defineProperty-监听对象"><a href="#defineProperty-监听对象" class="headerlink" title="defineProperty 监听对象"></a>defineProperty 监听对象</h2><p>在 Vue 官网却有着下面的一句话：<strong>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</strong><br>造成该问题的原因便是因为 defineProperty 不能监听整个对象，只能遍历对象的各个属性，例如我们有下面的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;123&#x27;</span>, </span><br><span class="line">  age : <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>监听这种数据，只能递归调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归，确保每个属性都被监听</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(data, key, data[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听指定数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 确保子元素监听</span></span><br><span class="line">  Observer(val);</span><br><span class="line">  <span class="comment">// 开启监听</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 不可删除</span></span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我捕获到了数据变化: &#x27;</span>, val, <span class="string">&#x27; --&gt; &#x27;</span>, newVal);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听的数据</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;123&#x27;</span>, </span><br><span class="line">  age : <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line">Observer(obj);</span><br></pre></td></tr></table></figure><p>这样递归才能实现对象的监听，但是这样也造成了：<strong>数组</strong> 和 <strong>对象</strong> 新增属性都是无法触发 setter 的(除了数组的 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code> 因为它们都修改原数据)。<br>而 Vue 并不会去解决这个问题，因为这是 defineProperty 方法的特性，刻意解决只会造成性能的浪费，而为了解决这个问题，便提出了 <code>$set</code> 方法。</p><h2 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h2><p>因为 Vue 提倡使用<code>$set</code> 进行数组等数据的修改，其主要接收 3 个参数：</p><ol><li><code>target</code>：需要添加属性的对象，也就是我们要在那个对象上面添加属性。</li><li><code>key</code>：新增属性的 key，也就是我们新增属性的索引。</li><li><code>val</code>：新增属性的值，我们要添加进的值。</li></ol><p>我们打开其源码，位于：<strong>src/core/observer/index.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target: <span class="built_in">Array</span> &lt; any &gt; | <span class="built_in">Object</span>, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主要用于判断是不是基本数据类型</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组的处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">        <span class="comment">// 利用  splice 实现数组替换</span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象，并且该属性原来已存在于对象中，则直接更新</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// vue给响应式对象(比如 data 里定义的对象)都加了一个 __ob__ 属性，</span></span><br><span class="line">  <span class="comment">// 如果一个对象有这个 __ob__ 属性，那么就说明这个对象是响应式对象，我们修改对象已有属性的时候就会触发页面渲染。</span></span><br><span class="line">  <span class="comment">// 非 data 里定义的就不是响应式对象。</span></span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是响应式对象，进行依赖收集</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  <span class="comment">// 触发更新视图</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下上面的流程大致如下：</p><ol><li>首先判断数据是否为<strong>对象</strong>类型，如果是普通类型的属性，则会抛出异常。</li><li>判断是否为<strong>数组</strong>，并且 key 值是否为有效的，如果成功则选择数组长度和 key 值获取最大的数值，作为数组新的 length 值，并且使用 splice 方法进行替换。</li><li>判断数据值是否为响应的 _ob_：</li></ol><ul><li>如果是 Vue实例，直接不行，抛出错误。</li><li>如果不是响应数据，就是普通的修改数据对象操作。</li><li>如果是响应数据，那就通过 Object.defineProperty 进行数据的劫持。</li></ul><ol start="4"><li>通知 DOM 进行数据更新。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Vue 中其核心便是&lt;code&gt;数据劫持-数据订阅&lt;/code&gt;，数据劫持主要劫持 data 对象的所有 property，并使用 &lt;code&gt;Object.defineProperty&lt;/code&gt; 把所有 property 添加  getter/setter 方法。但是由于 Object.defineProperty 不能劫持整个对象，只能劫持对象的一个个属性，并且不能监听数组、对象属性等，所以在 Vue 中数组或者对象属性改变是监听不到的，而&lt;code&gt;$set&lt;/code&gt;便是为了解决这些问题。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="Vue" scheme="https://www.bipch.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://www.bipch.cn/es6-promise/"/>
    <id>https://www.bipch.cn/es6-promise/</id>
    <published>2021-01-13T10:32:04.000Z</published>
    <updated>2021-03-07T06:42:19.487Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是异步编程的一种解决方案，由 ES6 将其写进了语言标准，统一了用法，并原生提供了Promise 对象。Promise 要用于解决前端代码中异步操作的处理，可以将异步操作队列化，使其按照指定的顺序执行，可以很好的解决代码中出现<code>回调地狱</code>的问题。</p><span id="more"></span><h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>主要前端代码需要处理多个函数，并且下一个函数的参数为前一个参数的返回值，这样便会造成回调地狱的问题。虽然看着定义有点绕，但是看下面代码就能看出回调地狱的问题了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">startRequest1(url, <span class="function">(<span class="params">err1, res1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err1) <span class="keyword">return</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(err1.errorMsg);</span><br><span class="line">  startRequest2(res1, <span class="function">(<span class="params">err2, res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err2) <span class="keyword">return</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(err2.errorMsg);</span><br><span class="line">      startRequest3(res2, <span class="function">(<span class="params">err3, res3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err3) <span class="keyword">return</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(err3.errorMsg);</span><br><span class="line">        ....</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样嵌套下去，每一次都需要处理错误，然后处理下一个请求，一旦有一个请求错误，异常也很难处理，并且代码可读性非常的低、也极难维护。</p><h2 id="特点和缺点"><a href="#特点和缺点" class="headerlink" title="特点和缺点"></a>特点和缺点</h2><p>Promise可以链式的处理项目中的异步操作，并提供了一系列的API，可以设置成功、失败等时候的函数调用，这样使得控制异步操作更容易。<br>Promise主要有2个特点：</p><ol><li><strong>对象状态不受外界影响</strong>。Promise主要有3中状态 <code>Pending</code>(进行中)、<code>Fulfilled</code>(已执行)、<code>Rejected</code>(已拒绝)。只有处理异步操作的结果，可以决定是哪一种状态，任何操作都无法改变这个状态。</li><li><strong>状态修改后，就不会发送改变，任何时候都可以得到这个结果</strong>。Promise的状态修改只有两种情况：<ol><li>从Pending状态变为Resolved状态。</li><li>从Pending状态变为Rejected状态。</li></ol></li></ol><p>只有这两种情况，一旦修改状态便被锁定了，不会在发送变化了。</p><p>Promise也不是都是优点，虽然解决了<code>回调地狱</code>的问题，但是也是有一些缺点的:</p><ol><li>Promise一旦创建便无法取消，只能一路走下去。</li><li>如果不设置处理函数，无论成功、还是失败都不会返回到外部，换句话说Promise内的错误是无法在外面用 <strong>try{…}catch(){…}</strong> 捕捉的，只能在错误执行函数中执行错误。</li><li>状态无法预测，无法得知异步操作具体执行到那一步了。<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2>一般 Promise 代码为下面的格式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(...)&#123;</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">  resolve(data);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 失败</span></span><br><span class="line">  reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 请求成功</span></span><br><span class="line">...</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>使用 Promise 对象创建一个 p，执行里面逻辑，然后注册 then 中的成功和失败事件。<h3 id="new-Promise"><a href="#new-Promise" class="headerlink" title="new Promise"></a>new Promise</h3></li></ol><ul><li>构造函数接收一个函数作为参数。</li><li>创建 Promise 时，会自动执行。</li><li>参数函数主要有 resolve 和 reject 两个参数。</li><li>在Promise执行过程中调用 resolve 函数状态将变为 fulfilled，调用 reject 时状态变成 rejected，它们可以接收参数，相应的参数都会传递给下一个方法中。</li></ul><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>then 主要有两个参数，分别对应两种状态，接收的数据为上一个方法传递的数据：</p><ul><li>当Promise的状态为 fulfilled 时，会执行第一个函数参数。</li><li>当Promise的状态为 rejected 时，会执行第二个函数参数。<h2 id="解决回调地狱"><a href="#解决回调地狱" class="headerlink" title="解决回调地狱"></a>解决回调地狱</h2>上面介绍了一些地狱回调的问题，下面开始用 Promise 解决该问题：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">startRequest1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest2(res))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest3(res))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest4(res))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest5(res))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>对比下上面地狱回调代码，代码通过Promise会变得非常的简明。    <h2 id="异步并发"><a href="#异步并发" class="headerlink" title="异步并发"></a>异步并发</h2>如果多个并发的执行，只有获取全部完成后，才会返回结果。用普通的方式来编写那便是下面的代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tasks = [getData1, getData2, getData3, getData4, getData5];</span><br><span class="line"><span class="keyword">let</span> datas = [];</span><br><span class="line"></span><br><span class="line">tasks.map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  res(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  datas.push(data);</span><br><span class="line">  <span class="keyword">if</span> (datas.length === tasks.length) &#123;</span><br><span class="line">      <span class="comment">// 已经全部请求完了，此时可以调用回调</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>上面通过编辑成功后通过回调传入，一旦执行完成便会进入if。很麻烦啊，Promise 提供更方便的 API：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  getData1,</span><br><span class="line">  getData2,</span><br><span class="line">  getData3,</span><br><span class="line">  getData4,</span><br><span class="line">  getData5</span><br><span class="line">]).then(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 已拿到全部的data，可以处理了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>对比很明显，Promise可以将我们的请求更清晰明了。</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li><code>then</code>: 上面介绍了then用法，主要用于链式进行调用。</li><li><code>catch</code>: 主要用于捕获Promise里面的异常，应为Promise内的异常无法用 try 进行捕获。</li><li><code>finally</code>: 无论Promise对象最终是成功还是失败都会去执行其中方法。</li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Promise除了提供一些实例方法，还提供了一些静态的方法：</p><ul><li><code>all</code>: 主要处理并发请求。</li><li><code>race</code>: 和上面all相似，但是all是都成功才会调用回调，而race(赛跑)也是并发，但是一旦有一个请求完成，便会立即停止(不管结果本身是成功状态还是失败状态)。</li><li><code>resolve</code>: 返回一个状态为fulfilled的Promise对象，它的参数会传递给下面的回调函数中去。</li><li><code>reject</code>: 和上面的基本同理，只是Ppromise的状态不同。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到通过Promise创建实例，然后通过链式调用 .then.then.then 开始编码，这便是Promise的使用形式，可以看到它基本模式是：</p><ul><li>可以将异步转换为Promise。</li><li>对象主要有3中状态(Pending(进行中)、Fulfilled(已执行)、Rejected(已拒绝))。</li><li>通过 .then 进行调用。</li><li>完成后触发相应的回调。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Promise 是异步编程的一种解决方案，由 ES6 将其写进了语言标准，统一了用法，并原生提供了Promise 对象。Promise 要用于解决前端代码中异步操作的处理，可以将异步操作队列化，使其按照指定的顺序执行，可以很好的解决代码中出现&lt;code&gt;回调地狱&lt;/code&gt;的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="ES6" scheme="https://www.bipch.cn/tags/ES6/"/>
    
    <category term="异步" scheme="https://www.bipch.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Mongoose聚合查询</title>
    <link href="https://www.bipch.cn/Mongoose-aggregate/"/>
    <id>https://www.bipch.cn/Mongoose-aggregate/</id>
    <published>2020-12-22T07:02:21.000Z</published>
    <updated>2021-03-08T19:52:29.612Z</updated>
    
    <content type="html"><![CDATA[<p>在 MongoDB 中，聚合(<code>aggregate</code>)主要可以用于多个表之间的联合查询，并且可以进行求和、求平均值、最大与最小值等，在项目中使用也是非常的方便，下面主要是一些常用的操作，更多详细的可以看其<a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/">官方文档</a>。</p><span id="more"></span><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>日常开发中经常这些场景，比如文章都有类别字段，而一个类别可以对应多个文章，我们如果需要统计每个类别下的所有文章便可以通过<code>aggregate</code>进行查询，或者我们需要统计每个时间段发布的文章做个归档，也可以使用其来完成。</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>常规的定义为：<code>db.collection.aggregate(pipeline, options)</code><br>主要接收两个参数，其中 <strong>pipeline</strong> 表示数据联立等操作，而 <strong>options</strong> 则为数据库的配置，这里就不多说该属性了。而 <strong>pipeline</strong> 常用的属性有：</p><ol><li><code>$project</code>：用于指定返回的字段，字段可以是文档中的，也可以添加新的字段，或者排除某个字段。</li><li><code>$match</code>：用于过滤文档，可以只返回服务我们条件的。</li><li><code>$limit</code>：用于限制最后查询出的数据，可以配合下面的进行数据分页。</li><li><code>$skip</code>：用于跳过指定条数的数据，可以用于实现分页。</li><li><code>$unwind</code>：拆分数据，将一条数据拆分为多条。</li><li><code>$group</code>：对文档中的数据进行分组，可用于分组或者统计。</li><li><code>$sort</code>：根据某些字段进行数据的排序。</li><li><code>$geoNear</code>：距指定点最近到最远的顺序输出文档。</li><li><code>$lookup</code>：用于将数据进行汇总。</li></ol><h2 id="lookup-数据填充"><a href="#lookup-数据填充" class="headerlink" title="$lookup(数据填充)"></a>$lookup(数据填充)</h2><p>当一个文章类型对应多个文章，而每个文章仅仅对应一个类型，大致为(一对多)，我们要再文章集合中填充类型的信息，便需要该查询方式了。<br>其基本格式为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   $lookup:</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">from</span>: <span class="xml"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">to</span> <span class="attr">join</span>&gt;</span>,</span></span><br><span class="line">       localField: &lt;field from the input documents&gt;,</span><br><span class="line">       foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;,</span><br><span class="line">       as: &lt;output array field&gt;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们有下面的 <strong>post</strong> 集合数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">2</span> &#125;,</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">8</span>  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>同样还需要一个 <strong>type</strong> 集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;name&quot;</span> : <span class="string">&quot;web&#125;,</span></span><br><span class="line"><span class="string">   &#123; &quot;</span>_id<span class="string">&quot; : 8, &quot;</span>name<span class="string">&quot; : &quot;</span>数据库<span class="string">&quot; &#125;</span></span><br><span class="line"><span class="string">])</span></span><br></pre></td></tr></table></figure><p>我们如果需要将指定的 <strong>type</strong> 信息填充到 <strong>post</strong> 中便可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.post.aggregate([</span><br><span class="line">   &#123;</span><br><span class="line">     $lookup:</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">from</span>: <span class="string">&quot;type&quot;</span>,</span><br><span class="line">         localField: <span class="string">&quot;type&quot;</span>,</span><br><span class="line">         foreignField: <span class="string">&quot;_id&quot;</span>,</span><br><span class="line">         <span class="keyword">as</span>: <span class="string">&quot;typeInfo&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>这样便通过<code>$lookup</code>完成了字段填充，<strong>from</strong> 表示需要联接的集合，<strong>localField</strong> 表示需要和集合进行联立的字段，<strong>foreignField</strong> 表示集合中用于和 localField 对应的字段，<strong>as</strong> 表示别名。其结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>,</span><br><span class="line"><span class="attr">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line"><span class="attr">&quot;type&quot;</span> : <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;typeInfo&quot;</span>: [</span><br><span class="line">&#123; <span class="attr">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;web&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line"><span class="attr">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>,</span><br><span class="line"><span class="attr">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line"><span class="attr">&quot;type&quot;</span> : <span class="number">8</span>,</span><br><span class="line"><span class="attr">&quot;typeInfo&quot;</span>: [</span><br><span class="line">&#123; <span class="attr">&quot;_id&quot;</span> : <span class="number">8</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;数据库&quot;</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>当然我们不可能只遇到一对多，有时甚至需要多对多进行填充，这么我们可以先借助<code>$unwind</code>展开数组，然后再填充数据。</p></blockquote><h2 id="group-分组"><a href="#group-分组" class="headerlink" title="$group(分组)"></a>$group(分组)</h2><p>当文章有添加日期，我们需要根据添加日期的年份对文章进行分组，这样便可以统计每年新增的文章。<br>默认的格式为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $group:</span><br><span class="line">    &#123;</span><br><span class="line">      _id: &lt;expression&gt;, <span class="comment">// Group By Expression</span></span><br><span class="line">      &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要先创建一个 <strong>post</strong> 集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">2</span>, <span class="attr">createdAt</span>: <span class="string">&quot;2021-03-03 03-08:50&quot;</span>&#125;,</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">8</span>, <span class="attr">createdAt</span>: <span class="string">&quot;2020-12-03 09-05:40&quot;</span>  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>我们可以很轻松的对数据分组，分组之前可以先通过<code>$project</code>筛选出需要的字段，<code>$sort:</code>对选中的数据排序整理数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">db.post.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      _id: <span class="number">1</span>,</span><br><span class="line">      title: <span class="number">1</span>,</span><br><span class="line">      createdAt: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $sort: &#123;</span><br><span class="line">      createdAt: -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &#123;</span><br><span class="line">        $dateToString: &#123; <span class="attr">format</span>: <span class="string">&quot;%Y&quot;</span>, <span class="attr">date</span>: <span class="string">&quot;$createdAt&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      posts: &#123; <span class="attr">$push</span>: <span class="string">&quot;$$ROOT&quot;</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $sort: &#123;</span><br><span class="line">      _id: -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>$group</code>中 <strong>_id</strong> 表示用于分组的字段，其内部的<code>$dateToString</code>表示格式化数据，因为我们需要按照年份进行分组，所以要提取出日期中的年份。posts 为数据名称<code>$push</code>表示对每个分组添加进数据，<code>$$ROOT</code>表示分组出数据的所有字段(可以和 $project 结合使用)。</p><p>最后返回数据格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> <span class="string">&quot;2021&quot;</span></span><br><span class="line">    &#x27;posts&#x27;: [</span><br><span class="line">      &#123;&quot;_id&quot; : 1, &quot;title&quot; : &quot;React&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 2, createdAt: &quot;2021-03-03 03-08:50&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> <span class="string">&quot;2020&quot;</span></span><br><span class="line">    &#x27;posts&#x27;: [</span><br><span class="line">      &#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;mongodb&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 8, createdAt: &quot;2020-12-03 09-05:40&quot;  &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unwind-数组统计"><a href="#unwind-数组统计" class="headerlink" title="$unwind(数组统计)"></a>$unwind(数组统计)</h2><p>可以用于展开数组的字段，例如我们需要统计数组中每个字段出现的次数。<br>需要先创建一个 <strong>post</strong> 集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">   <span class="string">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>,</span><br><span class="line">   <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line">   <span class="string">&quot;type&quot;</span> : <span class="number">2</span>,</span><br><span class="line">   tags: [<span class="string">&quot;web&quot;</span>]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">   <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">   <span class="string">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>,</span><br><span class="line">   <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line">   <span class="string">&quot;type&quot;</span> : <span class="number">8</span>,</span><br><span class="line">   tags: [<span class="string">&quot;web&quot;</span>, <span class="string">&quot;数据库&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>我们需要统计数组中每个 <strong>tag</strong> 出现的次数，那么我们可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.post.aggregate([&#123;</span><br><span class="line">$project: &#123;</span><br><span class="line">tags: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">$unwind: <span class="string">&quot;$tags&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">$group: &#123;</span><br><span class="line">_id: <span class="string">&quot;$tags&quot;</span>,</span><br><span class="line">sum: &#123;</span><br><span class="line">$sum: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><p>这样先通过<code>$project</code>筛选出需要的字段，然后通过<code>$unwind</code>展开指定字段，最后使用<code>$group</code>进行累加的操作。最后计算的结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;<span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;web&quot;</span>, <span class="attr">&quot;sum&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;数据库&quot;</span>, <span class="attr">&quot;sum&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 MongoDB 中，聚合(&lt;code&gt;aggregate&lt;/code&gt;)主要可以用于多个表之间的联合查询，并且可以进行求和、求平均值、最大与最小值等，在项目中使用也是非常的方便，下面主要是一些常用的操作，更多详细的可以看其&lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.bipch.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MongoDB" scheme="https://www.bipch.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://www.bipch.cn/XSS/"/>
    <id>https://www.bipch.cn/XSS/</id>
    <published>2020-12-10T02:35:40.000Z</published>
    <updated>2021-03-02T05:02:03.164Z</updated>
    
    <content type="html"><![CDATA[<p><strong>XSS</strong> 是 <strong>跨域脚本攻击</strong> 的简称，表示有人不怀好心在 Web 界面中插入恶意的 Script 代码，用户浏览界面的时候，恶意嵌入的 Web 里面的恶意 Script 就会被执行，从而达到恶意攻击用户的目的。</p><span id="more"></span><h2 id="XSS攻击方式"><a href="#XSS攻击方式" class="headerlink" title="XSS攻击方式"></a>XSS攻击方式</h2><p>恶意插入 JavaScript 代码，主要在一些简单的留言板、富文本展示等界面，如果有用户在代码中恶意添加下面一行代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(“hey!you are attacked”)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么后面解析到这一句话的时候，Script 代码便会被执行到，界面便会出现弹框，这便是简单的 XSS 攻击方式。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其原理就是在我们渲染 <strong>html</strong> 代码时，传入可执行的 <strong>JavaScript</strong> 代码，例如通过数据库保存为可执行代码，或者路径传参为可执行代码。<br>例如我们可以在一些文本框中输入下面内容：<br><img src="https://upload-images.jianshu.io/upload_images/7455247-39bd5204a1c40823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp" alt=""><br>这样的一段代码一旦保存到数据库中，这个 JavaScript 代码便会立即执行。也就是界面会出现下面的情况：<br><img src="https://upload-images.jianshu.io/upload_images/7455247-7df7eea8d898458c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1038/format/webp" alt=""><br>这便是 XSS 攻击的简单原理，简单来说便是将可执行的恶意 JavaScript 代码插入到界面中，使其被执行，并且它不只可以引入一小段 JS 代码，甚至我们可以直接引入一段可执行的 JS 的脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;*******&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况下脚本中代码甚至都会去执行，而在脚本中我们可以随意执行，并且可以获取到项目的私密信息，可以说对项目的危害还是非常大的。</p><h2 id="XSS过滤"><a href="#XSS过滤" class="headerlink" title="XSS过滤"></a>XSS过滤</h2><p>既然 <strong>XSS漏洞</strong> 危害那么大，那么  <strong>XSS漏洞</strong> 很好利用吗？肯定不是的，因为我们有许多的方式可以过滤掉 <strong>XSS漏洞</strong> 的攻击。</p><h3 id="过滤不合法信息"><a href="#过滤不合法信息" class="headerlink" title="过滤不合法信息"></a>过滤不合法信息</h3><p>我们可以将输入或者传入的内容中不合法信息都进行过滤，从而保证项目中数据的安全性。<br>比如移除用户输入的 DOM 属性，例如过滤掉 <strong>onclick</strong>、<strong>onerror</strong>、<strong>onload</strong> 等相关的 DOM 事件，并且移除一些用户定义的节点，例如过滤掉 <strong>&lt;style&gt;</strong>、<strong>&lt;script&gt;</strong>、<strong>&lt;iframe&gt;</strong> 等节点。</p><blockquote><p>注意：不是所有的 JavaScript 都要在 &lt;script&gt; 中才能执行，放在 &lt;img onerror=”alert(0)” src=”wwww” /&gt; 也是可以正常执行的，所以一些 DOM 事件也有必要进行过滤。</p></blockquote><h3 id="对特殊字符串进行编码"><a href="#对特殊字符串进行编码" class="headerlink" title="对特殊字符串进行编码"></a>对特殊字符串进行编码</h3><p>我们不仅需要对于输入或者传入的数据进行过滤，在前端渲染或后台保存的时候，我们还需要对字符串进行 HTML Entity 的编码处理，因为有时为了攻击网站，还可以使用一些转移的字符如：<code>&quot;&lt;&quot;</code>可以替换为<code>&amp;lt;</code>、<code>&quot;&gt;&quot;</code>可以替换为<code>&amp;gt;</code>等字符转码可以绕过一些过滤。</p><blockquote><p>并且能绕过匹配的不仅有特殊字符串，如果项目中判断不完全甚至可以用大小写绕过，例如我们这样写：&lt;scRIpt&gt;********&lt;scRIpt/&gt; 是能正常运行的，因为 JavaScript 是不区分大小写的。</p></blockquote><h3 id="httpOnly"><a href="#httpOnly" class="headerlink" title="httpOnly"></a>httpOnly</h3><p>不将信息存储到 web Storage，而存储到 <strong>cookie</strong> 中，并且为 cookie 设置为无法被读写的，为其设置上<code>httpOnly</code>，这样之后使用 JS 便不能读写 cookie 数据。</p><h3 id="限制长度"><a href="#限制长度" class="headerlink" title="限制长度"></a>限制长度</h3><p>因为需要添加一些可执行的 JS 代码，会是很长的一段代码，所以我们可以限制一些代码的长度，避免出现过长的代码，也可以进行简单的长度限制。</p><h2 id="XSS绕开过滤"><a href="#XSS绕开过滤" class="headerlink" title="XSS绕开过滤"></a>XSS绕开过滤</h2><p>道高一尺魔高一丈，项目中有很多避免 XSS 漏洞的方式，但 XSS 的攻击方式也是多种多样。</p><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>上面已经介绍过，因为 JavaScript 是一种弱文本语言，并其不区分大小写，所以我们可以利用这点进行攻击，例如添加下面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scrIPt</span>&gt;</span><span class="javascript">alert(<span class="string">&quot;hello world&quot;</span>)</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果项目判断不谨慎，很容易被该方式偷鸡。</p><h3 id="利用过滤语句进行攻击"><a href="#利用过滤语句进行攻击" class="headerlink" title="利用过滤语句进行攻击"></a>利用过滤语句进行攻击</h3><p>一种技巧，因为大部分项目都对 &lt;script&gt; 标签进行了过滤，那么我们便可以利用这一点对齐进行攻击。例如这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scRi<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">pt&gt;alert(<span class="string">&quot;hello world&quot;</span>)&lt;/scRi</span><span class="tag">&lt;/<span class="name">script</span>&gt;<span class="name">pt</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然这样代码看起来什么也不是，但是经过其过滤掉 &lt;script&gt; 标签后，会出现下面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scRipt</span>&gt;</span><span class="javascript">alert(<span class="string">&quot;hello world&quot;</span>)</span><span class="tag">&lt;/<span class="name">scRipt</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正好利用其过滤形成一条可执行语句，也是一种小技巧。</p><h3 id="并不是只有-script-标签才能插入可执行代码"><a href="#并不是只有-script-标签才能插入可执行代码" class="headerlink" title="并不是只有 script 标签才能插入可执行代码"></a>并不是只有 script 标签才能插入可执行代码</h3><p>我们并不是只有插入 &lt;script&gt;  才能执行 JS 的代码，我们可以使用 DOM标签 绑定事件，事件中可执行 JS 代码。例如我们这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;w.123&#x27;</span> <span class="attr">onerror</span>=<span class="string">&#x27;alert(&quot;hey!&quot;)&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果输入大意，也是可能对其项目造成危害的。</p><h3 id="使用转义字符"><a href="#使用转义字符" class="headerlink" title="使用转义字符"></a>使用转义字符</h3><p>因为项目都是对指定字符串进行匹配，但是 JS 中有一些特别的转义字符，大部分都是通过 “&quot; 字符进行转义，而攻击者可以使用转义输入，但是转义之后便是可执行的代码，便能达到攻击项目的目的。<br>例如这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>(\u0061\u006c\u0065\u0072\u0074(<span class="number">1</span>))</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样转移之后便是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样也可以绕过一些字符的过滤。</p><h2 id="XSS攻击分类"><a href="#XSS攻击分类" class="headerlink" title="XSS攻击分类"></a>XSS攻击分类</h2><p>实际项目中的漏洞是不会这么直观的，我们需要不断的换各种方式去尝试，甚至可以使用多种方式合并起来绕过项目的过滤，以达到我们的目的，而攻击的方式更是多种多样，并且XSS 的攻击大致上可以分为两类：</p><ul><li>一类是<code>反射型XSS</code>，又称为 <strong>非持久型XSS</strong>。</li><li>一类是<code>存储型XSS</code>，也称之为 <strong>持久型XSS</strong>。</li></ul><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p><strong>反射型XSS</strong> 一般表示从 <strong>URL</strong> 中传入恶意攻击的代码，而界面不错任何处理便渲染到项目中。<br>这也就是说攻击相对于访问者是 <strong>一次性</strong> 的，也就是通过 <strong>URL</strong> 将恶意代码传递到界面上，而项目不对数据进行任何处理，将脚本 <strong>“反射”</strong> 到浏览器进行渲染，此时恶意脚本便执行了。<br>也就是说如果此种形式进行 <strong>XSS攻击</strong>，只能访问特定链接才能实现恶意攻击。</p><h3 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h3><p><strong>储存型XSS</strong> 与上面最大的不同是，它是通过将恶意代码保存到数据库中，界面读取到数据库中的恶意代码，直接渲染上面也会造成 <strong>XSS攻击</strong>。<br>例如我们在数据库中保存了一行恶意代码，然后指定用户访问时，后台将恶意代码读取出并返回到前端浏览器执行。这就意味着该用户登陆的所有地方都会执行这段恶意代码，<strong>因此存储型XSS危害更大</strong>。<br>只需要登陆指定用户到指定 URL 便可进行攻击，不需要访问特定的 URL。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;XSS&lt;/strong&gt; 是 &lt;strong&gt;跨域脚本攻击&lt;/strong&gt; 的简称，表示有人不怀好心在 Web 界面中插入恶意的 Script 代码，用户浏览界面的时候，恶意嵌入的 Web 里面的恶意 Script 就会被执行，从而达到恶意攻击用户的目的。&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞攻击" scheme="https://www.bipch.cn/categories/%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"/>
    
    
    <category term="跨域脚本攻击" scheme="https://www.bipch.cn/tags/%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="https://www.bipch.cn/javascript-garbage-collection/"/>
    <id>https://www.bipch.cn/javascript-garbage-collection/</id>
    <published>2020-11-20T04:20:36.000Z</published>
    <updated>2021-03-07T07:58:16.525Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中所有的内存管理是自动执行的，并且都是不可见的。我们创建的基本类型、对象、函数等，这些都是需要分配内存的，但是由于其是不可见的，所以我们要明白怎么进行空间的分配、不用的时候，会发生什么呢？JS 引擎如何清理它呢？</p><span id="more"></span><h2 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h2><p>JavaScript 中内存管理的重要概念便是<code>可达性</code>，其主要负责我们项目能够访问到的值，都能够保存到内存中。其主要有下面几个要点：</p><ul><li><strong>有一组基本的固有可达值，由于显而易见的原因无法删除，这些值称为<code>根</code></strong>。<br>  例如：<ul><li>本地函数的局部变量和参数。</li><li>当前嵌套调用链上的其它函数的变量和参数。</li><li>全局变量。</li><li>还有一些其它的，内部的。</li></ul></li><li><strong>如果引用可以从根访问任何其它值，则认为该值是可以访问的</strong>。<br>  例如：在代码中定义一个对象，并且在别的地方对该对象进行引用，则该对象视为具有<code>可达性</code>，它引用的值也是可以访问的，而 JS 引擎中有一个后台进程称为<strong>垃圾回收器</strong>，它监视所有代码中的对象，并删除那些<strong>不具有</strong>可达性的对象。<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2>虽然叙述起来可能很绕嘴，但是其含义还是很容易理解的，例如下面代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>代码定义了一个对象<code>&#123;name: &#39;jack&#39;&#125;</code>并定义 <strong>user</strong> 指针指向该对象，此时对象<code>&#123;name: &#39;jack&#39;&#125;</code>被访问不会被清除，但是我们添加下面代码：<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &#x27;jack&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="addition">+ user = null;</span></span><br></pre></td></tr></table></figure>这样对象<code>&#123;name: &#39;jack&#39;&#125;</code>就被覆盖掉了，其不具备<code>可达性</code>，所以此时垃圾回收器便会将其视为垃圾进行回收，释放内存。<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2>JavaScript 的垃圾回收机制有很多种，下面简单列举几种：<h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3>一种很常见的垃圾回收算法，它主要定期执行下面的步骤：</li></ul><ol><li>垃圾回收器获取根并 <strong>”标记“</strong> 它们。</li><li>然后它访问并 <strong>“标记”</strong> 所有来自它们的引用。</li><li>然后它访问标记对象的引用。所有被访问对象都会被记住，以便以后不再访问同一对象两次。</li><li>以此类推，直到引用都标记完成(从根节点开始访问)。</li><li>除了标记对象外，所有对象都被删除。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 JavaScript 中所有的内存管理是自动执行的，并且都是不可见的。我们创建的基本类型、对象、函数等，这些都是需要分配内存的，但是由于其是不可见的，所以我们要明白怎么进行空间的分配、不用的时候，会发生什么呢？JS 引擎如何清理它呢？&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="JavaScript" scheme="https://www.bipch.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>执行机制</title>
    <link href="https://www.bipch.cn/javascript-event-loop/"/>
    <id>https://www.bipch.cn/javascript-event-loop/</id>
    <published>2020-11-07T06:20:36.000Z</published>
    <updated>2021-03-07T11:39:40.967Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 的代码中都是按照一定的顺序去执行的，其每一段的代码执行，都有一定的先后顺序，这种代码的执行顺序一般称之为其执行机制。</p><span id="more"></span><h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2><p>JavaScript 的执行机制主要在意下面几点：</p><ol><li><strong>JavaScript是一门单线程语言</strong>。</li><li><strong>Event Loop(事件循环)是JS的执行机制</strong>。</li></ol><h2 id="为什么-JS-代码是单线程？"><a href="#为什么-JS-代码是单线程？" class="headerlink" title="为什么 JS 代码是单线程？"></a>为什么 JS 代码是单线程？</h2><p><strong>其实也很好的理解，因为JS是用来在浏览器控制一些DOM的操作的一门脚本语言，如果JS是多线程，那么两个线程同时对一个DOM元素进行相互冲突的操作，那么浏览器将无法去执行。所以JS只能是单线程的</strong>。<br>既然它只能只能是单线程，但是 JS 需要处理许多的异步请求，例如：请求网络接口、读取一些文件，延迟执行等操作，都需要使用异步去处理，否则一个请求解析时间过长那么代码就会阻塞。</p><h3 id="单线程-实现-“多线程”"><a href="#单线程-实现-“多线程”" class="headerlink" title="单线程 实现 “多线程”"></a>单线程 实现 “多线程”</h3><p>在 JS 中所有的异步以及多线程都可以理解为一种”假象“，例如H5新增的 WebWorker 来说，子线程有诸多的限制，不能控制DOM、不能修改全局对象等，通常只能处理一些数据逻辑。<br>这些限制并没有违背我们之前的观点，所以说是”假象“。JS异步执行机制就是 <strong>事件循环</strong>(Event Loop)，理解他就理解了异步执行机制。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>JS 代码在执行过程中会先执行同步操作异步操作排在事件队列里，这样的理解并没有什么错误，但是如果在深入理解会发现还有一些其它的概念，比如 event table 和 event queue，具体可以下面的流程：</p><ol><li>先判断任务是同步任务还是异步，同步进入主线程运行，异步进入 event table。</li><li>异步在 event table 中注册事件，满足触发条件后(触发条件可能是延迟或网络请求成功)，后被推入 event queue。</li><li>同步任务进入主线程一直执行，一直到主线程空闲时，才会到 event queue  查看是否有可执行的异常任务，如果有就推入主线程。</li></ol><p>JS主线程执行过程中会不断的检查主线程执行栈是否为空，一旦为空，就回去 event queue 检查是否有等待被调用的函数，直至执行完毕。绘制流程图如下所示：</p><p><img src="https://img.bipch.cn/2021/02/03/56e4181bd3a21.png" alt=""></p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>通过上面的描述，可能还不够直观，我们用 Ajax 异步操作，执行顺序如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&#x27;*****&#x27;</span>,</span><br><span class="line">  data: [],</span><br><span class="line">  success: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    consoel.log(<span class="string">&#x27;ajax成功&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>那么它的执行顺序为：</p><ul><li>ajax 进入  <strong>event table</strong>，并注册成功的回调函数 <strong>success</strong>。</li><li>主线执行完成，执行<code>console.log(&#39;代码执行结束&#39;)</code>代码。</li><li>ajax 事件完成，回调函数进入 <strong>event queue</strong>。</li><li>主线程从 <strong>event queue</strong> 读取回调函数 <strong>success</strong> 并执行。</li></ul><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>项目中经常出现 <code>setTimeout</code>或者<code>setinterval</code>并不是特别准时，例如下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout延迟&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步占用大量的事件</span></span><br><span class="line">sleep(<span class="number">999999999</span>);</span><br></pre></td></tr></table></figure><p>如果我们用上面流程解释该代码会很简单，虽然其只是 0s，但是其还是异步，只是将其挂起并不会去执行，只有同步<code>sleep</code>执行完成，才会真正的去执行<code>setTimeout</code>代码，所以说不管是<code>setTimeout</code>还是<code>setinterval</code>都不会那么准时，因为 JS 会需要处理所有同步代码才会去执行异步。</p><h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><p>代码中除了同步和异步任务，还可以对异步任务再细一步的划分，可以再划分为：</p><ul><li><strong>宏任务</strong>：包含<code>setTimeout</code>、<code>setIntval</code>异步方式。</li><li><strong>微任务</strong>：包含<code>Promsie</code>异步方式。</li></ul><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>既然异步可以进一步细分，那细分之后，顺序是怎么样的呢？<br>其实前面没什么变化，只是对异步进行了区分：不同异步进入对应的 <strong>event queue</strong>，比如 <code>setTimeout</code> 和 <code>setIntval</code> 会进入宏任务的 <strong>event queue</strong>，而 <code>Promsie</code> 进入微任务的 <strong>event queue</strong>，虽然都是异步任务，但是 <strong>宏任务的优先级高于微任务</strong>。</p><h2 id="Promise的事件循环"><a href="#Promise的事件循环" class="headerlink" title="Promise的事件循环"></a>Promise的事件循环</h2><p>Promise 在进行初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完成后，继续向下执行代码，在此之前，then 的回调不会执行，同步代码执行完毕后，才会在事件循环中检查是否有可用的 Promise 回调，如果有则执行，否则继续下一个事件循环。<br>可以总结为下面流程：</p><ol><li><strong>宏任务和微任务都是队列</strong>，主线程代码执行完毕后，会执行宏任务中的同步代码。</li><li>进入第一轮事件循环的时候，会 <strong>把全部的 js 脚本当成宏任务运行</strong>。</li><li>如果执行中遇到<code>setTimeout</code>之类的宏任务，那么会将其推入 <strong>[宏任务队列]</strong> 中，下一轮宏任务执行时调用。</li><li>如果遇到 <code>Promise.then()</code> 之类的微观任务，就会推入到 <strong>[当前宏任务的微观任务]</strong> 中，本轮宏观任务结束后，依次执行所有微观任务。</li><li>如果第一轮事件循环中执行完全部的同步以及微观任务队列任务，那么这一轮事件循环便结束了，开始进行下一轮。</li><li>依次循环往复。</li></ol><p>结合上面定义，我们看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 宏任务2</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">      resolve(<span class="number">6</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 微任务1</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏任务1</span></span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 微任务2</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>结合定义一步步上面代码：</p><ol><li>第一轮将所有代码作为宏观任务，进入主线程。</li><li>首先遇到 new Promise 名称为 first，执行里面同步函数。</li><li>遇到 new Promise 名称为 p，执行同步函数，遇到里面含有的 setTimeout 将其回调注册后分发给第二轮宏观任务 event queue，并将 p 的 then 函数发布到当前任务的微任务event queue。</li><li>对 first 注册 then 回调，并将回调添加到微任务 event queue。</li><li>宏任务执行完毕，开始执行微任务…。</li><li>得出结果为：<strong>3</strong>、<strong>7</strong>、<strong>4</strong>、<strong>1</strong>、<strong>2</strong>、<strong>5</strong>。</li></ol><p>结合上面叙述，我们得出下面的结论：<strong>宏任务是一个栈，按照先入先执行的原理，微任务也是按照先入先执行的原理。但是每个宏任务对应都有一个微任务栈，宏任务执行过程中会先执行同步代码在执行微任务栈</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 JavaScript 的代码中都是按照一定的顺序去执行的，其每一段的代码执行，都有一定的先后顺序，这种代码的执行顺序一般称之为其执行机制。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="JavaScript" scheme="https://www.bipch.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>拷贝</title>
    <link href="https://www.bipch.cn/javascript-copy/"/>
    <id>https://www.bipch.cn/javascript-copy/</id>
    <published>2020-11-02T03:48:10.000Z</published>
    <updated>2021-03-02T04:19:45.782Z</updated>
    
    <content type="html"><![CDATA[<p>了解拷贝之前，必须先搞清楚 <strong>=</strong>(赋值) 和 <strong>拷贝</strong> 的区别，它们是不会相同的。<strong>赋值</strong> 只能算是”引用”，其引用的任然是同一对象，不能算是真正的拷贝，因为<strong>拷贝</strong>是重新创建了新的对象，所以赋值和拷贝本质还是有区别的。</p><span id="more"></span><h2 id="赋值与拷贝"><a href="#赋值与拷贝" class="headerlink" title="赋值与拷贝"></a>赋值与拷贝</h2><p>JS 中的拷贝可以分为<code>浅拷贝</code>和<code>深拷贝</code>，它们的主要区别如下所示：</p><p><strong>深拷贝</strong>：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 会 影响原数组。</p><p><strong>浅拷贝</strong>：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 不会 影响原数组。</p><p>所以结合上面的叙述，我们可以绘制出下面的表格：</p><table><thead><tr><th>名称</th><th>和原数据是否指向同一对象</th><th>第一层数据为基本数据类型</th><th>原数据中包含子对象</th></tr></thead><tbody><tr><td>=</td><td>是</td><td>改变会使原数据一同改变</td><td>改变会使原数据一同改变</td></tr><tr><td>浅拷贝</td><td>否</td><td>改变 <strong>不</strong> 会使原数据一同改变</td><td>改变会使原数据一同改变</td></tr><tr><td>深拷贝</td><td>否</td><td>改变 <strong>不</strong> 会使原数据一同改变</td><td>改变 <strong>不会</strong> 会使原数据一同改变</td></tr></tbody></table><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>我们要区分 <code>浅拷贝</code> 和 <code>赋值</code> 的区别，我们通过下面的方式进行比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;language&#x27;</span>: [</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dst = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      dst[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</span><br><span class="line"></span><br><span class="line">obj2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj3.age = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">obj2.language[<span class="number">1</span>] = [<span class="string">&quot;二&quot;</span>, <span class="string">&quot;三&quot;</span>];</span><br><span class="line">obj3.language[<span class="number">2</span>] = [<span class="string">&quot;四&quot;</span>, <span class="string">&quot;五&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">//obj1 = &#123;</span></span><br><span class="line"><span class="comment">//    &#x27;name&#x27; : &#x27;lisi&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;age&#x27; :  &#x27;18&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">//obj2 = &#123;</span></span><br><span class="line"><span class="comment">//    &#x27;name&#x27; : &#x27;lisi&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;age&#x27; :  &#x27;18&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">//obj3 = &#123;</span></span><br><span class="line"><span class="comment">//    &#x27;name&#x27; : &#x27;zhangsan&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;age&#x27; :  &#x27;20&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure><p>先定义一个原始对象 obj1，然后使用 <strong>赋值</strong> 得到第二个对象 obj2，然后通过 <strong>浅拷贝</strong> 对象 obj1 得到 obj3 对象。也就是说：</p><ul><li><strong>obj1</strong>：原始数据。</li><li><strong>obj2</strong>：赋值操作得到。</li><li><strong>obj3</strong>：浅拷贝得到。</li></ul><p>最后得出：我们在改变 <strong>obj2</strong> 和 <strong>obj3</strong> 的 <code>name</code> 属性，最后可以看出改变 <strong>obj2</strong> 会使 <strong>obj1</strong> 进行修改，而 <strong>obj3</strong> 不会修改。这就说明了 <strong>赋值只是复用引用地址</strong>，但引用还是同一对象，而 <strong>拷贝则是新创建了一个对象</strong>。而我们修改 <strong>obj2</strong> 和 <strong>obj3</strong> 的 <code>language</code> 属性时，最后是都会发生改变的，这是因为 浅拷贝 只是复制一层的对象属性，并不包括对象中的引用数据。所以修改引用类型的数据，原始数据也会进行修改。</p><p>从上面的实例很容易就能区分出 <strong>复制</strong> 和 <strong>浅拷贝</strong> 的真正区别。我们千万不能将 <strong>复制</strong> 直接当成 <strong>浅拷贝</strong> 进行理解。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>因为前面讲了 <strong>浅拷贝</strong> 至于 <strong>深度拷贝</strong> 其实对对象的所有子对象都进行拷贝。那么怎么实现呢？<br>其实我们递归调用 <strong>浅拷贝</strong> 对象，把所有属于对象的属性类型都遍历赋给另一个对象即可。比如下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, newObj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          newObj[key] = (obj[key].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">          deepClone(obj[key], newObj[key]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newObj[key] = obj[key]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出和 <strong>浅拷贝</strong> 非常的相似，只是遍历的时候判断如果是 <strong>对象类型</strong> 的数据，就递归继续拷贝，这样就避免 <strong>浅拷贝</strong> 子对象的问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;了解拷贝之前，必须先搞清楚 &lt;strong&gt;=&lt;/strong&gt;(赋值) 和 &lt;strong&gt;拷贝&lt;/strong&gt; 的区别，它们是不会相同的。&lt;strong&gt;赋值&lt;/strong&gt; 只能算是”引用”，其引用的任然是同一对象，不能算是真正的拷贝，因为&lt;strong&gt;拷贝&lt;/strong&gt;是重新创建了新的对象，所以赋值和拷贝本质还是有区别的。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="JavaScript" scheme="https://www.bipch.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB安装和常用方法</title>
    <link href="https://www.bipch.cn/linux-software/"/>
    <id>https://www.bipch.cn/linux-software/</id>
    <published>2020-10-20T06:20:30.000Z</published>
    <updated>2021-03-08T19:53:43.149Z</updated>
    
    <content type="html"><![CDATA[<p>一种非关系型的数据库，由于其高性能、易部署、易使用，并且可以通过 Mongoose 和 Node.js 完美结合起来使用，可以很方便的为 web 应用提供一种高效的存储方案，详情可以去<a href="https://www.mongodb.com/">官网</a>查看。</p><span id="more"></span><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>我的服务器操作系统为 centos，请根据操作系统进行安装。首先我们要去复制压缩包的下载的链接：</p><p><img src="https://img.bipch.cn/2021/02/03/36e0894477c7d.png" alt="MongoDB DownLoad"></p><p>按照自己的系统拷贝相应的链接，这里贴出我的链接：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https</span>://fastdl.mongodb.org/linux/mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span>.tgz</span><br></pre></td></tr></table></figure><p>拷贝完成后需要放置到服务器，一般我会放置在 <strong>/usr/local/</strong> 路径下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local</span><br><span class="line">wget https:<span class="regexp">//</span>fastdl.mongodb.org<span class="regexp">/linux/m</span>ongodb-linux-x86_64-amazon-<span class="number">4.4</span>.<span class="number">3</span>.tgz</span><br></pre></td></tr></table></figure><p>等待文件下载完成后，我们需要对其解压：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -zxvf mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span>.tgz</span><br><span class="line"><span class="attribute">mv</span> mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span> mongodb-linux</span><br><span class="line"><span class="attribute">rm</span> mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span>.tgz</span><br></pre></td></tr></table></figure><p>这样通过<code>tar</code>命令进行解压，通过<code>mv</code>命令进行重命名，然后通过<code>rm</code>将压缩包删除，因为解压之后，压缩包已经失去了价值。<br>这样基本项目已经下载完成，我们还需要手动创建日志文件目录、数据库文件目录：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> mongodb-linux</span><br><span class="line"><span class="keyword">mkdir</span> <span class="keyword">db</span> logs</span><br></pre></td></tr></table></figure><p><strong>mongodb-linux</strong> 根目录下新建了两个文件夹<code>db</code>、<code>logs</code>分别存放数据库和日志。<br>这样配置基本完成，我们只需告诉 Mongodb 文件位置即可，在<code>bin</code>目录下新建文件<code>mongodb.conf</code>文件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> bin</span><br><span class="line"><span class="keyword">vi</span> mongodb.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p>打开 vim 编辑文件，输入下面内容：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dbpath=<span class="regexp">/usr/</span>local<span class="regexp">/mongodb-linux/</span>db</span><br><span class="line">logpath=<span class="regexp">/usr/</span>local<span class="regexp">/mongodb-linux/</span>logs/mongodb.log</span><br><span class="line">port=<span class="number">27017</span></span><br><span class="line">fork=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>一些基础配置：</p><ul><li><code>dbpath</code>：数据库地址。</li><li><code>logpath</code>：日志地址。</li><li><code>port</code>：端口。</li><li><code>fork</code>：前台还是后台运行，true 表示后台运行，否则表示前台。</li></ul><p>完成后，通过<code>:wt</code>命令退出 vim，这样基本配置完成，我们在 <strong>bin</strong> 目录下运行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./mongod</span> -f mongodb.conf</span><br></pre></td></tr></table></figure><p>然后执行<code>./mongo</code>即可链接上 Mongodb，然后可以通过下面方式查看版本号：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">db</span>.<span class="keyword">version</span>()</span><br></pre></td></tr></table></figure><p>当然如果嫌每次执行都需进入<strong>bin</strong>目录，我们可以为其配置环境变量，修改<code>/etc/profile</code>配置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><p>然后只需在最后添加下面两行代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装路径</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">MONGODB_HOME</span>=/usr/local/mongodb-linux</span><br><span class="line"><span class="comment"># bin 目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$MONGODB_HOME/bin</span><br></pre></td></tr></table></figure><p>完成后，使用<code>source /etc/profile</code>命令重启即可。</p><h2 id="数据库常用命令"><a href="#数据库常用命令" class="headerlink" title="数据库常用命令"></a>数据库常用命令</h2><p>上面已经将 Monsedb 安装完成，下面总结下其常用的命令方便以后的使用。</p><h3 id="数据库列表"><a href="#数据库列表" class="headerlink" title="数据库列表"></a>数据库列表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">show</span> dbs</span><br><span class="line"><span class="keyword">admin</span>   <span class="number">0.000</span>GB</span><br><span class="line">config  <span class="number">0.000</span>GB</span><br><span class="line"><span class="keyword">local</span>   <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">use</span> react_blog</span><br><span class="line">switched <span class="keyword">to</span> db react_blog</span><br></pre></td></tr></table></figure><p><code>use</code>命令创建时，如果数据库不存在会进行创建后进入，如果已经存在回切换到指定数据库，所以切换到执行数据库也是该命令。</p><blockquote><p>新增的数据库使用 <code>show dbs</code> 是无法查询出的，我们只有新增数据之后才可以查询出。</p></blockquote><h3 id="当前数据库"><a href="#当前数据库" class="headerlink" title="当前数据库"></a>当前数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">react_blog</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.dropDatabase()  <span class="comment"># 删除数据库</span></span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt; db  <span class="comment"># 查询当前数据库</span></span><br><span class="line">react_blog</span><br><span class="line">&gt; <span class="keyword">show </span>dbs  <span class="comment"># 查询数据库列表</span></span><br><span class="line">admin   <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line"><span class="built_in">config</span>  <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">local   <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">&gt; db.createCollection(<span class="string">&quot;user&quot;</span>)  <span class="comment"># 相当于创建一个数据库</span></span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt; <span class="keyword">show </span>dbs  <span class="comment"># 在查询数据库列表</span></span><br><span class="line">admin       <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line"><span class="built_in">config</span>      <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">local       <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">react_blog  <span class="number">0</span>.<span class="number">000</span>GB</span><br></pre></td></tr></table></figure><p>可以看出虽然执行<code>dropDatabase</code>删除了该数据库，但是其当前数据库并没有改变，尽管其已经被删除，使用<code>dbs</code>查询发现已经从列表中删除，但是如果我们此时新建 Collection(可以立即为数据库中的数据表)，该操作是执行成功的，并且数据库又能查询出来。所以可以很简单的得出结论：<strong><code>dropDatabase</code> 只是清空当前数据库的所有 Collection</strong>。</p><h3 id="查询所有集合"><a href="#查询所有集合" class="headerlink" title="查询所有集合"></a>查询所有集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; show collections</span><br><span class="line">user</span><br></pre></td></tr></table></figure><h2 id="collection-常用命令"><a href="#collection-常用命令" class="headerlink" title="collection 常用命令"></a>collection 常用命令</h2><p>集合就相当于 Mysql 数据库中的数据表。</p><h3 id="创建-collection"><a href="#创建-collection" class="headerlink" title="创建 collection"></a>创建 collection</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.createCollection(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : 1 &#125;</span><br></pre></td></tr></table></figure><p>该操作相当于在 Mysql 中的数据库新增一个数据表。</p><blockquote><p>当一个数据库中包含一个集合时(哪怕只是一个空集合)，便能够使用<code>dbs</code>查询出来了。</p></blockquote><h3 id="删除-collection"><a href="#删除-collection" class="headerlink" title="删除 collection"></a>删除 collection</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.user.drop()</span><br><span class="line">true</span><br><span class="line">&gt; show collections</span><br></pre></td></tr></table></figure><h3 id="重命名-collection"><a href="#重命名-collection" class="headerlink" title="重命名 collection"></a>重命名 collection</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show collections</span><br><span class="line">user</span><br><span class="line">&gt; db.user.renameCollection(&quot;users&quot;)</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt; show collections</span><br><span class="line">users</span><br></pre></td></tr></table></figure><h2 id="关闭-MongoDB"><a href="#关闭-MongoDB" class="headerlink" title="关闭 MongoDB"></a>关闭 MongoDB</h2><p>MongoDB 启动成功后需要以正确的方式进行关闭：<br>可以使用<code>Crtl + C</code>命令直接关闭，注意此时只是退出了 MongoDB，如果退出后在连接是可以正常连接的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ^C</span><br><span class="line">bye</span><br><span class="line">&gt; .&#x2F;mongo</span><br></pre></td></tr></table></figure><p>这样做是完全没有问题的，如果要彻底关闭 MongoDB，排除强行关闭端口的情况下，还能使用<code>shutdownServer</code>，注意：<strong>使用该方法时<code>必须</code>在 admin 下</strong>，不然会给出下面的提示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown command <span class="keyword">only</span> works <span class="keyword">with</span> the <span class="keyword">admin</span> <span class="keyword">database</span>; try <span class="string">&#x27;use admin&#x27;</span></span><br></pre></td></tr></table></figure><p>这样去关闭：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">admin</span><br><span class="line">&gt; db.shutdownServer()</span><br><span class="line">server should be down...</span><br><span class="line">&gt; <span class="keyword">exit</span></span><br><span class="line">bye</span><br></pre></td></tr></table></figure><p>因为<code>shutdownServer</code>不会关闭当前的服务，所以我们还要加上<code>exit</code>来退出。这样即使后面再使用<code>./mongo</code>也是无法连接的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一种非关系型的数据库，由于其高性能、易部署、易使用，并且可以通过 Mongoose 和 Node.js 完美结合起来使用，可以很方便的为 web 应用提供一种高效的存储方案，详情可以去&lt;a href=&quot;https://www.mongodb.com/&quot;&gt;官网&lt;/a&gt;查看。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.bipch.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MongoDB" scheme="https://www.bipch.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流</title>
    <link href="https://www.bipch.cn/antiShake-throttle/"/>
    <id>https://www.bipch.cn/antiShake-throttle/</id>
    <published>2020-10-20T05:48:10.000Z</published>
    <updated>2021-03-07T07:29:38.796Z</updated>
    
    <content type="html"><![CDATA[<p>防抖和节流在web开发中属于性能优化方面的知识，实际使用频率还是很高的，比如我们有一个高频率触发事件，每次触发都会执行一次事件绑定的函数。例如我们每次移动滚动条都要触发一个函数，那么我们每稍微移动下滚动条，便会调用很多次函数，如果函数逻辑复杂很有可能出现响应速度跟不上触发频率，出现延迟，假死、卡顿或崩溃的现象。而我们可以通过下面的几种方式优化代码。</p><span id="more"></span><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>实现方式：<strong>每次触发事件时设置一个延迟调用的方法，并且取消之前的延迟调用方法。</strong>这样如果短时间触发大量的同一事件，函数代码只会执行一次。<br>下面用代码实现上面逻辑，因为要一段时间之后执行某些逻辑，所以需要<code>setTineout</code>函数实现，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 防抖函数</span></span><br><span class="line"><span class="comment">* fn: 需要防抖函数</span></span><br><span class="line"><span class="comment">* delay: 防抖时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计时器对象</span></span><br><span class="line">  <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次执行都把 setTimeout 清除</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); </span><br><span class="line">    <span class="comment">// 重写创建 setTimeout，主要重置 setTimeout</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;防抖：&#x27;</span>, <span class="built_in">Math</span>.random());&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 开始防抖，500 防抖时间 </span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, <span class="number">500</span>));</span><br></pre></td></tr></table></figure><p>简单柯里化函数滚动条滚动之后等待 500ms 之后才能触发 handle 函数，连续执行是不会触发 handle 函数。<br>虽然实现了我们需求，它的缺点也非常的明显: 如果这个事件不断地触发，其会不断取消前面的函数，重新执行，这样函数是无法进行执行的。</p><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>实现方式：<strong>每次触发事件，如果当前有等待执行的延时函数，则直接 return。</strong><br>使用下面代码来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 标记，是否可以成功向下执行</span></span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 是否可以继续向下</span></span><br><span class="line">    <span class="keyword">if</span>(!canRun) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置结束，等待一段时间后，才能继续执行</span></span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 此时的值为 false </span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行节流函数</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="comment">// 执行之后，我们可以继续执行了</span></span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样封装即使事件一直执行，并不会第一时间进行触发函数，而是判断是否有函数执行，如果有则不会执行，执行前一个函数执行完成才继续触发下一个函数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>防抖：</strong> 将多个操作合并为一次操作。原理就是一个计时器，在规定的 delay 时间后才能触发函数，但是如果在 delay 时间内再次触发，就会取消之前的计时器并重启设置。这样一来，只有zui’hou一次操作会被触发。</li><li><strong>节流：</strong> 使一段时间后触发一次函数，原理是通过判断是否有延迟函数执行，若有延迟函数执行则结束该函数。</li><li><strong>区别：</strong> 节流不管触发多频繁，都会保证在规定时间内一定会执行一次处理函数，而防抖只是在最后一次事件后才触发函数。如果在界面无限加载的情况下，我们需要用户滚动界面时，每隔一段时间发一次网络请求，而不是用户停下才去请求数据。这种需求就适合使用节流技术来实现。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;防抖和节流在web开发中属于性能优化方面的知识，实际使用频率还是很高的，比如我们有一个高频率触发事件，每次触发都会执行一次事件绑定的函数。例如我们每次移动滚动条都要触发一个函数，那么我们每稍微移动下滚动条，便会调用很多次函数，如果函数逻辑复杂很有可能出现响应速度跟不上触发频率，出现延迟，假死、卡顿或崩溃的现象。而我们可以通过下面的几种方式优化代码。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://www.bipch.cn/categories/web/"/>
    
    
    <category term="JavaScript" scheme="https://www.bipch.cn/tags/JavaScript/"/>
    
  </entry>
  
</feed>
