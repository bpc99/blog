{"meta":{"title":"Blog","subtitle":"记录生活中的点点滴滴","description":"正因为有忘也忘不了的回忆，才会变得坚强，这就是所谓的成长吧！","author":"Xiaopc767d","url":"https://www.bipch.cn","root":"/"},"pages":[{"title":"关于小站","date":"2019-10-11T01:44:31.314Z","updated":"2019-10-11T01:44:31.314Z","comments":true,"path":"about/index.html","permalink":"https://www.bipch.cn/about/index.html","excerpt":"","text":"一位来自河南的蒟蒻，目前从式前端工作，还有很多知识需要去学习。有什么好的建议可以联系我的邮箱或 QQ。 QQ：1980894425 E-mail：baipcheng@126.com"},{"title":"分类","date":"2019-07-04T23:03:51.000Z","updated":"2019-07-04T23:05:42.930Z","comments":true,"path":"categories/index.html","permalink":"https://www.bipch.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-04T22:58:28.000Z","updated":"2019-07-04T23:02:10.293Z","comments":true,"path":"tags/index.html","permalink":"https://www.bipch.cn/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-10-17T10:11:40.455Z","updated":"2019-10-17T10:11:40.455Z","comments":true,"path":"friends/index.html","permalink":"https://www.bipch.cn/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： bpc’s blog 头像： https://cdn.jsdelivr.net/gh/bpc99/assets@master/avatar/avatar.jpg 网址： http://www.baipc.com.cn/blog 标签： Web前端"}],"posts":[{"title":"vercel","slug":"vercel","date":"2021-03-09T09:29:56.000Z","updated":"2021-03-09T11:46:07.931Z","comments":true,"path":"vercel/","link":"","permalink":"https://www.bipch.cn/vercel/","excerpt":"当项目完成后，最重要的便是部署了，一般需要挑选一个访问速度比较快的、花钱比较少的、部署比较方便…这些因素同时考虑比较好用的便是 GitHub Pages 了，但是其国内一般访问较慢，如果比较着重考虑国内访问的话，可以考虑另一款和 Github 比较契合的工具 Vercel。","text":"当项目完成后，最重要的便是部署了，一般需要挑选一个访问速度比较快的、花钱比较少的、部署比较方便…这些因素同时考虑比较好用的便是 GitHub Pages 了，但是其国内一般访问较慢，如果比较着重考虑国内访问的话，可以考虑另一款和 Github 比较契合的工具 Vercel。 Why VercelVercel 国内的访问速度也是比较快，而且无需科学上网，相同的项目对比 Vercel 托管的程序(图左) 和 直接部署的程序(图右) 的请求速度： 可以看到其速度加快了 2 倍多，并且 Vercel 和 Github 也是比较契合的，其还能直接导入 hexo、vue、next等项目，其会自动为我们构建。 Github我们可以在 Github 新增一个仓库，然后可以在 Vercel 设置该仓库，这样一旦仓库数据数据更新 Vercel 中的数据也会更新，并且可以查看仓库的操作日志等信息。在 vercel 新增 Project，然后选择 Add Github Org or Account： 选中所需的仓库之后，会根据我们的项目自动判断项目的类型，例如我们导入 Hexo 项目： 可以看出其自动判断了项目类型，当然如果不准确可以自行修改，选择类型之后会自动生成打包命令(Build and Output Settings)、项目根目录(ROOT DIRECTORY)、环境变量(Environment Variables)等配置，根据需求配置完成后，会根据命令和项目类型自动部署，成功后可以看到下面界面： 这样便完成了部署，如果是其它类型的项目，那么部署方式也是同样的。 域名项目部署成功后系统会自动为其分配一个域名，但是其并不是太好记，所以我们一般需要将自己域名设置为项目的访问路径。进入项目的详情界面，点击 View Domains 可配置项目的各个属性，但是其域名必须经过 CNAME 解析，不然会报出下面的错误： 我们解析时添加解析，例如案例云的界面为： 这样即可添加域名，并且其添加成功后会自动为我们的域名申请 SSL 证书，并为项目使用 https 协议。添加域名之后，可以在详情页查看其各个域名信息，与项目日志、启动时间等字段： 总结当然一个项目的部署方式有许多种的，而 Vercel 只是其中之一，并且开发中也不能拘束与一种部署方式，而是需要根据实际的情况选择不同的方式。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"项目部署","slug":"项目部署","permalink":"https://www.bipch.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"}]},{"title":"Hexo多种部署方式","slug":"Linux/Hexo多种部署方式","date":"2021-02-03T16:43:35.000Z","updated":"2021-03-09T11:44:02.908Z","comments":true,"path":"hexo-aliyun/","link":"","permalink":"https://www.bipch.cn/hexo-aliyun/","excerpt":"使用 Hexo 搭建完成博客，平常会更新一些文章，但是如果只是打包按照静态文件部署会显得非常的麻烦，并且每次修改文章，都要重新登陆服务器全部覆盖，这样每次都消耗大量的时间，为了简化文章的部署，也出现了很多中方法，这里记录下本人使用的两种。","text":"使用 Hexo 搭建完成博客，平常会更新一些文章，但是如果只是打包按照静态文件部署会显得非常的麻烦，并且每次修改文章，都要重新登陆服务器全部覆盖，这样每次都消耗大量的时间，为了简化文章的部署，也出现了很多中方法，这里记录下本人使用的两种。 Git + Nginx官网介绍，简单来说便是通过deploy指令读取配置文件(_config.yml)中的deploy属性配置，然后根据配置，将我们打包之后的静态文件推送到服务器中的 Git钩子 上，最后根据钩子的配置，将客户端与服务端代码合并，然后保存到服务端指定路径下，最后通过 Nginx 对指定的路径进行反向代理，即可使用命令将代码合并，并自动完成代码部署的功能。 通过上面描述，大致对 Hexo deploy 指令有了些大致印象，其关键的一步便是在服务端建立 Git钩子 以响应客户端的代码提交。我们可以这么做： 建立 Git 钩子首先创建钩子文件夹，并分配 755 类型权限： 123mkdir /var/repo/chown -R hexo /var/repo/chmod -R 755 /var/repo/ 创建完成后，我们还需要初始化钩子文件： 12cd /var/repo/git init --bare hexo_static.git 名称可以随意，初始化完成后，执行： 1vim /var/repo/hexo_static.git/hooks/post-receive 打开文件之后，保存下面的内容： 12#!/bin/bashgit --work-tree=/var/www/blog --git-dir=/var/repo/hexo_static.git checkout -f 请注意上面的路径，保存完成后。只需把该文件变为可执行文件： 1chmod +x /var/repo/hexo_static.git/hooks/post-receive 这样基本的 Git钩子 便建立完成了，当客户端提交代码向该钩子时，便会将代码传输到指定的路径下。 deploy 配置我们只需在配置文件(_config.yml)中编辑deploy属性，便能很简单的完成一键部署： 1234deploy: type: git repo: hexo@47.110.125.228:/var/repo/hexo_static.git branch: master 这样只需把属性的 repo 字段指向刚刚创建的 Git钩子 即可。当然 Hexo 还需要一个依赖，执行下面命令按照依赖： 1cnpm install hexo-deployer-git --save 按照完成后 Hexo 配置完成，为了简便我们可以在 package.json 中添加一行命令： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g -d &amp;&amp; hexo deploy&quot;&#125;, 这样运行yarn build，便会将代码提交到服务端的配置文件下，然后通过 Nginx 反向代理便能完成了一键部署。 vercelvercel 不论是和 Github的契合度，还是国内的镜像的加速，都是比较好用的，具体项目的部署，可以看 vercel 的部署。 总结虽然介绍了两种的部署方式但是其如果依照结果来看如果要托管博客，其方式太多太多，除此之外肯定还有很多的方法都能达成相同的目的，这里就当是抛砖引玉了，最后附带上个人的博客。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.bipch.cn/categories/Linux/"}],"tags":[{"name":"项目部署","slug":"项目部署","permalink":"https://www.bipch.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.bipch.cn/tags/Hexo/"}]},{"title":"pm2 + Nginx 部署 Koa2","slug":"Nginx/pm2+Nginx部署Koa2","date":"2021-01-30T18:10:03.000Z","updated":"2021-03-08T19:49:23.509Z","comments":true,"path":"linux-pm2-nginx-Koa2/","link":"","permalink":"https://www.bipch.cn/linux-pm2-nginx-Koa2/","excerpt":"因为自己需要空闲的时候总结一些个人项目等，之前通过 hexo 搭建的博客，但是接触了 koa2 决定使其搭建一个后台接口服务，为前端界面提供相应数据。 本篇主要讲解客户端一键将 koa2 项目部署到服务器，服务器端使用 pm2 管理 koa2 服务及 Nginx 反向代理服务到另一个接口。 首先网站大致为：koa2 默认占用本地6060端口，然后通过 nginx 反向代理到80端口，同时 nginx 将80端口转发到443强制使用 https 协议。","text":"因为自己需要空闲的时候总结一些个人项目等，之前通过 hexo 搭建的博客，但是接触了 koa2 决定使其搭建一个后台接口服务，为前端界面提供相应数据。 本篇主要讲解客户端一键将 koa2 项目部署到服务器，服务器端使用 pm2 管理 koa2 服务及 Nginx 反向代理服务到另一个接口。 首先网站大致为：koa2 默认占用本地6060端口，然后通过 nginx 反向代理到80端口，同时 nginx 将80端口转发到443强制使用 https 协议。 服务器本人服务器系统为CentOS7.0，系统不同执行的命令也会有些许差别。部署之前要安装必备的软件：Node、npm、pm2、Nginx。安装的方法这里就不多说了，其方式有太多。 下面的配置都是为了服务器安全，如果不需要可以不用配置。后面用户直接设置为 root 即可。 创建新用户(可选)为了服务器的安全起见，不推荐用 root 用户管理所有权限，只有需要 root 权限时，在使用su切换为 root。创建一个新用户： 1useradd bpc 对新用户初始化密码： 1passwd bpc 将该用户添加到wheel组中，设置为管理员用户： 1usermod -aG wheel bpc 关闭 root 用户访问 ssh(可选)为了服务器的安全，我们也需要关闭 root 的 ssh 访问权限。打开配置文件： 1vi /etc/ssh/sshd_config 找到下面配置，并将 yes 修改为 no： 1PermitRootLogin no 保存文件后，重启sshd服务： 1service sshd restart 这样 root 用户便不能直接登陆了，我们退出服务，使用新用户登陆，当权限不足时使用su切换到指定用户即可。 文件读写权限(可选)因为我们自定义了用户进行管理，其并不会向 root 一样有着所有文件的读写权限，我们需要对指定路径设置新用户的访问权限。比如我在服务器中将最终代码放置在 /var/api/blog 路径下，那么我们通过下面方式分配权限： 12chown -R bpc /var/apichmod -R 755 /var/api 这样通过chown命令分配指定用户权限，通过chmod分配给文件夹详细权限(755表示拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限)。 SSH 上传代码客户和服务器端同步代码需要建立一个 github 的私人仓库，我的命名为 react_blog_api。 设置密钥由于需要使用 ssh 读写私人仓库内容，所以需要配置私人仓库中的 Deploy keys。这就需要我们在客户端和服务器端生成id_rsa.pub(默认名称)文件，并查询其内容： 首先我们查看是否已经生成该文件： 1cat ~/.ssh/id_rsa.pub # cat 命令查看文件 当然如果cat命令没有查找文件，那么可以使用下面命令生成： 1ssh-keygen -t rsa -C &quot;你的个人邮箱&quot; 复制成功后，将内容粘贴到私人仓库中的 Deploy keys ： 并将 Allow write access 勾选上添加即可。 提交代码私人仓库配置完成后，我们便有权限操作私人仓库了，我们将客户端代码传入到仓库中： 12345git initgit remote add origin https://github.com/bpc99/blog_api.gitgit add .git commit -m &quot;项目初始化&quot;git push -u origin master 这样便将客户端代码提交至 Github 私人仓库。 pm2 配置使用 pm2 可以使 node 程序永远保持活动状态，无需停机便可以重新加载它们，并简化常见的任务管理。并且其还为我们提供了 deploy 配置，可以让我们在本地一键将项目部署到服务端。 同步代码关于 pm2 的基本操作和配置这里就不介绍了，具体可以查看其官方文档，当 koa2 本地运行无误时，我们需要配置 pm2 中的deploy属性，其默认的模板文件为： 12345678910111213module.exports = &#123; apps : [...], deploy : &#123; production : &#123; user : &quot;node&quot;, host : &quot;212.83.163.1&quot;, ref : &quot;origin/master&quot;, repo : &quot;git@github.com:repo.git&quot;, path : &quot;/var/www/production&quot;, &quot;post-deploy&quot; : &quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot; &#125; &#125;&#125; 一些基础的配置，其各个属性也都很简单： 12345678&quot;production&quot;: &#123; &quot;user&quot;: &quot;登录远程服务器的用户名(例如 root)&quot;, &quot;host&quot;: &quot;IP&quot;, &quot;ref&quot;: &quot;远端名称及分支名&quot;, &quot;repo&quot;: &quot;git仓库地址&quot;, &quot;path&quot;: &quot;远程服务器部署目录，需要填写user具备写入权限的目录&quot;, &quot;post-deploy&quot; : &quot;部署后需要执行的命令&quot;&#125; 我们根据自己服务器的信息填入即可，最后贴出本人的配置： 1234567891011module.exports = &#123; apps : [...], production: &#123; user: &quot;bpc&quot;, host: &quot;47.110.125.228&quot;, ref: &quot;origin/master&quot;, repo: &quot;git@github.com:bpc99/blog_api.git&quot;, path: &quot;/var/api/blog&quot;, &quot;post-deploy&quot;: &quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot; &#125;&#125; 这样便完成了 pm2 的基本配置，贴出ecosystem.config.js所有配置： 123456789101112131415161718module.exports = &#123; apps: [&#123; name: &#x27;api&#x27;, script: &#x27;./src/index.js&#x27;, watch: true, ignore_watch: [ &quot;node_modules&quot; ] &#125;], deploy: &#123; production: &#123; user: &quot;bpc&quot;, host: &quot;47.110.125.228&quot;, ref: &quot;origin/master&quot;, repo: &quot;git@github.com:bpc99/blog_api.git&quot;, path: &quot;/var/api/blog&quot;, &quot;post-deploy&quot;: &quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot; &#125; &#125;&#125;; 最后我们在根目录下，以ecosystem.config.js为配置文件，启动 pm2： 1pm2 deploy ecosystem.config.js production setup 此时会出现一个错误： Host key verification failed.fatal: Could not read from remote repository. 主要是因为在远程服务器中，并未将 github.com 加入known_hosts，在服务器端通过如下命令设置： 1ssh-keyscan -t rsa github.com &gt;&gt; ~/.ssh/known_hosts 如果成功，会在/home/用户名/.ssh目录下生成known_hosts文件。然后客户端重新执行部署的指令： 1pm2 deploy ecosystem.config.js production setup 如果传输成功 pm2 便将 GitHub 私人仓库中的文件，都传输到了我们服务器指定路径下，我们打开指定文件夹，发现其多了 3 个文件夹： current：当前运行的文件夹。 source：真正的项目源代码。 shared：项目日志文件。 部署代码当一键传输配置完成，客户端项目代码可以一键传输到服务器上，这样我们便可以开始部署服务器上的项目了。 在开始部署之前，我们需要确保本地和 Github 私人仓库代码的同步，先将本地文件同步到 Github： 12345678# 和仓库代码同步git pull# 代码添加到暂存区git add .# 提交暂存区到仓库区git commit -m &quot;update ecosystem&quot;# 传本地指定分支到远程仓库git push 这样提交完成后，在本地的根目录下执行命令，将代码向生产环境下部署： 1pm2 deploy ecosystem.config.js production 如果项目部署成功，配置文件中的post-deploy中的命令会自动执行(当然运行速度慢了可以将 npm 切换为 cnpm 或 yarn)，那么便可以看出 pm2 给出的提示： 12345678910[PM2][WARN] Applications api not running, starting...[PM2][WARN] Environment [production] is not defined in process file[PM2] App [api] launched (1 instances)┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐│ id │ name │ namespace │ version │ mode │ pid │ uptime │ ? │ status │ cpu │ mem │ user │ watching │├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤│ 0 │ api │ default │ 1.0.0 │ fork │ 9438 │ 0s │ 0 │ online │ 0% │ 9.1mb │ bpc │ disabled │└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘ ○ successfully deployed origin/master--&gt; Success 这样便表示代码部署成功，我们可以在服务器上所有端口使用清空： 1netstat -antp 可以查看端口开发情况，例如本人的6060端口： 1tcp 0 0 127.0.0.1:6060 0.0.0.0:* LISTEN 2657/node /var/www/ 注意：此时端口为127.0.0.1表明局域网可以访问，公网是不能访问到的，我们还需要 nginx 进行代理。 Nginx上面基本运行完成，但是只有局域网可以访问，我们需要将其使用 nginx 代理至公网上，至于 nginx 下载和配置便不多提了，我们可以新建一个配置文件，最终贴出我的配置： 12345678910111213141516server&#123; listen 80; server_name api.bipch.cn; access_log /www/wwwlogs/api.bipch.cn.log; error_log /www/wwwlogs/api.bipch.cn.error.log; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:6060; proxy_redirect off; &#125;&#125; 其原理也很简单，其拦截了80端口，并代理到本地的6060，并配置了相应的域名，日志，端口等信息，配置完成后，使用./nginx -s reload重启服务。 最后如果配置正确，并且相应端口的安全组已经打开，那么我们便可以正常访问相应的API了。 配置 httpshttps 配置肯定需要相应的证书的，由于本人服务器为阿里云，免费证书申请可以看这篇，申请成功后，修改我们的配置文件： 123456789101112131415161718192021222324252627282930313233server&#123; listen 80; listen 443 ssl; server_name api.bipch.cn; access_log /www/wwwlogs/api.bipch.cn.log; error_log /www/wwwlogs/api.bipch.cn.error.log; # HTTP_TO_HTTPS_START if ($server_port !~ 443)&#123; rewrite ^(/.*)$ https://$host$1 permanent; &#125; # HTTP_TO_HTTPS_END # HTTP_CONFIG_START ssl_certificate /www/server/panel/vhost/cert/api.bipch.cn/fullchain.pem; ssl_certificate_key /www/server/panel/vhost/cert/api.bipch.cn/privkey.pem; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; # HTTP_CONFIG_END location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:6060; proxy_redirect off; &#125;&#125; 这样接口便强制使用 https 协议，其重点在于ssl_certificate和ssl_certificate_key分别指向两个证书的路径。当所有属性配置完成后，重启指定的 nginx 便完成了反向代理。最后 pm2 便在本地6060运行，nginx 将80端口代理到6060端口，并且将80端口转发到443端口，使用 https 协议，这样便结合了 pm2 + nginx 完成了 node 项目的部署。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.bipch.cn/categories/Nginx/"}],"tags":[{"name":"项目部署","slug":"项目部署","permalink":"https://www.bipch.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.bipch.cn/tags/Nginx/"},{"name":"Koa2","slug":"Koa2","permalink":"https://www.bipch.cn/tags/Koa2/"},{"name":"pm2","slug":"pm2","permalink":"https://www.bipch.cn/tags/pm2/"}]},{"title":"react导航守卫","slug":"web/React/react-router","date":"2021-01-28T17:10:06.000Z","updated":"2021-03-08T19:52:24.143Z","comments":true,"path":"react-router/","link":"","permalink":"https://www.bipch.cn/react-router/","excerpt":"导航守卫在日常开发中经常会被使用到，比如一个界面需要登陆之后或需要某种权限才能进行访问，这样我们可以很简单的使用导航守卫实现。","text":"导航守卫在日常开发中经常会被使用到，比如一个界面需要登陆之后或需要某种权限才能进行访问，这样我们可以很简单的使用导航守卫实现。 导航守卫vue 的导航守卫主要分为 3 种，分别为：全局导航守卫、路由导航守卫、组件导航守卫，而最为常用的便是全局导航守卫中的beforeEach，每次界面的跳转都会经过里面的逻辑，只有通过才会进行跳转。例如一些组件需要登陆才能进行访问，否则进入登陆或者401界面，那么用 vue-router 可以这么写： 123456789const router = new Router(&#123; mode: &#x27;history&#x27;, routes: baseRouter&#125;);router.beforeEach((to, from, next) =&gt; &#123; // TODO: Landing logic next();&#125; 这样每次界面的跳转都会执行里面的逻辑，只有调用next()才能跳转，否则我们可以为其跳转到其它界面。那么 react-router 为什么不提供相应的 api 呢？其实是因为设计理念的区别，React 会选择让用户自己封装相应的功能，路由守卫功能在很久前也被人提出了react-router路由拦截官方说明，而作者更希望保证插件的灵活性，让用户自己封装相应代码的功能。 配置文件项目中为了方便，我们要添加路由配置文件，然后根据配置文件生成路由.。我们先定义路由数据类型： 1234567891011121314export interface routersProps&#123; // 路径 path: string, // 名称 name: string, // 是否需要登陆 auth?: boolean, // 是否严格验证 exact?: boolean, // 组件 component: React.FC&lt;any&gt;, // 子路由 children?: Array&lt;routersProps&gt;&#125; 这样定义了一些路由的数据类型，然后我们的路由数组可以这么定义： 12345678910111213141516171819202122232425262728const routers: Array&lt;routersProps&gt; = [ &#123; path: &#x27;/user&#x27;, name: &#x27;user&#x27;, component: React.lazy(() =&gt; import(&#x27;../layouts/UserLayout&#x27;)), children: [ &#123; exact: true, name: &#x27;userLogin&#x27;, path: &#x27;/user/login&#x27;, component: React.lazy(() =&gt; import(&#x27;../pages/login/index&#x27;)), &#125; ] &#125;, &#123; path: &#x27;/&#x27;, name: &#x27;index&#x27;, auth: true, component: React.lazy(() =&gt; import(&#x27;../layouts/BasicLayout&#x27;)), children: [ &#123; exact: true, name: &#x27;Article&#x27;, path: &#x27;/article&#x27;, component: React.lazy(() =&gt; import(&#x27;../pages/article/index&#x27;)), &#125; ] &#125;] 这样简单的定义了一些路由数组，其组件使用了React.lazy主要为了让组件使用的时候再去加载。 遍历路由既然组件已经定义完成了，下面我们需要根据配置文件遍历出组件，我们可以这样去封装组件的遍历： 123456789101112131415161718192021interface RenderRoutesProps&#123; routes: Array&lt;routersProps&gt;&#125;const RenderRoutesMap: React.FC&lt;RenderRoutesProps&gt; = (&#123; routes &#125;) =&gt; &#123; return ( &lt;Switch&gt; &#123; routes.map((route, index) =&gt; &#123; return ( &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; render=&#123;props =&gt; ( &lt;RouterGuard router=&#123;route&#125; routerProps=&#123;props&#125; /&gt; )&#125; /&gt; ) &#125;) &#125; &lt;/Switch&gt; )&#125;export default RenderRoutesMap; 这样组件RenderRoutesMap接收一个路由数组，但是我们并没有着急使用Route渲染，而是引入了另一个组件RouterGuard，并传入了 route(当前路由信息)、props(react-router) 作为参数。 HOC封装组件逻辑的判断因为需要被大量的组件使用，所以为了代码更好的复用这里使用 HOC，封装组件真正的展示： 123456789101112131415161718interface RouterGuardProps &#123; router: routersProps, routerProps: RouteComponentProps,&#125;const RouterGuard: React.FC&lt;RouterGuardProps&gt; = (&#123;router, routerProps&#125;) =&gt; &#123; const &#123; name, path, exact, auth, children = []&#125; = router; return ( &lt;Route name=&#123;name&#125; path=&#123;path&#125; key=&#123;path&#125; exact=&#123;exact&#125; render=&#123;() =&gt; &#123; return &lt;Suspense fallback=&#123;&lt;div&gt;loading....&lt;/div&gt;&#125;&gt; &lt;router.component &#123;...routerProps&#125;&gt; &lt;RenderRoutesMap routes=&#123;children&#125; /&gt; &lt;/router.component&gt; &lt;/Suspense&gt; &#125;&#125; /&gt; )&#125;export default RouterGuard; 首先对组件进行渲染，因为使用了React.lazy包装组件，所以使用的时候要加上React.Suspense，然后对组件内容进行递归调用，遍历组件的 children 子元素，因为可能设计到多层嵌套，这里直接把 children 传递给RenderRoutesMap组件，让其循环遍历即可。 添加逻辑处理上面我们基本路由已经遍历处理完成，我们可以直接在RouterGuard封装逻辑代码，因为我们所有路由都经过了它的封装，所以进入新的界面RouterGuard里面的逻辑都会执行，我们可以这样去封装： 123456789101112131415161718192021const RouterGuard: React.FC&lt;RouterGuardProps&gt; = (&#123;router, routerProps&#125;) =&gt; &#123; const &#123; name, path, exact, auth, children = []&#125; = router; const [loading, setLoading] = useState(true); useEffect(() =&gt; &#123; if(!!auth &amp;&amp; !localStorage.getItem(&#x27;token&#x27;))&#123; notification.error(&#123; message: &#x27;令牌无效&#x27;, description: &#x27;token 过期或失效，请重新登陆&#x27;, &#125;); routerProps.history.replace(&#x27;/user/login&#x27;); &#125;else&#123; setLoading(false); &#125; &#125;) return ( loading?&lt;PageLoading /&gt;:&lt;Route .../&gt; )&#125;export default RouterGuard; 这样我们添加 loading 属性，当界面还在加载或验证逻辑的时候会显示 loading 界面，处理完成才展示 router，如果不符合逻辑使用history.replace进行重定向。 引用上面代码已经基本封装完成，我们在使用路由时通过下面代码引用即可： 123&lt;BrowserRouter&gt; &lt;RenderRoutesMap routes=&#123;routes&#125; /&gt;&lt;/BrowserRouter&gt; 将路由数组传入即可完成。 总结上面代码可以满足基本的导航守卫的封装，但是代码还是有很多需要改进的地方，这里就先抛砖引玉了。如果需要实现较为好用的权限路由可以使用 umi路由，其内置了许多权限和路由相关的封装。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"导航守卫","slug":"导航守卫","permalink":"https://www.bipch.cn/tags/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"}]},{"title":"Next.js","slug":"web/React/Next/Next","date":"2021-01-27T15:29:22.000Z","updated":"2021-03-09T11:29:50.736Z","comments":true,"path":"react-next/","link":"","permalink":"https://www.bipch.cn/react-next/","excerpt":"一款轻量级的 React 服务端渲染框架，社区 的活跃度也不错，如果需要使用 React 做一个轻量级的 SSR 类型的项目是个不错的选择(比如个人博客)，其使用起来也是非常的简便。","text":"一款轻量级的 React 服务端渲染框架，社区 的活跃度也不错，如果需要使用 React 做一个轻量级的 SSR 类型的项目是个不错的选择(比如个人博客)，其使用起来也是非常的简便。 SSR将组件或页面由服务端解析，服务端请求数据并填充得到最终的 html 字符串返回客户端。 这样做优势在于： 利于SEO：平常界面信息都是通过客户端 JS 动态拼接生成的，需要服务端返回相应的数据才能正确显示，但浏览器爬虫并不会等界面完全加载之后才会抓取。而服务端渲染则更便于爬虫抓取整个网页的信息。 利于首屏渲染：因为服务端渲染完全由服务端返回客户端 HTML 字符串，客户端不需要解析 js 等文件，这样首屏的速度高于普通的方式。 当然其也不是全是优点，缺点也非常多： 服务器压力大：本来属于客户端的工作，现在统一交给服务端去做，如果出现高并发会对服务器造成不小负担。 开发条件受限：由于解析文件交给了服务端，所以一些代码的用法和以前有所区别。 hello world空文件下安装开发闭包插件： 1yarn add react react-dom next 修改package.json中的命令： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot; next build&quot;, &quot;start&quot;: &quot;next start&quot;&#125; 3 个命令每个都有着自己作用，后面会介绍，新建一个文件： 123456function Home()&#123; return ( &lt;div&gt;hello world&lt;/div&gt; )&#125;export default Home; 执行yarn dev运行项目，运行成功后，直接输入：http://localhost:3000/home 即可访问界面，不需再需要路由相关的封装，page下的所有文件都会自动创建路由。 create-next-app使用脚手架初始化项目可以更好的为我们组织代码，执行命令安装： 1yarn global add create-next-app 安装完成后，直接创建即可： 1create-next-app project-name 完成后执行yarn dev启动，启动完成后可以看到默认界面。 基础架构项目创建完成后，默认有些项目的配置： components：也其它的项目基本一样，也是用于存放组件的地方。 pages：所有的前端界面，该目录下的所有界面都会自动生成相应的路由。 pages/api：项目中所有网络请求 public：项目静态文件，可以用于存放不需要打包的文件，里面的文件打包时都会复制到另一个目录，不会经过打包处理。 styles：为项目提供初始化或界面的样式。 .gitignore：再向 Git 提交代码时，忽略一些文件。 很轻便的一种前端结构，并没有太复杂的配置。 界面跳转React 中跳转界面主要用 react-router-dom 等框架实现，但是 Next.js 并不需要在安装 react-router-dom 插件，我们跳转界面需要在 Next.js 中引入： 12345678import Link from &#x27;next/link&#x27;export default ()=&gt;( &lt;&gt; ... &lt;Link href=&quot;/&quot;&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/Link&gt; &lt;/&gt;) 这样便可以实现界面跳转了，但是 &lt;Link /&gt; 组件，只能接收一个组件。除了组件跳转，我们也可以通过 JS 代码进行跳转： 123456789101112import &#123; useRouter &#125; from &quot;next/router&quot;;export default ()=&gt; &#123; const router = useRouter(); return ( &lt;&gt; ... &lt;button onClick=&#123;()=&gt;&#123;router.push(&#x27;/home&#x27;)&#125;&#125;&gt;home&lt;/button&gt; &lt;/&gt; )&#125; 静态生成 or SSR这一点非常重要，Next 为界面提供了两种渲染的方式： 静态生成：只有构建(build)时才获取数据，之后每次引用都是构建的数据。 SSR：每次请求界面都会生成新的 html。 我们可以为每个界面选择一个渲染方式，两种区别便是获取数据的时机，具体结合实际使用，当然处于性能考虑最优选肯定为 静态生成 的方式。 数据获取根据不同的渲染方式获取数据的策略也不同，官网为我们提供了三个获取数据的方法： getStaticProps(静态生成)：构建(build)时获取界面数据。 getStaticPaths(静态生成)：构建(build)时根据数据渲染界面动态路由。 getServerSideProps(SSR)：每次界面请求都获取数据。 getStaticProps根据介绍很容易发现其作用，为我们的静态生成界面获取数据，默认格式如下： 123export async function getStaticProps(ctx) &#123; // TODO: Logic processing&#125; 直接导出该方法即可，方法中可以进行逻辑处理，例如可以这样写： 12345678910export async function getStaticProps(&#123; params &#125;) &#123; //? 获取数据 const detailedSource = await postDetails(params.id); //? 返回数据 return &#123; props: &#123; detailed: detailedSource &#125;, &#125;;&#125; 可以看出在ctx.params可以获取到动态路由的传参，然后利用async/await处理异步逻辑获取数据，最后 return 数据即可，组件中直接通过 props 即可获取到最后的数据。如果您熟悉一些 Next.js 可执行next build然后在.next/server/pages可以找到该文件，例如： 可以看出，当我们 build 时，其自动把含有getStaticProps界面和数据结合形成最终形成 html 静态界面，就算以后数据变化其也不会改变，除非重新 build 生成新的静态 html 界面。 getStaticPaths此方法只适用于含有动态路由的界面，例如一个界面的路径为pages/detailed/[id].jsx，转换为路由为：detailed/***，这是必须有一个getStaticPaths方法，表示那些 id 才能访问该界面。默认的格式为： 12345678export async function getStaticPaths() &#123; return &#123; paths: [ &#123; params: &#123; ... &#125; &#125; // See the &quot;paths&quot; section below ], fallback: true or false // See the &quot;fallback&quot; section below &#125;;&#125; 其两个熟悉必须按照指定格式返回： paths：表示那些路径可以访问该界面。 fallback：表示如果界面查找不到会不会生成备用界面(一般设置为 false 展示 404 界面)。 例如我们接口返回下面的数据： 1234[ &#123;id: 1, title: &#x27;Next入门&#x27;, ....&#125;, &#123;id: 2, title: &#x27;Next踩坑&#x27;, ....&#125;] 那么只有访问detailed/1和detailed/2才能访问pages/detailed/[id].jsx界面，否则例如detailed/3都跳转至 404 界面，那么我们可以这样写： 123456export async function getStaticPaths() &#123; // 获取数据 const source = await posts(); const paths = source.data.map((post) =&gt; `/detailed/$&#123;post.id&#125;`); return &#123; paths, fallback: false &#125;;&#125; 执行接口获取数据，然后拼接 paths 数据，最后将拼接后的数据返回给 Next 完成，这样只有指定的路由才能访问该界面其余的都会到 404 界面。当然我们也可以使用 build 打包，然后我们可以看到另一个由于的现象，也是在.next/server/pages目录下，我们动态路由 detailed 目录下： 可以清除看到getStaticPaths返回的每个数据都会生成一个 html 静态界面，开始有那味了。 getServerSidePropsSSR 渲染时会执行的函数，其使用和上面的getStaticProps非常相似，但由于其是服务端渲染，每次请求都触发而不是静态生成界面，所以其有着更多的属性和配置，可以看下其 官网的介绍 这里不多介绍了，其使用方式也是老一套。 自定义Head界面的标题一般都需要虽然界面的跳转进行着修改，我们可以使用 &lt;Head /&gt;轻松做到这样的事情： 1234567891011import Head from &#x27;next/head&#x27;;const Home = () =&gt; &#123; return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/Head&gt; ... &lt;/div&gt; )&#125; 打包其部署也是非常的简单粗暴，我们可以看下其 webpack 提供的命令： 123456&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next dev&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;export&quot;: &quot;next build &amp;&amp; next export&quot;&#125; 这里的export命令是本人添加的，正常只有前三个： dev：项目的运行命令，进行本地开发使用的命令。 start：启动打包之后代码的命令，Next build之后的代码必须依靠 start 才能启动，启动时也必须确保根目录下含有.next文件夹。 build：上面多次提及此命令，其会将项目进行打包，生成.next文件夹，以供 start 命令运行。 当然除了上述命令，其还未我们推出了export命令，其也必须依靠.next文件夹，运行之后可将.next文件转换为任何地方都可部署的静态文件，默认输出到out文件夹下，我们可以拿其和.next下的文件做一个对比： 可以看出其完全是静态界面，我们可以任意将其部署到任意服务器上。 部署Next 的部署方式也有多种多样。 Node官方对这种方式也有 介绍，使用起来也是最为方便的一种，直接使用build命令进行打包，然后使用start命令运行其打包的内容，成功之后，我们将端口的安全组进行配置便可以公网访问。 pm2虽然 Node 可以直接托管项目，但是不管项目的管理，还是维护都并不是很方便，所以便有了 Node 的服务管理工具 pm2，其目的便是为了托管 Node 服务。安装成功后，在项目的根目录下执行： 1pm2 start npm --name &quot;next&quot; -- run start 这样也就相当于npm run start了，按照正常逻辑是可以执行的，但是由于 Node 可能无法找到 npm 具体的路径，所以会报出： 1Created by npm, please don&#x27;t edit manually. 该错误表示 npm 具体路径可能无法访问，我们修改其启动命令为： 1pm2 start npm-cli.js绝对路径 --name &quot;next&quot; -- run start 这样便能指定 npm 运行了。 vercel由原班人马打包的部署的工具，同时也是官网比较推荐的，vercel中进行了一些简单的部署介绍，也可以看其 Github 提供了更详细的部署。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"https://www.bipch.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"}]},{"title":"Nginx配置https","slug":"Nginx/Nginx配置https","date":"2021-01-27T12:17:41.000Z","updated":"2021-03-07T05:49:54.348Z","comments":true,"path":"nginx-https/","link":"","permalink":"https://www.bipch.cn/nginx-https/","excerpt":"项目部署的时候，默认遵守为 http 协议，也是应用最为广泛的一种网络协议，而 https 可以称之为安全版的 http，也就是 http + ssl，所以 https 安全的基础便是 ssl。而如果 http 请求需要添加 ssl 证书。","text":"项目部署的时候，默认遵守为 http 协议，也是应用最为广泛的一种网络协议，而 https 可以称之为安全版的 http，也就是 http + ssl，所以 https 安全的基础便是 ssl。而如果 http 请求需要添加 ssl 证书。 申请SSL证书申请证书的方式有许多，包括阿里云、腾讯云、华为云等都能申请到SSL相关免费的证书。例如申请阿里云免费SSL证书，首先进入安全（云盾）—&gt; SSL证书界面： 选择购买证书，然后进入到证书资源包，依次进行选择： 选择之后，20个资源包其费用为0，直接购买付款便可以，购买完成后，进入我们的SSL列表，便可以看到证书资源包数量以及变为20，点击左侧证书资源包，进行证书的申请： 因为我已经使用过两个，默认是空列表，我们点击头部按钮的证书申请，按照自己的信息，填入域名、个人信息、所在地等完成后，会进行审核，一般不到一分钟便能完成审核，完成后根据服务器类型下载相应的证书(例如Nginx)，得到其压缩包，解压后得到：******.key、******.pem两个文件，这两个便是我们所要的证书文件。 Nginx 配置上面得到SSL证书文件之后，使用起来也是很方便，在 Linux 中安装并配置完成 Nginx 配置后，就可以配置指定的端口为 https 协议： 1234567891011121314151617181920server&#123; ... # HTTP_TO_HTTPS_START if ($server_port !~ 443)&#123; rewrite ^(/.*)$ https://$host$1 permanent; &#125; # HTTP_TO_HTTPS_END # HTTP_CONFIG_START ssl_certificate # *****.pem 文件路径; ssl_certificate_key # *****.key 文件路径; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; # HTTP_CONFIG_END ...&#125; 这样也可以完成了SSL证书的配置，并强制使用 https 协议，注意便是ssl_certificate和ssl_certificate_key两个路径属性的配置，执行nginx -s reload重启 nginx 即可生效配置。生效后会代理 443 端口，然后进行请求转发。 宝塔配置Https我们可以借助宝塔的 nginx 模块，很容易的对项目添加 https 协议，使用宝塔添加完成项目后，进入配置选择SSH，然后选择其它证书，将 .key 文件内容复制到密钥(KEY)，另一个内容复制到证书(PEM格式)中： 输入后直接保存，即可自动完成项目的配置，并且还可以配置强制项目使用 https 协议，如果不是，也会定向到 https 协议中。 总结通过上面的方法便能免费申请到阿里云的SSL证书资源包，但是其只能有20个，如果域名过多那便需要进行收费了。不过申请SSL证书的方法也要很多，并不是只有通过阿里云才能实现，这里就先抛砖引玉了。","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.bipch.cn/categories/Nginx/"}],"tags":[{"name":"https","slug":"https","permalink":"https://www.bipch.cn/tags/https/"}]},{"title":"Linux top","slug":"Linux/top命令","date":"2021-01-27T07:23:10.000Z","updated":"2021-03-08T18:45:04.435Z","comments":true,"path":"linux-top/","link":"","permalink":"https://www.bipch.cn/linux-top/","excerpt":"电脑运行时，如果需要查询正在运行的程序和内存占用情况，以及找出那个程序导致我们电脑卡顿，这些都是top命令可以胜任的工作，它能有效的监听电脑进程的运行情况，并提供PID字段可以让用户处理占用 cpu 消耗较大的应用。","text":"电脑运行时，如果需要查询正在运行的程序和内存占用情况，以及找出那个程序导致我们电脑卡顿，这些都是top命令可以胜任的工作，它能有效的监听电脑进程的运行情况，并提供PID字段可以让用户处理占用 cpu 消耗较大的应用。 首先我的服务器系统为Centos7.8，如果不一样那么打印出的信息可能会有些差别： 1&gt; top 执行完毕后，界面打印出下面信息： 1234567top - 00:59:04 up 21:49, 2 users, load average: 0.09, 0.25, 0.34Tasks: 102 total, 1 running, 101 sleeping, 0 stopped, 0 zombie%Cpu(s): 7.4 us, 4.4 sy, 0.0 ni, 88.2 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1014696 total, 131908 free, 366040 used, 516748 buff/cacheKiB Swap: 1049596 total, 777980 free, 271616 used. 499336 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 可能第一次看着比较乱，但是这些信息将电脑的cpu、内存等资源的使用情况都提供出来了。 如何阅读首先其输出分作两部分，上部分(1 - 5行)为一些统计的信息，其余则是下部分包含所有服务信息的一个表格(由于太多没有列出来，只是列出一个表头)。 而我们解析只需要从这两部分入手。 上部分第一行：主要用于显示当前事件、服务器登陆数、系统负载情况。 top：监测时的系统时间(会一直刷新)。 users：系统登陆数。 load average：三个值，分别为过去1分钟、5分钟、15分钟的系统负载。 第二行：主要用于显示系统中各个类型进程的个数。 total：系统总进程数。 running：系统运行进程数。 sleeping：系统等待的进程数。 stopped：系统停止的进程数。 zombie：系统被复原的进程数。 第三行：该行主要显示按类型划分 cpu 使用情况。 us：用户进程占比。 sy：系统进程占比。 ni：nice 用户进程占比，也就是改变过优先级类型的进程占比。 id：cpu 空闲时间占比，该值越小说明 cpu 越忙。 wa：等待异步操作完成的时间占比。 hi：硬中断占用 cpu 的百分比。 si：软中断占用 cpu 的百分比。 st：”虚拟机管理程序从该虚拟机窃取的时间占比”。 可以使用 t(toggle) 切换折叠 Task(第二行) 和 %Cpu(s)(第三行) 的展开和折叠。 第四行与第五行：主要提供了内存、交换分区的信息。 total：总内存容量。 free：空闲内存。 used：已用内存。 下部分系统中正在运行的进程，默认按照 cpu 使用频率降序排序，我们输入M进行按照内存排序，输入P按照 cpu 使用频率排序。当然如果 cpu 使用频率较高的话，表示程序消耗了许多的资源，也就是造成电脑卡顿的最终祸首。其提供了下面关于服务的信息： PID：进程的唯一标识符，可以借助 ID 关闭指定的服务。 USER：运行进程的用户。 PR：优先级。 NI：Nice 值，表示进程的优先级。 VIRT：虚拟内存的大小。 RES：常驻内存的大小。 SHR：共享内存的大小。 S：进程的运行状态，I 代表空闲、R 代表运行、S 代表休眠、Z表示僵尸进程、T 或 t 代表停止等。 %CPU：自上次屏幕更新 cpu 的使用率。 %MEM：自上次屏幕更新，RES常用内存使用率。 TIME+：自从程序启动后总的 CPU 使用时间。 COMMAND：启动命令。 cpu使用率较高当 cpu 空闲时间较高时，服务器可以正常的工作，当 cpu 空闲较低时，我们的服务器会变得非常的卡，甚至会影像到我们部署到服务器上的各个服务。例如我服务器为阿里云最基础的配置，如果同时在服务器下载多个文件，那么便会出现： 这种情况，可以看到id已经为0，此时服务器会非常的卡，甚至我们部署在服务器上的服务也都是无法进行访问的，此时需要在 top 命令行中输入k，此时程序会给出提示： 1PID to signal/kill [default pid = 30] 其默认关闭排行第一的服务，也可以自己输入指定程序的PID字段，回车便可以关闭指定的程序，关闭成功后，服务器恢复正常： 我们可以借助 top 命令查询当前系统的运行状态，其也为我们提供了很多配置帮助我们更好的进行工作，查找指定指定配置我们可以看其为我们提供的手册。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.bipch.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.bipch.cn/tags/Linux/"}]},{"title":"redux-saga","slug":"web/React/Redux/redux-saga","date":"2021-01-26T10:56:17.000Z","updated":"2021-03-08T19:53:40.738Z","comments":true,"path":"react-redux-saga/","link":"","permalink":"https://www.bipch.cn/react-redux-saga/","excerpt":"redux-saga 是一个用于管理应用程序副作用的 redux 中间件，它的目标是让副作用集中处理，然后方便以后的维护和扩展。它和其他解决异步中间件不同，它像进程一样可以主应用程序启动，暂停和取消，也能访问完整的 redux state、dispatch、redux action。","text":"redux-saga 是一个用于管理应用程序副作用的 redux 中间件，它的目标是让副作用集中处理，然后方便以后的维护和扩展。它和其他解决异步中间件不同，它像进程一样可以主应用程序启动，暂停和取消，也能访问完整的 redux state、dispatch、redux action。 流程redux-saga 通过监听 action，只需我们发送了指定的 action，便会进行拦截。转换为流程图如下： 基本可以把 saga 分解为 Worker 和 Watcher：Saga = Worker + Watcher。 简单的Hello Word虽然上面说的很难理解，但是通过下面代码可以很好的理解： 创建 Store 添加中间件1234567891011// 引入saga中间件import createSagaMiddleware from &#x27;redux-saga&#x27;;// 创建sagaconst sagaMiddleware = createSagaMiddleware();// 项目添加 saga 中间件const store = createStore( reducer, composeWithDevTools( applyMiddleware(sagaMiddleware) )); 创建监听redux-saga 主要工作方式便是监听指定的 action，这一步还是比较重要： 1234567891011import &#123; takeEvery, put, delay &#125; from &#x27;redux-saga/effects&#x27;;// 创建新的任务function* incrementAsync() &#123; yield delay(2000); yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;// 创建监听函数export function* watchIncrementAsync() &#123; // 监听 INCREMENT_ASYNC ，派发到 incrementAsync 任务 yield takeEvery(&#x27;INCREMENT_ASYNC&#x27;, incrementAsync);&#125; 启动监听简单创建完成后，需要在根目录启动 redux-saga 的监听： 123456789101112// 收集到所有的监听import &#123; all, fork &#125; from &#x27;redux-saga/effects&#x27;;import * as userSagas from &#x27;./user&#x27;;export default function* rootSage() &#123; yield all([ ...Object.values(userSagas) ].map(fork));&#125;// 根目录启动监听sagaMiddleware.run(rootSaga); es6 Generator主要解决异步执行造成的 地狱回调 问题，可以暂时让函数的执行流挂起。 在线验证工具：jsbin 例子简单的一个示例了解下 Generator 执行过程： 123456789function* Generator()&#123; yield &#x27;start&#x27;; yield &#x27;hello word&#x27;; return &#x27;end&#x27;;&#125;let Gen = Generator();console.log(Gen.next());console.log(Gen.next());console.log(Gen.next()); 其打印结果为： 123&#123;done: false, value: &quot;start&quot;&#125;&#123;done: false, value: &quot;hello word&quot;&#125;&#123;done: true, value: &quot;end&quot;&#125; 可以看到当我们创建函数时不会立即执行，当我们调用 next 方法时，函数会开始执行，一直到yield 暂停执行，挂起函数，直到下次调用 next 方法。函数运行返回值为一个json，done 表示是否结束，value 是返回值。 传递参数和接收参数当我们代码为下面样子时： 1234567891011function* Generator()&#123; let name = yield &#x27;start&#x27;; console.log(name); let age = yield &#x27;hello word&#x27;; console.log(age); return &#x27;end&#x27;;&#125;let Gen = Generator();console.log(Gen.next());console.log(Gen.next(&#x27;blog&#x27;));console.log(Gen.next(23)); 其打印结果为： 12345&#123;done: false, value: &quot;start&quot;&#125;&quot;blog&quot;&#123;done: false, value: &quot;hello word&quot;&#125;23&#123;done: true, value: &quot;end&quot;&#125; 可以看到 next 方法参数传递给 上一个 yield 中，达到赋值的效果。 异步转同步那么我们为什么要使用 Generator，其实主要便是为了解决项目中异步代码很容易造成地狱回调，而我们使用 Generator 可以很好的处理异步： 1234567891011121314151617181920function *gen() &#123; var posts = yield fetch(&quot;https://jsonplaceholder.typicode.com/posts&quot;); console.log(&#x27;posts&#x27;, posts[0].title); var users = yield fetch(&quot;https://jsonplaceholder.typicode.com/users&quot;); console.log(&#x27;users&#x27;, users[0].name);&#125;function run(generator) &#123; var myGen = generator(); function handle(yielded) &#123; if (!yielded.done) &#123; yielded.value.then(function(response)&#123; return response.json(); &#125;).then(function(json) &#123; return handle(myGen.next(json)); &#125;) &#125; &#125; return handle(myGen.next());&#125;run(gen); APItakeEvery很基础的一个方法，用来监测监听 action，每次发送 action 都会进行监听，拦截指定的 action 并分配新的任务： 12345import &#123; takeEvery &#125; from &#x27;redux-saga/effects&#x27;;export function* watchIncrementAsync() &#123; // 监听拦截 INCREMENT_ASYNC action，派发新的任务 yield takeEvery(&#x27;INCREMENT_ASYNC&#x27;, incrementAsync);&#125; put用来发送新的 action 请求，内部是对 Redux 中 dispath 的一个封装，也是需要接收一个 action 参数： 1234import &#123; put &#125; from &#x27;redux-saga/effects&#x27;;function* incrementAsync() &#123; yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125; delay将程序延迟指定时间后执行，相当于一个延迟函数： 123456import &#123; put, delay &#125; from &#x27;redux-saga/effects&#x27;;function* incrementAsync() &#123; yield delay(2000); yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125; 这样任务延迟 2 秒后会执行 put 发送一个 action。 takeLatest和上面的 takeEvery 基本相同，但是 takeEvery 如果这次异步还没有结束，此时若发送下一次请求，takeEvery 会累计放入执行队列中依次执行，而 takeLatest 不是，它会以取消前面的action，以最后一次发送的 action 为准： 1234import &#123; takeLatest &#125; from &#x27;redux-saga/effects&#x27;;export function* watchIncrementAsync() &#123; yield takeLatest(&#x27;INCREMENT_ASYNC&#x27;, incrementAsync);&#125; 使用方式和 takeEvery 基本相同。 call主要是为了帮我们的函数参数作为 call 的参数传入，返回值是一个 js对象。call 作用主要是为了方便我们测试代码，和规范我们项目代码： 123456789import axios from &#x27;axios&#x27;;import &#123; takeLatest, put, call &#125; from &#x27;redux-saga/effects&#x27;;function* incrementAsync() &#123; // 普通的函数 const a = yield axios.get(&quot;https://jsonplaceholder.typicode.com/users&quot;); // 使用call后 const b = yield call(axios.get, &quot;https://jsonplaceholder.typicode.com/users&quot;); yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;);&#125; Allall 给我们提供了一种并发执行多个异步请求的操作。如果我们接口需要并发执行，则需要使用这个方法： 1234567891011function* fetchUser() &#123; const user = yield call(axios.get, &quot;https://jsonplaceholder.typicode.com/users&quot;); console.log(user);&#125;function* incrementAsync() &#123; yield all([ fetchUser(), fetchUser(), ]); yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;);&#125; fork非阻塞式调用：上面介绍了 call 的使用方式，但是相对于 generator 来说，call是阻塞式 的，只有上一个 promise 返回才会执行下一个。而 fork是非阻塞式 的，是并发执行所有任务，不用等到上一个任务的promise： 123456import &#123; takeLatest, put, call, fork &#125; from &#x27;redux-saga/effects&#x27;;const delay = (ms) =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));function* incrementAsync() &#123; yield fork(delay, 2000); yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;);&#125; 根据结果可以看出程序并不会延迟 2 秒后发送 action，而是延迟和发送并发执行，当我们把fork变为call时： 1yield call(delay, 2000); 程序会等待2秒后会发送请求。 cancel用于取消 fork 还未结束的任务，防止 fork 任务等待时间过长引起其他一些不必要的错误： 123456789101112function* increment () &#123; while(true)&#123; console.log(&#x27;11111&#x27;); yield delay(1000); console.log(&#x27;22222&#x27;); &#125;&#125;function* incrementAsync() &#123; const task = yield fork(increment); yield cancel(task); yield put(&#123; type: &#x27;INCREMENT&#x27; &#125;);&#125; race当我们需要并发执行多个任务，并不一定需要等待所有操作完成，只需有一个操作完成即可继续执行下面的方法。这就是race方法的用处，它可以并发执行多个请求，只要有一个请求返回，race就正常返回请求，并且取消其余的请求： 12345const &#123; a, b &#125; = yield race(&#123; a: call(axios.get, &#x27;https://jsonplaceholder.typicode.com/users&#x27;), b: call(axios.get, &#x27;https://jsonplaceholder.typicode.com/todos&#x27;)&#125;);console.log(a, b); 总结redux-saga 最为 redux 一个非常优秀的中间件，可以为 redux 解决很多问题，包括异步 action、分离逻辑等，在开发中还是很好用的。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://www.bipch.cn/tags/Redux/"}]},{"title":"Error-first","slug":"Node/Error-first","date":"2021-01-16T17:50:47.000Z","updated":"2021-03-01T11:46:18.466Z","comments":true,"path":"error-first/","link":"","permalink":"https://www.bipch.cn/error-first/","excerpt":"在 Node 这么火的今天，其成功离不开内部高效的事件循环以及异步I/O，整个 Node 的设计从上到下都遵循着异步的概念。而 Node 处理异步指定的标准便是error-first也被称之为错误优先。","text":"在 Node 这么火的今天，其成功离不开内部高效的事件循环以及异步I/O，整个 Node 的设计从上到下都遵循着异步的概念。而 Node 处理异步指定的标准便是error-first也被称之为错误优先。 error-first因为 Node 中存在大量的异步，而处理异步最多的还是传入callback，对于异步任务，必须要指定任务完成后需要执行的回调函数，才能准确的接收到异步任务的执行结果。而随着callback回调越来越多，其传参也越来越多样化，Node 觉得必需对callback指定一个标准，这个标准便是error-first： callback函数的第一个参数为 error 对象保留。如果发生异常，异常信息会被放在第一个 err 参数返回。 callback函数的第二个参数保留给成功的响应数据。如果没发生异常，err参数会传递 null，第二个参数为成功后的返回数据。 具体代码，可以看 Node fs 提供的回调方式： 1234fs.readFile(&#x27;/foo.txt&#x27;, function(err, data) &#123; // TODO: Error Handling Still Needed! console.log(data);&#125;); 我们在使用一些 Node 异步的时候也需要注意其规范，这样才能正常接收数据和处理错误。","categories":[{"name":"Node","slug":"Node","permalink":"https://www.bipch.cn/categories/Node/"}],"tags":[{"name":"error-first","slug":"error-first","permalink":"https://www.bipch.cn/tags/error-first/"}]},{"title":"Koa2","slug":"Node/Koa2","date":"2021-01-16T17:50:47.000Z","updated":"2021-03-07T06:12:25.734Z","comments":true,"path":"node-koa2/","link":"","permalink":"https://www.bipch.cn/node-koa2/","excerpt":"一个非常流行的基于 Node 平台的 web 开发框架，优点便是非常小，但是扩展性却极其强。非常的干净利落。和另外一个比较的开发框架 Express 作用是相同的。","text":"一个非常流行的基于 Node 平台的 web 开发框架，优点便是非常小，但是扩展性却极其强。非常的干净利落。和另外一个比较的开发框架 Express 作用是相同的。 koa2 和 express 的区别虽然 koa2 和 express 作用是相同的，并且都是原班人马打造的，但是两者使用的区别还是很大的。 集成度：koa2 是一个非常轻量级的开发框架，里面并没有继承太多的插件，例如实现 Router 还需要安装koa-router、加载文件需要koa-static，而 express 内置了大量的插件，包括router、文件等插件都进行了内置。 社区活跃度：由于 express 是一款比较成熟的框架，其上手难度是比较小的，并且其社区活跃度远高于 koa2，截至本篇文章，在 npm 上对比其插件的数量如下： 可以看出差别还是很大的。 中间件：express 的中间件是一款典型的线性模型，也就是自上而下依次去执行，而 koa 中间件是洋葱模型。 洋葱模型关于 koa 中间件有一个很形象的图片： 可以看出其开始的时候，是依次开始执行，执行到next便会执行下一个中间件，而结束的时候是像栈操作一样，先进入的是最后去执行的。例如我们可以方便的添加日志，记录每个接口的请求信息与时间： 123456789101112131415161718192021const Koa = require(&#x27;koa&#x27;);const app = new Koa();// loggerapp.use(async (ctx, next) =&gt; &#123; console.log(&#x27;第一层 - 开始&#x27;); const start = Date.now(); await next(); const ms = Date.now() - start; console.log(`$&#123;ctx.method&#125; ----------- $&#123;ctx.url&#125; ----------- $&#123;ms&#125;ms`); console.log(&#x27;第一层 - 结束&#x27;)&#125;);// responseapp.use(async ctx =&gt; &#123; console.log(&#x27;第二层 - 开始&#x27;) ctx.body = &#x27;Hello World&#x27;; console.log(&#x27;第二层 - 结束&#x27;)&#125;);app.listen(3000); 这样便通过第一个中间件打印日志信息，当执行到next方法时，会执行下一个中间件直到结束碰到ctx.body，然后进行出栈操作。所以上面代码执行后打印出下面信息： 12345第一层 - 开始第二层 - 开始第二层 - 结束打印第一次执行的结果： GET -------- / ------ 6ms第一层 - 结束 koa-router由于 koa 并未内置是一款小型轻量级的开发框架，并未内置过多的插件，所以一些功能需要借助一些插件来完成，例如路由的实现可以依靠koa-router。 getget 方式比较方便，并且动态路由传递方式也很简单： 12345678910111213141516171819const Koa = require(&#x27;koa&#x27;);const router = require(&#x27;koa-router&#x27;)();const app = new Koa();// logsapp.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; url $&#123;ctx.request.url&#125;`); await next();&#125;);// post routerrouter.get(&#x27;/:name&#x27;, (&#123;params&#125;) =&gt; &#123; ctx.body = &#x27;Hello &#x27; + params.name;&#125;);// add router middlewareapp.use(router.routes());app.listen(3000); 这样可以直接 get 方式请求 http://localhost:3000/koa2 最后可以返回正确的数据。 koa-bodyparser上面的形式只能处理简单的路径传参，但是参数复杂或者通过别的形式传参，就需要通过koa-bodyparser中间件处理传递过来的数据了： 12345678910111213141516171819202122232425262728293031const app = new Koa();const Koa = require(&#x27;koa&#x27;);const router = require(&#x27;koa-router&#x27;)();const bodyParser = require(&#x27;koa-bodyparser&#x27;);// add koa-bodyparser middlewareapp.use(bodyParser());// logsapp.use(async (ctx, next) =&gt; &#123; console.log(`Process $&#123;ctx.request.method&#125; url $&#123;ctx.request.url&#125;`); await next();&#125;);// post paramsrouter.post(&#x27;/&#x27;, async (ctx) =&gt; &#123; const params = ctx.request.body; ctx.response.body = `&lt;h1&gt;post，$&#123;params.name&#125;&lt;/h1&gt;`;&#125;);// get paramsrouter.get(&#x27;/&#x27;, async (ctx) =&gt; &#123; const params = ctx.request.query; ctx.response.body = `&lt;h1&gt;get，$&#123;params.name&#125;&lt;/h1&gt;`;&#125;);// add router middlewareapp.use(router.routes());app.listen(3000);console.log(&#x27;app started at port 3000...&#x27;); 使用Insomnia可以测试我们的接口： 可以看出接口返回了正确的数据。 中间件应用项目中会有些接口是需要一定的权限或者登陆后才能进行访问的，有些接口一些字段是不能重复的，但是如果将代码都重新写一遍会消耗大量的时间，同时也不利于维护，而解决方式便可以使用中间件去解决。例如：一些接口需要登陆之后才能继续访问，否则返回前端401，那我们只需判断前端是否传入 token 和其正确性即可： 12345678910111213141516171819// 定义const checkUserMiddleware = async (ctx, next) =&gt; &#123; if (ctx.request.headers[&quot;authorization&quot;]) &#123; // TODO: Authentication is also required await next() return &#125; // 登陆失败，禁止继续执行，所以不需要执行 next() ctx.body = &#123; status: 401, msg: &#x27;token 失效&#x27; &#125;&#125;export default checkUserMiddleware;// 使用router.post(&#x27;/info&#x27;, checkUserMiddleware, async (ctx, next) =&gt; &#123; ....&#125;) 这样没有接口需要登陆拦截，添加上述中间件即可。 部署API 开发完成后，可以直接再服务器通过 Node 运行项目完成部署，但是由于 Node 即不容易管理，并且相关 doc 窗口关闭服务便会停止，所以我们需要一个 Node 的服务管理工具，这里推荐 pm2。启动命令很简单： 1pm2 start 启动文件 也可以通过下面方式查看所有托管的服务： 1pm2 list 也可以使用pm2 init生成默认的配置文件 ecosystem.config.js，也可以配置启动命令，例如贴出我的简单配置： 1234567891011121314module.exports = &#123; apps: [&#123; // 启动名称 name: &#x27;api&#x27;, // 启动文件 script: &#x27;./src/index.js&#x27;, // 监听改变 watch: true, // 忽略监听 ignore_watch: [ &quot;node_modules&quot; ] &#125;], // 部署配置 deploy: &#123;...&#125;&#125;; 这样一个简单的 pm2 配置便完成了，然后使用下面命令启动： 1pm2 start ecosystem.config.js 即可完成服务托管。","categories":[{"name":"Node","slug":"Node","permalink":"https://www.bipch.cn/categories/Node/"}],"tags":[{"name":"Koa2","slug":"Koa2","permalink":"https://www.bipch.cn/tags/Koa2/"}]},{"title":"Vue $set","slug":"web/Vue/vue-$set","date":"2021-01-14T10:25:49.000Z","updated":"2021-03-07T12:46:29.670Z","comments":true,"path":"vue-set/","link":"","permalink":"https://www.bipch.cn/vue-set/","excerpt":"在 Vue 中其核心便是数据劫持-数据订阅，数据劫持主要劫持 data 对象的所有 property，并使用 Object.defineProperty 把所有 property 添加 getter/setter 方法。但是由于 Object.defineProperty 不能劫持整个对象，只能劫持对象的一个个属性，并且不能监听数组、对象属性等，所以在 Vue 中数组或者对象属性改变是监听不到的，而$set便是为了解决这些问题。","text":"在 Vue 中其核心便是数据劫持-数据订阅，数据劫持主要劫持 data 对象的所有 property，并使用 Object.defineProperty 把所有 property 添加 getter/setter 方法。但是由于 Object.defineProperty 不能劫持整个对象，只能劫持对象的一个个属性，并且不能监听数组、对象属性等，所以在 Vue 中数组或者对象属性改变是监听不到的，而$set便是为了解决这些问题。 definePropertyObject.defineProperty 方法主要用于劫持 JavaScript 对象，当我们访问相应对象时，会执行相应的逻辑： 12345678910let object1 = &#123;name: &#x27;123&#x27;&#125;;Object.defineProperty(object1, &#x27;name&#x27;, &#123; get()&#123;......&#125;, set()&#123;......&#125;,&#125;);object1.name = 77;console.log(object1.name); 通过上述代码便监听了 object1 的 name 属性，一旦修改或读取便会调用相应的 getter/setter 方法，一旦数据有修改 defineProperty 便会监听到，执行一系列逻辑。 defineProperty 监听对象在 Vue 官网却有着下面的一句话：由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。造成该问题的原因便是因为 defineProperty 不能监听整个对象，只能遍历对象的各个属性，例如我们有下面的数据： 1234let object1 = &#123; name: &#x27;123&#x27;, age : 123&#125;; 监听这种数据，只能递归调用： 123456789101112131415161718192021222324252627282930313233343536// 递归，确保每个属性都被监听function Observer(data) &#123; if (!data || typeof data !== &#x27;object&#x27;) &#123; return; &#125; Object.keys(data).map(key =&gt; &#123; defineReactive(data, key, data[key]); &#125;);&#125;// 监听指定数据function defineReactive(data, key, val) &#123; // 确保子元素监听 Observer(val); // 开启监听 Object.defineProperty(data, key, &#123; // 可枚举 enumerable: true, // 不可删除 configurable: false, get: function () &#123; return val; &#125;, set: function (newVal) &#123; console.log(&#x27;我捕获到了数据变化: &#x27;, val, &#x27; --&gt; &#x27;, newVal); val = newVal; &#125; &#125;);&#125;// 监听的数据const obj = &#123; name: &#x27;123&#x27;, age : 123&#125;;Observer(obj); 这样递归才能实现对象的监听，但是这样也造成了：数组 和 对象 新增属性都是无法触发 setter 的(除了数组的 push、pop、shift、unshift、splice、sort、reverse 因为它们都修改原数据)。而 Vue 并不会去解决这个问题，因为这是 defineProperty 方法的特性，刻意解决只会造成性能的浪费，而为了解决这个问题，便提出了 $set 方法。 $set因为 Vue 提倡使用$set 进行数组等数据的修改，其主要接收 3 个参数： target：需要添加属性的对象，也就是我们要在那个对象上面添加属性。 key：新增属性的 key，也就是我们新增属性的索引。 val：新增属性的值，我们要添加进的值。 我们打开其源码，位于：src/core/observer/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243function set(target: Array &lt; any &gt; | Object, key: any, val: any): any &#123; // 主要用于判断是不是基本数据类型 if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; (isUndef(target) || isPrimitive(target)) ) &#123; warn(`Cannot set reactive property on undefined, null, or primitive value: $&#123;(target: any)&#125;`) &#125; // 数组的处理 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key) // 利用 splice 实现数组替换 target.splice(key, 1, val) return val &#125; // 对象，并且该属性原来已存在于对象中，则直接更新 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val return val &#125; // vue给响应式对象(比如 data 里定义的对象)都加了一个 __ob__ 属性， // 如果一个对象有这个 __ob__ 属性，那么就说明这个对象是响应式对象，我们修改对象已有属性的时候就会触发页面渲染。 // 非 data 里定义的就不是响应式对象。 const ob = (target: any).__ob__ if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27; + &#x27;at runtime - declare it upfront in the data option.&#x27; ) return val &#125; // 不是响应式对象 if (!ob) &#123; target[key] = val return val &#125; // 是响应式对象，进行依赖收集 defineReactive(ob.value, key, val) // 触发更新视图 ob.dep.notify() return val&#125; 总结下上面的流程大致如下： 首先判断数据是否为对象类型，如果是普通类型的属性，则会抛出异常。 判断是否为数组，并且 key 值是否为有效的，如果成功则选择数组长度和 key 值获取最大的数值，作为数组新的 length 值，并且使用 splice 方法进行替换。 判断数据值是否为响应的 _ob_： 如果是 Vue实例，直接不行，抛出错误。 如果不是响应数据，就是普通的修改数据对象操作。 如果是响应数据，那就通过 Object.defineProperty 进行数据的劫持。 通知 DOM 进行数据更新。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.bipch.cn/tags/Vue/"}]},{"title":"Promise","slug":"web/ES6/Promise","date":"2021-01-13T10:32:04.000Z","updated":"2021-03-07T06:42:19.487Z","comments":true,"path":"es6-promise/","link":"","permalink":"https://www.bipch.cn/es6-promise/","excerpt":"Promise 是异步编程的一种解决方案，由 ES6 将其写进了语言标准，统一了用法，并原生提供了Promise 对象。Promise 要用于解决前端代码中异步操作的处理，可以将异步操作队列化，使其按照指定的顺序执行，可以很好的解决代码中出现回调地狱的问题。","text":"Promise 是异步编程的一种解决方案，由 ES6 将其写进了语言标准，统一了用法，并原生提供了Promise 对象。Promise 要用于解决前端代码中异步操作的处理，可以将异步操作队列化，使其按照指定的顺序执行，可以很好的解决代码中出现回调地狱的问题。 回调地狱主要前端代码需要处理多个函数，并且下一个函数的参数为前一个参数的返回值，这样便会造成回调地狱的问题。虽然看着定义有点绕，但是看下面代码就能看出回调地狱的问题了: 12345678910startRequest1(url, (err1, res1) =&gt; &#123; if(err1) return throw Error(err1.errorMsg); startRequest2(res1, (err2, res2) =&gt; &#123; if(err2) return throw Error(err2.errorMsg); startRequest3(res2, (err3, res3) =&gt; &#123; if(err3) return throw Error(err3.errorMsg); .... &#125;) &#125;)&#125;) 这样嵌套下去，每一次都需要处理错误，然后处理下一个请求，一旦有一个请求错误，异常也很难处理，并且代码可读性非常的低、也极难维护。 特点和缺点Promise可以链式的处理项目中的异步操作，并提供了一系列的API，可以设置成功、失败等时候的函数调用，这样使得控制异步操作更容易。Promise主要有2个特点： 对象状态不受外界影响。Promise主要有3中状态 Pending(进行中)、Fulfilled(已执行)、Rejected(已拒绝)。只有处理异步操作的结果，可以决定是哪一种状态，任何操作都无法改变这个状态。 状态修改后，就不会发送改变，任何时候都可以得到这个结果。Promise的状态修改只有两种情况： 从Pending状态变为Resolved状态。 从Pending状态变为Rejected状态。 只有这两种情况，一旦修改状态便被锁定了，不会在发送变化了。 Promise也不是都是优点，虽然解决了回调地狱的问题，但是也是有一些缺点的: Promise一旦创建便无法取消，只能一路走下去。 如果不设置处理函数，无论成功、还是失败都不会返回到外部，换句话说Promise内的错误是无法在外面用 try{…}catch(){…} 捕捉的，只能在错误执行函数中执行错误。 状态无法预测，无法得知异步操作具体执行到那一步了。基本用法一般 Promise 代码为下面的格式：1234567891011121314151617let p = new Promise((resolve, reject) =&gt; &#123; ... if(...)&#123; // 成功 resolve(data); &#125;else&#123; // 失败 reject(error); &#125;&#125;)p.then(res =&gt; &#123; // 请求成功 ...&#125;, err =&gt; &#123; // 处理错误 ...&#125;) 使用 Promise 对象创建一个 p，执行里面逻辑，然后注册 then 中的成功和失败事件。new Promise 构造函数接收一个函数作为参数。 创建 Promise 时，会自动执行。 参数函数主要有 resolve 和 reject 两个参数。 在Promise执行过程中调用 resolve 函数状态将变为 fulfilled，调用 reject 时状态变成 rejected，它们可以接收参数，相应的参数都会传递给下一个方法中。 thenthen 主要有两个参数，分别对应两种状态，接收的数据为上一个方法传递的数据： 当Promise的状态为 fulfilled 时，会执行第一个函数参数。 当Promise的状态为 rejected 时，会执行第二个函数参数。解决回调地狱上面介绍了一些地狱回调的问题，下面开始用 Promise 解决该问题：123456startRequest1().then(res =&gt; startRequest2(res)).then(res =&gt; startRequest3(res)).then(res =&gt; startRequest4(res)).then(res =&gt; startRequest5(res))... 对比下上面地狱回调代码，代码通过Promise会变得非常的简明。 异步并发如果多个并发的执行，只有获取全部完成后，才会返回结果。用普通的方式来编写那便是下面的代码：1234567891011let tasks = [getData1, getData2, getData3, getData4, getData5];let datas = [];tasks.map(res =&gt; &#123; res(data =&gt; &#123; datas.push(data); if (datas.length === tasks.length) &#123; // 已经全部请求完了，此时可以调用回调 &#125; &#125;)&#125;) 上面通过编辑成功后通过回调传入，一旦执行完成便会进入if。很麻烦啊，Promise 提供更方便的 API：123456789Promise.all([ getData1, getData2, getData3, getData4, getData5]).then(datas =&gt; &#123; // 已拿到全部的data，可以处理了&#125;) 对比很明显，Promise可以将我们的请求更清晰明了。 API实例方法 then: 上面介绍了then用法，主要用于链式进行调用。 catch: 主要用于捕获Promise里面的异常，应为Promise内的异常无法用 try 进行捕获。 finally: 无论Promise对象最终是成功还是失败都会去执行其中方法。 静态方法Promise除了提供一些实例方法，还提供了一些静态的方法： all: 主要处理并发请求。 race: 和上面all相似，但是all是都成功才会调用回调，而race(赛跑)也是并发，但是一旦有一个请求完成，便会立即停止(不管结果本身是成功状态还是失败状态)。 resolve: 返回一个状态为fulfilled的Promise对象，它的参数会传递给下面的回调函数中去。 reject: 和上面的基本同理，只是Ppromise的状态不同。 总结可以看到通过Promise创建实例，然后通过链式调用 .then.then.then 开始编码，这便是Promise的使用形式，可以看到它基本模式是： 可以将异步转换为Promise。 对象主要有3中状态(Pending(进行中)、Fulfilled(已执行)、Rejected(已拒绝))。 通过 .then 进行调用。 完成后触发相应的回调。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.bipch.cn/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://www.bipch.cn/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"Mongoose聚合查询","slug":"数据库/MongoDB/Mongoose聚合查询","date":"2020-12-22T07:02:21.000Z","updated":"2021-03-08T19:52:29.612Z","comments":true,"path":"Mongoose-aggregate/","link":"","permalink":"https://www.bipch.cn/Mongoose-aggregate/","excerpt":"在 MongoDB 中，聚合(aggregate)主要可以用于多个表之间的联合查询，并且可以进行求和、求平均值、最大与最小值等，在项目中使用也是非常的方便，下面主要是一些常用的操作，更多详细的可以看其官方文档。","text":"在 MongoDB 中，聚合(aggregate)主要可以用于多个表之间的联合查询，并且可以进行求和、求平均值、最大与最小值等，在项目中使用也是非常的方便，下面主要是一些常用的操作，更多详细的可以看其官方文档。 使用场景日常开发中经常这些场景，比如文章都有类别字段，而一个类别可以对应多个文章，我们如果需要统计每个类别下的所有文章便可以通过aggregate进行查询，或者我们需要统计每个时间段发布的文章做个归档，也可以使用其来完成。 Definition常规的定义为：db.collection.aggregate(pipeline, options)主要接收两个参数，其中 pipeline 表示数据联立等操作，而 options 则为数据库的配置，这里就不多说该属性了。而 pipeline 常用的属性有： $project：用于指定返回的字段，字段可以是文档中的，也可以添加新的字段，或者排除某个字段。 $match：用于过滤文档，可以只返回服务我们条件的。 $limit：用于限制最后查询出的数据，可以配合下面的进行数据分页。 $skip：用于跳过指定条数的数据，可以用于实现分页。 $unwind：拆分数据，将一条数据拆分为多条。 $group：对文档中的数据进行分组，可用于分组或者统计。 $sort：根据某些字段进行数据的排序。 $geoNear：距指定点最近到最远的顺序输出文档。 $lookup：用于将数据进行汇总。 $lookup(数据填充)当一个文章类型对应多个文章，而每个文章仅仅对应一个类型，大致为(一对多)，我们要再文章集合中填充类型的信息，便需要该查询方式了。其基本格式为： 123456789&#123; $lookup: &#123; from: &lt;collection to join&gt;, localField: &lt;field from the input documents&gt;, foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;, as: &lt;output array field&gt; &#125;&#125; 例如我们有下面的 post 集合数据： 1234db.post.insert([ &#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;React&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 2 &#125;, &#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;mongodb&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 8 &#125;]) 同样还需要一个 type 集合： 1234db.post.insert([ &#123; &quot;_id&quot; : 2, &quot;name&quot; : &quot;web&#125;, &#123; &quot;_id&quot; : 8, &quot;name&quot; : &quot;数据库&quot; &#125;]) 我们如果需要将指定的 type 信息填充到 post 中便可以这样写： 1234567891011db.post.aggregate([ &#123; $lookup: &#123; from: &quot;type&quot;, localField: &quot;type&quot;, foreignField: &quot;_id&quot;, as: &quot;typeInfo&quot; &#125; &#125;]) 这样便通过$lookup完成了字段填充，from 表示需要联接的集合，localField 表示需要和集合进行联立的字段，foreignField 表示集合中用于和 localField 对应的字段，as 表示别名。其结果为： 12345678910111213141516171819[ &#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;React&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 2, &quot;typeInfo&quot;: [ &#123; &quot;_id&quot; : 2, &quot;name&quot; : &quot;web&quot;&#125; ] &#125;, &#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;mongodb&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 8, &quot;typeInfo&quot;: [ &#123; &quot;_id&quot; : 8, &quot;name&quot; : &quot;数据库&quot; &#125; ] &#125;] 当然我们不可能只遇到一对多，有时甚至需要多对多进行填充，这么我们可以先借助$unwind展开数组，然后再填充数据。 $group(分组)当文章有添加日期，我们需要根据添加日期的年份对文章进行分组，这样便可以统计每年新增的文章。默认的格式为： 12345678&#123; $group: &#123; _id: &lt;expression&gt;, // Group By Expression &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;, ... &#125; &#125; 需要先创建一个 post 集合： 1234db.post.insert([ &#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;React&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 2, createdAt: &quot;2021-03-03 03-08:50&quot;&#125;, &#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;mongodb&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 8, createdAt: &quot;2020-12-03 09-05:40&quot; &#125;]) 我们可以很轻松的对数据分组，分组之前可以先通过$project筛选出需要的字段，$sort:对选中的数据排序整理数据： 123456789101112131415161718192021222324db.post.aggregate([ &#123; $project: &#123; _id: 1, title: 1, createdAt: 1, &#125; &#125;, &#123; $sort: &#123; createdAt: -1 &#125; &#125;, &#123; $group: &#123; _id: &#123; $dateToString: &#123; format: &quot;%Y&quot;, date: &quot;$createdAt&quot; &#125; &#125;, posts: &#123; $push: &quot;$$ROOT&quot; &#125; &#125;, &#125;, &#123; $sort: &#123; _id: -1 &#125; &#125;]) $group中 _id 表示用于分组的字段，其内部的$dateToString表示格式化数据，因为我们需要按照年份进行分组，所以要提取出日期中的年份。posts 为数据名称$push表示对每个分组添加进数据，$$ROOT表示分组出数据的所有字段(可以和 $project 结合使用)。 最后返回数据格式如下： 12345678910111213&#123; &#123; &quot;_id&quot; &quot;2021&quot; &#x27;posts&#x27;: [ &#123;&quot;_id&quot; : 1, &quot;title&quot; : &quot;React&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 2, createdAt: &quot;2021-03-03 03-08:50&quot;&#125; ] &#125;, &#123; &quot;_id&quot; &quot;2020&quot; &#x27;posts&#x27;: [ &#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;mongodb&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 8, createdAt: &quot;2020-12-03 09-05:40&quot; &#125; ] &#125;&#125; $unwind(数组统计)可以用于展开数组的字段，例如我们需要统计数组中每个字段出现的次数。需要先创建一个 post 集合： 123456789101112131415db.post.insert([ &#123; &quot;_id&quot; : 1, &quot;title&quot; : &quot;React&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 2, tags: [&quot;web&quot;] &#125;, &#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;mongodb&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 8, tags: [&quot;web&quot;, &quot;数据库&quot;] &#125;]) 我们需要统计数组中每个 tag 出现的次数，那么我们可以这样写： 1234567891011121314db.post.aggregate([&#123; $project: &#123; tags: 1 &#125;&#125;, &#123; $unwind: &quot;$tags&quot;&#125;, &#123; $group: &#123; _id: &quot;$tags&quot;, sum: &#123; $sum: 1 &#125; &#125;&#125;]) 这样先通过$project筛选出需要的字段，然后通过$unwind展开指定字段，最后使用$group进行累加的操作。最后计算的结果为： 1234[ &#123;&quot;_id&quot;: &quot;web&quot;, &quot;sum&quot;: 2&#125;, &#123;&quot;_id&quot;: &quot;数据库&quot;, &quot;sum&quot;: 1&#125;]","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.bipch.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.bipch.cn/tags/MongoDB/"}]},{"title":"XSS","slug":"漏洞攻击/XSS","date":"2020-12-10T02:35:40.000Z","updated":"2021-03-02T05:02:03.164Z","comments":true,"path":"XSS/","link":"","permalink":"https://www.bipch.cn/XSS/","excerpt":"XSS 是 跨域脚本攻击 的简称，表示有人不怀好心在 Web 界面中插入恶意的 Script 代码，用户浏览界面的时候，恶意嵌入的 Web 里面的恶意 Script 就会被执行，从而达到恶意攻击用户的目的。","text":"XSS 是 跨域脚本攻击 的简称，表示有人不怀好心在 Web 界面中插入恶意的 Script 代码，用户浏览界面的时候，恶意嵌入的 Web 里面的恶意 Script 就会被执行，从而达到恶意攻击用户的目的。 XSS攻击方式恶意插入 JavaScript 代码，主要在一些简单的留言板、富文本展示等界面，如果有用户在代码中恶意添加下面一行代码： 1&lt;script&gt;alert(“hey!you are attacked”)&lt;/script&gt; 那么后面解析到这一句话的时候，Script 代码便会被执行到，界面便会出现弹框，这便是简单的 XSS 攻击方式。 原理其原理就是在我们渲染 html 代码时，传入可执行的 JavaScript 代码，例如通过数据库保存为可执行代码，或者路径传参为可执行代码。例如我们可以在一些文本框中输入下面内容：这样的一段代码一旦保存到数据库中，这个 JavaScript 代码便会立即执行。也就是界面会出现下面的情况：这便是 XSS 攻击的简单原理，简单来说便是将可执行的恶意 JavaScript 代码插入到界面中，使其被执行，并且它不只可以引入一小段 JS 代码，甚至我们可以直接引入一段可执行的 JS 的脚本： 1&lt;script src=&quot;*******&quot;&gt;&lt;/script&gt; 这种情况下脚本中代码甚至都会去执行，而在脚本中我们可以随意执行，并且可以获取到项目的私密信息，可以说对项目的危害还是非常大的。 XSS过滤既然 XSS漏洞 危害那么大，那么 XSS漏洞 很好利用吗？肯定不是的，因为我们有许多的方式可以过滤掉 XSS漏洞 的攻击。 过滤不合法信息我们可以将输入或者传入的内容中不合法信息都进行过滤，从而保证项目中数据的安全性。比如移除用户输入的 DOM 属性，例如过滤掉 onclick、onerror、onload 等相关的 DOM 事件，并且移除一些用户定义的节点，例如过滤掉 &lt;style&gt;、&lt;script&gt;、&lt;iframe&gt; 等节点。 注意：不是所有的 JavaScript 都要在 &lt;script&gt; 中才能执行，放在 &lt;img onerror=”alert(0)” src=”wwww” /&gt; 也是可以正常执行的，所以一些 DOM 事件也有必要进行过滤。 对特殊字符串进行编码我们不仅需要对于输入或者传入的数据进行过滤，在前端渲染或后台保存的时候，我们还需要对字符串进行 HTML Entity 的编码处理，因为有时为了攻击网站，还可以使用一些转移的字符如：&quot;&lt;&quot;可以替换为&amp;lt;、&quot;&gt;&quot;可以替换为&amp;gt;等字符转码可以绕过一些过滤。 并且能绕过匹配的不仅有特殊字符串，如果项目中判断不完全甚至可以用大小写绕过，例如我们这样写：&lt;scRIpt&gt;********&lt;scRIpt/&gt; 是能正常运行的，因为 JavaScript 是不区分大小写的。 httpOnly不将信息存储到 web Storage，而存储到 cookie 中，并且为 cookie 设置为无法被读写的，为其设置上httpOnly，这样之后使用 JS 便不能读写 cookie 数据。 限制长度因为需要添加一些可执行的 JS 代码，会是很长的一段代码，所以我们可以限制一些代码的长度，避免出现过长的代码，也可以进行简单的长度限制。 XSS绕开过滤道高一尺魔高一丈，项目中有很多避免 XSS 漏洞的方式，但 XSS 的攻击方式也是多种多样。 大小写绕过上面已经介绍过，因为 JavaScript 是一种弱文本语言，并其不区分大小写，所以我们可以利用这点进行攻击，例如添加下面代码： 1&lt;scrIPt&gt;alert(&quot;hello world&quot;)&lt;/scrIPt&gt; 如果项目判断不谨慎，很容易被该方式偷鸡。 利用过滤语句进行攻击一种技巧，因为大部分项目都对 &lt;script&gt; 标签进行了过滤，那么我们便可以利用这一点对齐进行攻击。例如这样做： 1&lt;scRi&lt;script&gt;pt&gt;alert(&quot;hello world&quot;)&lt;/scRi&lt;/script&gt;pt&gt; 虽然这样代码看起来什么也不是，但是经过其过滤掉 &lt;script&gt; 标签后，会出现下面代码： 1&lt;scRipt&gt;alert(&quot;hello world&quot;)&lt;/scRipt&gt; 正好利用其过滤形成一条可执行语句，也是一种小技巧。 并不是只有 script 标签才能插入可执行代码我们并不是只有插入 &lt;script&gt; 才能执行 JS 的代码，我们可以使用 DOM标签 绑定事件，事件中可执行 JS 代码。例如我们这样写： 1&lt;img src=&#x27;w.123&#x27; onerror=&#x27;alert(&quot;hey!&quot;)&#x27; /&gt; 如果输入大意，也是可能对其项目造成危害的。 使用转义字符因为项目都是对指定字符串进行匹配，但是 JS 中有一些特别的转义字符，大部分都是通过 “&quot; 字符进行转义，而攻击者可以使用转义输入，但是转义之后便是可执行的代码，便能达到攻击项目的目的。例如这样写： 1&lt;script&gt;eval(\\u0061\\u006c\\u0065\\u0072\\u0074(1))&lt;/script&gt; 这样转移之后便是： 1&lt;script&gt;alert(1)&lt;/script&gt; 这样也可以绕过一些字符的过滤。 XSS攻击分类实际项目中的漏洞是不会这么直观的，我们需要不断的换各种方式去尝试，甚至可以使用多种方式合并起来绕过项目的过滤，以达到我们的目的，而攻击的方式更是多种多样，并且XSS 的攻击大致上可以分为两类： 一类是反射型XSS，又称为 非持久型XSS。 一类是存储型XSS，也称之为 持久型XSS。 反射型XSS反射型XSS 一般表示从 URL 中传入恶意攻击的代码，而界面不错任何处理便渲染到项目中。这也就是说攻击相对于访问者是 一次性 的，也就是通过 URL 将恶意代码传递到界面上，而项目不对数据进行任何处理，将脚本 “反射” 到浏览器进行渲染，此时恶意脚本便执行了。也就是说如果此种形式进行 XSS攻击，只能访问特定链接才能实现恶意攻击。 储存型XSS储存型XSS 与上面最大的不同是，它是通过将恶意代码保存到数据库中，界面读取到数据库中的恶意代码，直接渲染上面也会造成 XSS攻击。例如我们在数据库中保存了一行恶意代码，然后指定用户访问时，后台将恶意代码读取出并返回到前端浏览器执行。这就意味着该用户登陆的所有地方都会执行这段恶意代码，因此存储型XSS危害更大。只需要登陆指定用户到指定 URL 便可进行攻击，不需要访问特定的 URL。","categories":[{"name":"漏洞攻击","slug":"漏洞攻击","permalink":"https://www.bipch.cn/categories/%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"}],"tags":[{"name":"跨域脚本攻击","slug":"跨域脚本攻击","permalink":"https://www.bipch.cn/tags/%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"}]},{"title":"垃圾回收机制","slug":"web/JavaScript/垃圾回收机制","date":"2020-11-20T04:20:36.000Z","updated":"2021-03-07T07:58:16.525Z","comments":true,"path":"javascript-garbage-collection/","link":"","permalink":"https://www.bipch.cn/javascript-garbage-collection/","excerpt":"在 JavaScript 中所有的内存管理是自动执行的，并且都是不可见的。我们创建的基本类型、对象、函数等，这些都是需要分配内存的，但是由于其是不可见的，所以我们要明白怎么进行空间的分配、不用的时候，会发生什么呢？JS 引擎如何清理它呢？","text":"在 JavaScript 中所有的内存管理是自动执行的，并且都是不可见的。我们创建的基本类型、对象、函数等，这些都是需要分配内存的，但是由于其是不可见的，所以我们要明白怎么进行空间的分配、不用的时候，会发生什么呢？JS 引擎如何清理它呢？ 可达性JavaScript 中内存管理的重要概念便是可达性，其主要负责我们项目能够访问到的值，都能够保存到内存中。其主要有下面几个要点： 有一组基本的固有可达值，由于显而易见的原因无法删除，这些值称为根。 例如： 本地函数的局部变量和参数。 当前嵌套调用链上的其它函数的变量和参数。 全局变量。 还有一些其它的，内部的。 如果引用可以从根访问任何其它值，则认为该值是可以访问的。 例如：在代码中定义一个对象，并且在别的地方对该对象进行引用，则该对象视为具有可达性，它引用的值也是可以访问的，而 JS 引擎中有一个后台进程称为垃圾回收器，它监视所有代码中的对象，并删除那些不具有可达性的对象。案例虽然叙述起来可能很绕嘴，但是其含义还是很容易理解的，例如下面代码：123let user = &#123; name: &#x27;jack&#x27;&#125;; 代码定义了一个对象&#123;name: &#39;jack&#39;&#125;并定义 user 指针指向该对象，此时对象&#123;name: &#39;jack&#39;&#125;被访问不会被清除，但是我们添加下面代码：1234let user = &#123; name: &#x27;jack&#x27;&#125;;+ user = null; 这样对象&#123;name: &#39;jack&#39;&#125;就被覆盖掉了，其不具备可达性，所以此时垃圾回收器便会将其视为垃圾进行回收，释放内存。垃圾回收JavaScript 的垃圾回收机制有很多种，下面简单列举几种：标记-清除一种很常见的垃圾回收算法，它主要定期执行下面的步骤： 垃圾回收器获取根并 ”标记“ 它们。 然后它访问并 “标记” 所有来自它们的引用。 然后它访问标记对象的引用。所有被访问对象都会被记住，以便以后不再访问同一对象两次。 以此类推，直到引用都标记完成(从根节点开始访问)。 除了标记对象外，所有对象都被删除。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"}]},{"title":"执行机制","slug":"web/JavaScript/执行机制","date":"2020-11-07T06:20:36.000Z","updated":"2021-03-07T11:39:40.967Z","comments":true,"path":"javascript-event-loop/","link":"","permalink":"https://www.bipch.cn/javascript-event-loop/","excerpt":"在 JavaScript 的代码中都是按照一定的顺序去执行的，其每一段的代码执行，都有一定的先后顺序，这种代码的执行顺序一般称之为其执行机制。","text":"在 JavaScript 的代码中都是按照一定的顺序去执行的，其每一段的代码执行，都有一定的先后顺序，这种代码的执行顺序一般称之为其执行机制。 执行机制JavaScript 的执行机制主要在意下面几点： JavaScript是一门单线程语言。 Event Loop(事件循环)是JS的执行机制。 为什么 JS 代码是单线程？其实也很好的理解，因为JS是用来在浏览器控制一些DOM的操作的一门脚本语言，如果JS是多线程，那么两个线程同时对一个DOM元素进行相互冲突的操作，那么浏览器将无法去执行。所以JS只能是单线程的。既然它只能只能是单线程，但是 JS 需要处理许多的异步请求，例如：请求网络接口、读取一些文件，延迟执行等操作，都需要使用异步去处理，否则一个请求解析时间过长那么代码就会阻塞。 单线程 实现 “多线程”在 JS 中所有的异步以及多线程都可以理解为一种”假象“，例如H5新增的 WebWorker 来说，子线程有诸多的限制，不能控制DOM、不能修改全局对象等，通常只能处理一些数据逻辑。这些限制并没有违背我们之前的观点，所以说是”假象“。JS异步执行机制就是 事件循环(Event Loop)，理解他就理解了异步执行机制。 Event LoopJS 代码在执行过程中会先执行同步操作异步操作排在事件队列里，这样的理解并没有什么错误，但是如果在深入理解会发现还有一些其它的概念，比如 event table 和 event queue，具体可以下面的流程： 先判断任务是同步任务还是异步，同步进入主线程运行，异步进入 event table。 异步在 event table 中注册事件，满足触发条件后(触发条件可能是延迟或网络请求成功)，后被推入 event queue。 同步任务进入主线程一直执行，一直到主线程空闲时，才会到 event queue 查看是否有可执行的异常任务，如果有就推入主线程。 JS主线程执行过程中会不断的检查主线程执行栈是否为空，一旦为空，就回去 event queue 检查是否有等待被调用的函数，直至执行完毕。绘制流程图如下所示： Ajax通过上面的描述，可能还不够直观，我们用 Ajax 异步操作，执行顺序如下： 12345678$.ajax(&#123; url: &#x27;*****&#x27;, data: [], success: () =&gt; &#123; consoel.log(&#x27;ajax成功&#x27;); &#125;&#125;)console.log(&#x27;代码执行结束&#x27;); 那么它的执行顺序为： ajax 进入 event table，并注册成功的回调函数 success。 主线执行完成，执行console.log(&#39;代码执行结束&#39;)代码。 ajax 事件完成，回调函数进入 event queue。 主线程从 event queue 读取回调函数 success 并执行。 setTimeout项目中经常出现 setTimeout或者setinterval并不是特别准时，例如下面代码： 123456setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout延迟&#x27;);&#125;, 0);// 同步占用大量的事件sleep(999999999); 如果我们用上面流程解释该代码会很简单，虽然其只是 0s，但是其还是异步，只是将其挂起并不会去执行，只有同步sleep执行完成，才会真正的去执行setTimeout代码，所以说不管是setTimeout还是setinterval都不会那么准时，因为 JS 会需要处理所有同步代码才会去执行异步。 微任务和宏任务代码中除了同步和异步任务，还可以对异步任务再细一步的划分，可以再划分为： 宏任务：包含setTimeout、setIntval异步方式。 微任务：包含Promsie异步方式。 执行顺序既然异步可以进一步细分，那细分之后，顺序是怎么样的呢？其实前面没什么变化，只是对异步进行了区分：不同异步进入对应的 event queue，比如 setTimeout 和 setIntval 会进入宏任务的 event queue，而 Promsie 进入微任务的 event queue，虽然都是异步任务，但是 宏任务的优先级高于微任务。 Promise的事件循环Promise 在进行初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完成后，继续向下执行代码，在此之前，then 的回调不会执行，同步代码执行完毕后，才会在事件循环中检查是否有可用的 Promise 回调，如果有则执行，否则继续下一个事件循环。可以总结为下面流程： 宏任务和微任务都是队列，主线程代码执行完毕后，会执行宏任务中的同步代码。 进入第一轮事件循环的时候，会 把全部的 js 脚本当成宏任务运行。 如果执行中遇到setTimeout之类的宏任务，那么会将其推入 [宏任务队列] 中，下一轮宏任务执行时调用。 如果遇到 Promise.then() 之类的微观任务，就会推入到 [当前宏任务的微观任务] 中，本轮宏观任务结束后，依次执行所有微观任务。 如果第一轮事件循环中执行完全部的同步以及微观任务队列任务，那么这一轮事件循环便结束了，开始进行下一轮。 依次循环往复。 结合上面定义，我们看下面代码： 1234567891011121314151617181920212223242526const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123; console.log(3); let p = new Promise((resolve, reject) =&gt; &#123; console.log(7); // 宏任务2 setTimeout(() =&gt; &#123; console.log(5); resolve(6); &#125;, 0); resolve(1); &#125;); resolve(2); p.then((arg) =&gt; &#123; // 微任务1 console.log(arg); &#125;);&#125;));// 宏任务1first().then((arg) =&gt; &#123; // 微任务2 console.log(arg);&#125;);console.log(4); 结合定义一步步上面代码： 第一轮将所有代码作为宏观任务，进入主线程。 首先遇到 new Promise 名称为 first，执行里面同步函数。 遇到 new Promise 名称为 p，执行同步函数，遇到里面含有的 setTimeout 将其回调注册后分发给第二轮宏观任务 event queue，并将 p 的 then 函数发布到当前任务的微任务event queue。 对 first 注册 then 回调，并将回调添加到微任务 event queue。 宏任务执行完毕，开始执行微任务…。 得出结果为：3、7、4、1、2、5。 结合上面叙述，我们得出下面的结论：宏任务是一个栈，按照先入先执行的原理，微任务也是按照先入先执行的原理。但是每个宏任务对应都有一个微任务栈，宏任务执行过程中会先执行同步代码在执行微任务栈。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"}]},{"title":"拷贝","slug":"web/JavaScript/拷贝","date":"2020-11-02T03:48:10.000Z","updated":"2021-03-02T04:19:45.782Z","comments":true,"path":"javascript-copy/","link":"","permalink":"https://www.bipch.cn/javascript-copy/","excerpt":"了解拷贝之前，必须先搞清楚 =(赋值) 和 拷贝 的区别，它们是不会相同的。赋值 只能算是”引用”，其引用的任然是同一对象，不能算是真正的拷贝，因为拷贝是重新创建了新的对象，所以赋值和拷贝本质还是有区别的。","text":"了解拷贝之前，必须先搞清楚 =(赋值) 和 拷贝 的区别，它们是不会相同的。赋值 只能算是”引用”，其引用的任然是同一对象，不能算是真正的拷贝，因为拷贝是重新创建了新的对象，所以赋值和拷贝本质还是有区别的。 赋值与拷贝JS 中的拷贝可以分为浅拷贝和深拷贝，它们的主要区别如下所示： 深拷贝：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 会 影响原数组。 浅拷贝：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 不会 影响原数组。 所以结合上面的叙述，我们可以绘制出下面的表格： 名称 和原数据是否指向同一对象 第一层数据为基本数据类型 原数据中包含子对象 = 是 改变会使原数据一同改变 改变会使原数据一同改变 浅拷贝 否 改变 不 会使原数据一同改变 改变会使原数据一同改变 深拷贝 否 改变 不 会使原数据一同改变 改变 不会 会使原数据一同改变 浅拷贝我们要区分 浅拷贝 和 赋值 的区别，我们通过下面的方式进行比较： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var obj1 = &#123; &#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;: &#x27;18&#x27;, &#x27;language&#x27;: [ 1, [2, 3], [4, 5] ],&#125;;var obj2 = obj1;function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125;var obj3 = shallowCopy(obj1);obj2.name = &quot;lisi&quot;;obj3.age = &quot;20&quot;;obj2.language[1] = [&quot;二&quot;, &quot;三&quot;];obj3.language[2] = [&quot;四&quot;, &quot;五&quot;];console.log(obj1);//obj1 = &#123;// &#x27;name&#x27; : &#x27;lisi&#x27;,// &#x27;age&#x27; : &#x27;18&#x27;,// &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//&#125;;console.log(obj2);//obj2 = &#123;// &#x27;name&#x27; : &#x27;lisi&#x27;,// &#x27;age&#x27; : &#x27;18&#x27;,// &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//&#125;;console.log(obj3);//obj3 = &#123;// &#x27;name&#x27; : &#x27;zhangsan&#x27;,// &#x27;age&#x27; : &#x27;20&#x27;,// &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],//&#125;; 先定义一个原始对象 obj1，然后使用 赋值 得到第二个对象 obj2，然后通过 浅拷贝 对象 obj1 得到 obj3 对象。也就是说： obj1：原始数据。 obj2：赋值操作得到。 obj3：浅拷贝得到。 最后得出：我们在改变 obj2 和 obj3 的 name 属性，最后可以看出改变 obj2 会使 obj1 进行修改，而 obj3 不会修改。这就说明了 赋值只是复用引用地址，但引用还是同一对象，而 拷贝则是新创建了一个对象。而我们修改 obj2 和 obj3 的 language 属性时，最后是都会发生改变的，这是因为 浅拷贝 只是复制一层的对象属性，并不包括对象中的引用数据。所以修改引用类型的数据，原始数据也会进行修改。 从上面的实例很容易就能区分出 复制 和 浅拷贝 的真正区别。我们千万不能将 复制 直接当成 浅拷贝 进行理解。 深拷贝因为前面讲了 浅拷贝 至于 深度拷贝 其实对对象的所有子对象都进行拷贝。那么怎么实现呢？其实我们递归调用 浅拷贝 对象，把所有属于对象的属性类型都遍历赋给另一个对象即可。比如下面的代码： 123456789101112function deepClone(obj, newObj = &#123;&#125;) &#123; for (key in obj) &#123; if (typeof obj[key] === &#x27;object&#x27;) &#123; newObj[key] = (obj[key].constructor === Array) ? [] : &#123;&#125;; deepClone(obj[key], newObj[key]); &#125; else &#123; newObj[key] = obj[key] &#125; &#125; return newObj;&#125;; 可以看出和 浅拷贝 非常的相似，只是遍历的时候判断如果是 对象类型 的数据，就递归继续拷贝，这样就避免 浅拷贝 子对象的问题。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"}]},{"title":"MongoDB安装和常用方法","slug":"数据库/MongoDB/MongoDB安装和常用方法","date":"2020-10-20T06:20:30.000Z","updated":"2021-03-08T19:53:43.149Z","comments":true,"path":"linux-software/","link":"","permalink":"https://www.bipch.cn/linux-software/","excerpt":"一种非关系型的数据库，由于其高性能、易部署、易使用，并且可以通过 Mongoose 和 Node.js 完美结合起来使用，可以很方便的为 web 应用提供一种高效的存储方案，详情可以去官网查看。","text":"一种非关系型的数据库，由于其高性能、易部署、易使用，并且可以通过 Mongoose 和 Node.js 完美结合起来使用，可以很方便的为 web 应用提供一种高效的存储方案，详情可以去官网查看。 下载我的服务器操作系统为 centos，请根据操作系统进行安装。首先我们要去复制压缩包的下载的链接： 按照自己的系统拷贝相应的链接，这里贴出我的链接： 1https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-4.4.3.tgz 拷贝完成后需要放置到服务器，一般我会放置在 /usr/local/ 路径下： 12cd /usr/localwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-amazon-4.4.3.tgz 等待文件下载完成后，我们需要对其解压： 123tar -zxvf mongodb-linux-x86_64-amazon-4.4.3.tgzmv mongodb-linux-x86_64-amazon-4.4.3 mongodb-linuxrm mongodb-linux-x86_64-amazon-4.4.3.tgz 这样通过tar命令进行解压，通过mv命令进行重命名，然后通过rm将压缩包删除，因为解压之后，压缩包已经失去了价值。这样基本项目已经下载完成，我们还需要手动创建日志文件目录、数据库文件目录： 12cd mongodb-linuxmkdir db logs mongodb-linux 根目录下新建了两个文件夹db、logs分别存放数据库和日志。这样配置基本完成，我们只需告诉 Mongodb 文件位置即可，在bin目录下新建文件mongodb.conf文件： 12cd binvi mongodb.conf 打开 vim 编辑文件，输入下面内容： 1234dbpath=/usr/local/mongodb-linux/dblogpath=/usr/local/mongodb-linux/logs/mongodb.logport=27017fork=true 一些基础配置： dbpath：数据库地址。 logpath：日志地址。 port：端口。 fork：前台还是后台运行，true 表示后台运行，否则表示前台。 完成后，通过:wt命令退出 vim，这样基本配置完成，我们在 bin 目录下运行： 1./mongod -f mongodb.conf 然后执行./mongo即可链接上 Mongodb，然后可以通过下面方式查看版本号： 1db.version() 当然如果嫌每次执行都需进入bin目录，我们可以为其配置环境变量，修改/etc/profile配置： 1vi /etc/profile 然后只需在最后添加下面两行代码： 1234# 安装路径export MONGODB_HOME=/usr/local/mongodb-linux# bin 目录export PATH=$PATH:$MONGODB_HOME/bin 完成后，使用source /etc/profile命令重启即可。 数据库常用命令上面已经将 Monsedb 安装完成，下面总结下其常用的命令方便以后的使用。 数据库列表1234&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GB 创建数据库12&gt; use react_blogswitched to db react_blog use命令创建时，如果数据库不存在会进行创建后进入，如果已经存在回切换到指定数据库，所以切换到执行数据库也是该命令。 新增的数据库使用 show dbs 是无法查询出的，我们只有新增数据之后才可以查询出。 当前数据库12&gt; dbreact_blog 删除数据库123456789101112131415&gt; db.dropDatabase() # 删除数据库&#123; &quot;ok&quot; : 1 &#125;&gt; db # 查询当前数据库react_blog&gt; show dbs # 查询数据库列表admin 0.000GBconfig 0.000GBlocal 0.000GB&gt; db.createCollection(&quot;user&quot;) # 相当于创建一个数据库&#123; &quot;ok&quot; : 1 &#125;&gt; show dbs # 在查询数据库列表admin 0.000GBconfig 0.000GBlocal 0.000GBreact_blog 0.000GB 可以看出虽然执行dropDatabase删除了该数据库，但是其当前数据库并没有改变，尽管其已经被删除，使用dbs查询发现已经从列表中删除，但是如果我们此时新建 Collection(可以立即为数据库中的数据表)，该操作是执行成功的，并且数据库又能查询出来。所以可以很简单的得出结论：dropDatabase 只是清空当前数据库的所有 Collection。 查询所有集合12&gt; show collectionsuser collection 常用命令集合就相当于 Mysql 数据库中的数据表。 创建 collection12&gt; db.createCollection(&quot;user&quot;)&#123; &quot;ok&quot; : 1 &#125; 该操作相当于在 Mysql 中的数据库新增一个数据表。 当一个数据库中包含一个集合时(哪怕只是一个空集合)，便能够使用dbs查询出来了。 删除 collection123&gt; db.user.drop()true&gt; show collections 重命名 collection123456&gt; show collectionsuser&gt; db.user.renameCollection(&quot;users&quot;)&#123; &quot;ok&quot; : 1 &#125;&gt; show collectionsusers 关闭 MongoDBMongoDB 启动成功后需要以正确的方式进行关闭：可以使用Crtl + C命令直接关闭，注意此时只是退出了 MongoDB，如果退出后在连接是可以正常连接的： 123&gt; ^Cbye&gt; .&#x2F;mongo 这样做是完全没有问题的，如果要彻底关闭 MongoDB，排除强行关闭端口的情况下，还能使用shutdownServer，注意：使用该方法时必须在 admin 下，不然会给出下面的提示： 1shutdown command only works with the admin database; try &#x27;use admin&#x27; 这样去关闭： 123456&gt; dbadmin&gt; db.shutdownServer()server should be down...&gt; exitbye 因为shutdownServer不会关闭当前的服务，所以我们还要加上exit来退出。这样即使后面再使用./mongo也是无法连接的。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.bipch.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.bipch.cn/tags/MongoDB/"}]},{"title":"防抖节流","slug":"web/JavaScript/防抖节流","date":"2020-10-20T05:48:10.000Z","updated":"2021-03-07T07:29:38.796Z","comments":true,"path":"antiShake-throttle/","link":"","permalink":"https://www.bipch.cn/antiShake-throttle/","excerpt":"防抖和节流在web开发中属于性能优化方面的知识，实际使用频率还是很高的，比如我们有一个高频率触发事件，每次触发都会执行一次事件绑定的函数。例如我们每次移动滚动条都要触发一个函数，那么我们每稍微移动下滚动条，便会调用很多次函数，如果函数逻辑复杂很有可能出现响应速度跟不上触发频率，出现延迟，假死、卡顿或崩溃的现象。而我们可以通过下面的几种方式优化代码。","text":"防抖和节流在web开发中属于性能优化方面的知识，实际使用频率还是很高的，比如我们有一个高频率触发事件，每次触发都会执行一次事件绑定的函数。例如我们每次移动滚动条都要触发一个函数，那么我们每稍微移动下滚动条，便会调用很多次函数，如果函数逻辑复杂很有可能出现响应速度跟不上触发频率，出现延迟，假死、卡顿或崩溃的现象。而我们可以通过下面的几种方式优化代码。 防抖实现方式：每次触发事件时设置一个延迟调用的方法，并且取消之前的延迟调用方法。这样如果短时间触发大量的同一事件，函数代码只会执行一次。下面用代码实现上面逻辑，因为要一段时间之后执行某些逻辑，所以需要setTineout函数实现，代码如下： 1234567891011121314151617181920212223/*** 防抖函数* fn: 需要防抖函数* delay: 防抖时间*/function debounce(fn, delay) &#123; // 计时器对象 var timeout = null; return function (e) &#123; // 每次执行都把 setTimeout 清除 clearTimeout(timeout); // 重写创建 setTimeout，主要重置 setTimeout timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, delay); &#125;;&#125;// 防抖函数function handle() &#123;console.log(&#x27;防抖：&#x27;, Math.random());&#125; // 开始防抖，500 防抖时间 window.addEventListener(&#x27;scroll&#x27;, debounce(handle, 500)); 简单柯里化函数滚动条滚动之后等待 500ms 之后才能触发 handle 函数，连续执行是不会触发 handle 函数。虽然实现了我们需求，它的缺点也非常的明显: 如果这个事件不断地触发，其会不断取消前面的函数，重新执行，这样函数是无法进行执行的。 节流实现方式：每次触发事件，如果当前有等待执行的延时函数，则直接 return。使用下面代码来实现： 1234567891011121314151617function throttle(fn, delay)&#123; // 标记，是否可以成功向下执行 let canRun = true; return function()&#123; // 是否可以继续向下 if(!canRun) return; // 设置结束，等待一段时间后，才能继续执行 canRun = false; // 此时的值为 false setTimeout(() =&gt; &#123; // 执行节流函数 fn.apply(this, arguments); // 执行之后，我们可以继续执行了 canRun = true; &#125;, delay); &#125;&#125; 这样封装即使事件一直执行，并不会第一时间进行触发函数，而是判断是否有函数执行，如果有则不会执行，执行前一个函数执行完成才继续触发下一个函数。 总结 防抖： 将多个操作合并为一次操作。原理就是一个计时器，在规定的 delay 时间后才能触发函数，但是如果在 delay 时间内再次触发，就会取消之前的计时器并重启设置。这样一来，只有zui’hou一次操作会被触发。 节流： 使一段时间后触发一次函数，原理是通过判断是否有延迟函数执行，若有延迟函数执行则结束该函数。 区别： 节流不管触发多频繁，都会保证在规定时间内一定会执行一次处理函数，而防抖只是在最后一次事件后才触发函数。如果在界面无限加载的情况下，我们需要用户滚动界面时，每隔一段时间发一次网络请求，而不是用户停下才去请求数据。这种需求就适合使用节流技术来实现。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"}]},{"title":"React-Render-Props","slug":"web/React/React-Render-Props","date":"2020-10-09T07:02:21.000Z","updated":"2021-03-07T11:44:39.054Z","comments":true,"path":"react-redux-props/","link":"","permalink":"https://www.bipch.cn/react-redux-props/","excerpt":"render props 的作用和 hoc 的作用基本相似，根据官网的介绍其主要 用于使用一个值为函数的 prop 在 React 组件之间的代码共享，这样说似乎难以理解我们可以这样说：其核心为通过函数将 class 组件的 state 作为 props 传递给函数组件。","text":"render props 的作用和 hoc 的作用基本相似，根据官网的介绍其主要 用于使用一个值为函数的 prop 在 React 组件之间的代码共享，这样说似乎难以理解我们可以这样说：其核心为通过函数将 class 组件的 state 作为 props 传递给函数组件。 为什么用 render props学习技术之前一定要先明白它解决了什么样的问题，其实 render props 和 高阶组件hoc 作用一样，都是为了方便提取功能相似但逻辑有些不同的组件，可以对多个逻辑相同组件进行逻辑的提取，增加代码的灵活性。 例子比如我们有这样一个需求：一个按钮有该权限时展示否则隐藏。这种需求开发过程中还是很常见的，如果我们用普通的代码来写，便会出现下面的代码： 12345678910111213141516171819import React from &#x27;react&#x27;;class App extends React.Component&#123; constructor(props) &#123; super(props); this.state = &#123;isLogin: true&#125; &#125; render()&#123; /**逻辑判断*/ return ( &lt;div className=&quot;App&quot;&gt; &#123; this.state.isLogin &amp;&amp; &lt;button&gt;按钮&lt;/button&gt; &#125; &lt;/div&gt; ); &#125;&#125;export default App; 这样即使能完成我们的需求，但是代码中存在大量的逻辑判断，代码也有很大的耦合性，并且代码非常不灵活会显得很笨重，比如需求改变为当没有权限我们要跳转界面，这样就大量组件代码又需要修改，扩展性很差。 改造这种代码显然不符合我们的心意，我们需要第一次对代码封装，修改后代码为： 12345678910111213141516171819202122import React from &#x27;react&#x27;;class DictionComponent extends React.Component&#123; constructor(props) &#123; super(props); this.state = &#123;isLogin: true&#125; &#125; render()&#123; /**逻辑判断*/ return this.state.isLogin?&lt;button&gt;按钮&lt;/button&gt;:&#x27;&#x27;; &#125;&#125;class App extends React.Component&#123; render()&#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;DictionComponent /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 将逻辑判断封装为一个组件，使用的时候，引入相应组件。这样虽然可以简单的封装了，但是依然不够灵活，例如需求改变为权限不足时显示一行提示文字，此时上述代码已经不满足需求，只能修改组件或在封装一个组件，这就显得代码不够灵活，这时我们便要通过 render props 进行封装。 render props我们添加一个逻辑判断组件 DictionProps ，它能够动态的决定什么是需要渲染的，并能改变最终改变渲染的结果： 12345678910111213141516171819202122import React from &#x27;react&#x27;;class DictionProps extends React.Component&#123; constructor(props) &#123; super(props); this.state = &#123;isLogin: true&#125; &#125; render()&#123; /**逻辑判断*/ return this.state.isLogin?this.props.success():this.props.error(); &#125;&#125;class App extends React.Component&#123; render()&#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;DictionProps success=&#123;() =&gt; &lt;button&gt;按钮&lt;/button&gt;&#125; error=&#123;() =&gt; &#x27;&#x27;&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 这样我们可以完全交由 DictionProps 决定到底需不需要渲染，渲染的最终结果等信息，而不是写死来决定最终内容，这样需要什么组件按需传入即可，这样代码会显得非常灵活。结合上面代码来说：render props 是一个用于判断最终渲染的内容的函数 prop。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://www.bipch.cn/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"}]},{"title":"闭包","slug":"web/JavaScript/闭包","date":"2020-10-09T02:48:10.000Z","updated":"2021-03-07T07:23:13.528Z","comments":true,"path":"closure/","link":"","permalink":"https://www.bipch.cn/closure/","excerpt":"闭包在项目中还是经常会被使用的，或许使用过但是并没有特别在意到，我们可以用一句话来形容闭包为：可以访问其它函数作用域中变量的函数。","text":"闭包在项目中还是经常会被使用的，或许使用过但是并没有特别在意到，我们可以用一句话来形容闭包为：可以访问其它函数作用域中变量的函数。 闭包本质闭包的本质源自两点，作用域和私有性： 作用域：就是我们定义变量的使用范围。内部函数可以访问函数外面的变量，代码执行的过程中通过作用域链，可以去访问外围的变量。 私有性：我们可以将函数当作一个变量进行赋值，利用函数内部的 return 返回内部属性，这就相当于返回了一个函数的通道，我们可以使用这个通道访问函数内部定义的变量。但是这样造成一个问题，便是由于里面定义的值会被引用，所以垃圾回收器不会回收这些值，它们会一直保存下去，而且无法直接访问，必须通过对应函数进行访问，这也就是私有性。 显然，闭包的形成很简单，在执行过程完毕后，一旦函数通过作用域链访问外部函数定义一些值，即形成闭包。实际上在 JavaScript 代码中闭包不要太常见。 作用域这个比较容易理解，作用域就是：我们定义的每个变量的使用范围。作用域又分为 全局作用域 和 局部作用域。两个使用范围不同，各有优缺点。 作用域链作用域链就是在函数内部可以访问外部变量的机制，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 执行环境每当程序的执行流进入到一个可执行的代码时，就进入到了一个执行环境中（EC），EC 定义变量和函数有权访问的数据。JS 中函数运行都会产生一个执行环境，并且 JS 引擎还会产生一个与当前 EC 相关联的变量对象(VO)，EC 中所有定义的变量和方法都包含在 VO 中。 JS引擎会以栈的方式来处理执行上下文，也就是我们通常所说的函数调用栈。栈底永远是全局上下文，栈顶则是当前正在执行的上下文。处于栈顶的执行上下文执行完毕后，会自动出栈。 比如下面的例子可以很好的反应 EC 的执行流程： 12345678function declare() &#123; var a = 1; function update() &#123; a = 2; &#125; update();&#125;declare(); 我们如果使用执行上下文的进栈出栈流程图如下： 可以看出代码总共经历下面几个步骤： 首先第一步就是全局上下文入栈。 全局上下文入栈后，遇到的第一个可执行代码就是 declare() 函数的调用，此函数一旦调用，就会创建自己的执行上下文，此时 declare EC 入栈。 在新开辟的 declare EC 执行上下文中，执行内部的可执行代码，直到遇到 update() 函数调用时，又会创建一个新的执行上下文，此时 update EC 入栈。 当 update EC 中的可执行代码执行完毕之后，发现不再有其他执行上下文生成的情况，此上下文会自动从栈中弹出。 update EC 执行上下文弹出后，会继续执行 declare EC 执行上下文中的可执行代码，直到顺利执行完毕，且没有遇到其他执行上下文，则自动从栈中弹出。最后执行栈中只剩下全局上下文，若浏览器不关闭，全局上下文会一直存在，直到浏览器窗口关闭，全局上下文才会最终出栈。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"}]},{"title":"React-HOC","slug":"web/React/React-HOC","date":"2020-09-29T09:58:01.000Z","updated":"2021-03-07T12:09:26.203Z","comments":true,"path":"react-hoc/","link":"","permalink":"https://www.bipch.cn/react-hoc/","excerpt":"HOC 是一种很好的设计模式，而不是针对某些技术的API，这种设计模式在很多 React 库中证明了其价值，并且通过它我们可以很好的复用 React 组件中代码逻辑。","text":"HOC 是一种很好的设计模式，而不是针对某些技术的API，这种设计模式在很多 React 库中证明了其价值，并且通过它我们可以很好的复用 React 组件中代码逻辑。 高阶组件是什么?高阶组件简称HOC，它和高阶函数非常的相似，简单可以概况为：它是接受了一个组件，返回一个新的组件的纯函数。我们也可以将它理解为一个类工厂，它被传入了一个组件，然后返回一个经过加工的新组件。 解决什么问题?React 在开始时并不是使用 HOC 解决逻辑复用的问题，而是靠 Mixin 解决，虽然他非常的强大。但是它还具有非常大的隐患，让我们看下 Mixin 造成的问题： 破坏组件封装性: 如果我们组件中引用 Mixin 方法会为我们组件带来不可见的属性(props)和状态(state)。并且每个 Mixin 也可能相互依赖，相互耦合，非常不利于维护。 命名冲突: 不同 Mixin 的属性方法和组件中的属性方法都可能相互覆盖相互冲突。 雪球效应: 例如我们一个组件使用了一个 Mixin，但是 Mixin 会被多个组件引用，也就是说可能存在一个需要使 Mixin 添加更多属性或方法的组件，这样一直新增便会增加维护成本。 综上所述 Mixin 具有很高的侵入性，这种代码都具有很高的隐患，所以为了解决上述问题，React 改用了 HOC。 如何去实现？高阶组件主要有两个实现的方式，分别为 属性代理(Props Proxy)、反向继承(Inversion inherit)。但是我们无论使用那种方法都可以操作 WrappedComponent。下面主要看下如何去实现HOC。 Props Proxy我们先使用一个最简单代码实现这个功能： 123456789101112import React from &#x27;react&#x27;;export function propsProxyHoc(WrappedComponent) &#123; return class proopProxy extends React.Component &#123; componentDidMount() &#123; console.log(&#x27;props proxy 模式 HOC&#x27;); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props &#125; user = &quot;props-prosy&quot; /&gt; &#125; &#125;&#125; 上述代码非常像柯里化的函数，这里主要是 HOC 接收了一个组件然后返回一个新的组件，并且新组件 render 也是返回了一个 WrappedComponent 的 React 元素。我们将传入的 props 收集出来，然后传入新的组件，这便是属性代理名称的由来。那么我们到底使用Props Proxy可以做些什么?下面开始分析： 操作 props我们可以修改、读取、删除、编辑传递给 WrappedComponent 组件的数据。但是我们需要小心它并没有为我们提供相关的命名空间，所以属性随时可能会发送覆盖。例如我们可以在给 WrappedComponent 传递一些数据： 123456789101112import React from &#x27;react&#x27;;export function propsProxyHoc(WrappedComponent) &#123; return class proopProxy extends React.Component &#123; componentDidMount() &#123; console.log(&#x27;props proxy 模式 HOC&#x27;); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props &#125; user = &quot;props-prosy&quot; /&gt; &#125; &#125;&#125; 这样我们就可以在 WrappedComponent 组件中使用 this.props.user 来获取传递的数据。 通过 Refs 访问组件实例使用属性代理还是可以很简单的获取 WrappedComponent 的实例引用(ref)，例如我们这样写: 123456789101112import React from &#x27;react&#x27;;export function propsProxyHoc(WrappedComponent) &#123; return class proopProxy extends React.Component &#123; componentDidMount() &#123; console.log(&#x27;props proxy 模式 HOC&#x27;); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props &#125; ref = &#123;ref =&gt; this.res = ref&#125; /&gt; &#125; &#125;&#125; 这样渲染完成后，我们便可以通过 proopProxy 很简单的获取到 WrappedComponent 组件的实例。 提取 state属性代理情况下，我们可以将 WrappedComponent 组件的状态提取到包裹组件里，有一个常见的例子就是可以实现不受控组件到受控组件的转换。 123456789101112131415161718192021222324252627282930313233// 典型的不受控组件class WrappedComponent extends React.Component&#123; render()&#123; return &lt;input name=&quot;name&quot; &#123;...this.props.name&#125; /&gt; &#125;&#125;// HOC 工厂export function propsProxyHoc(WrappedComponent) &#123; return class proopProxy extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: &#x27;&#x27; &#125; this.onNameChange = this.onNameChange.bind(this); &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange &#125; &#125; return &lt;WrappedComponent &#123;...this.props &#125; &#123;...newProps&#125; /&gt; &#125; &#125;&#125; 通过上面代码我们可以通过 HOC 将不受控组件转换为了受控组件。其实也是通过 props 进行传输。 添加元素包裹我们使用 HOC 时还可以对 WrappedComponent 封装一些其它的 DOM 元素，例如： 12345678910import React from &#x27;react&#x27;;export function propsProxyHoc(WrappedComponent) &#123; return class propsProxy extends React.Component &#123; render()&#123; return ( &lt;div&gt; &lt;WrappedComponent &#123;...this.props &#125; /&gt; &lt;/div&gt; ) &#125; &#125;&#125; Inversion inherit当然除了我们使用 属性代理 的方式来实现HOC，还可以使用另一项技术来实现。看下下面的代码： 1234567function iInheritHOC(WrappedComponent) &#123; return class iInherit extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125; 反向继承 指的就是 HOC 返回的新组件去继承 WrappedComponent，因为继承关系是反着进行的，所以我们将其称为 反向继承。它和属性代理不同的便是，它继承了 WrappedComponent，这就意味着它可以访问到state、props、组件生命周期、render 等方法。但是虽然它能够访问 WrappedComponent 的生命周期等，但是这些尽量不要去修改，我们因该尽量保持 WrappedComponent 的完整性。 那么我们可以使用它来做些什么呢？下面进行分析： 渲染劫持(Render Highjacking)之所以称之为渲染劫持是因为由完全由 HOC 控制 WrappedComponent 渲染输出，进而完成控制渲染的结果。例如我们可以根据参数判断渲染那部分组件，或者不进行渲染: 1234567891011function iInheritHOC(WrappedComponent) &#123; return class iInherit extends WrappedComponent &#123; render() &#123; if (this.props.isRender) &#123; return super.render(); &#125; else &#123; return null; &#125; &#125; &#125;&#125; 甚至我们可以组件返回 render 的内容。例如我们 WrappedComponent 组件内容是这样的： 12345678class WrappedComponent extends React.Component&#123; render()&#123; return( &lt;input value=&#123;&#x27;Hello World&#x27;&#125; /&gt; ) &#125;&#125;export default iInheritHOC(WrappedComponent) 我们在 HOC 中控制 WrappedComponent 中 render 的内容： 1234567891011121314function iInheritHOC(WrappedComponent) &#123; return class iInherit extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); let newProps = &#123;&#125;; if (elementsTree &amp;&amp; elementsTree.type === &#x27;input&#x27;) &#123; newProps = &#123;value: &#x27;may the force be with you&#x27;&#125;; &#125; const props = Object.assign(&#123;&#125;, elementsTree.props, newProps); const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children); return newElementsTree; &#125; &#125;&#125; 这样我们根据 WrappedComponent 克隆了一个新的组件，它的内容基本一样，但是我们将 value 的值修改为: may the force be with you。最后我们可以看下 elementsTree 与 newElementsTree 的区别： 在反向继承中，由于是继承我们可以修改 WrappedComponent 的 state、props、render、钩子函数等。但是他有一个非常重要的问题就是：React元素(Element) 决定了 React 界面到底渲染为什么，而 React 元素有两种类型：字符串 和 函数。字符串类型的 React元素 代表DOM节点。函数 类型代表 React组件。而函数类型的 React组件 最终会被解析为一个完全由 字符串类型React元素树。这就意味着反向继承不能保证完整的子组件树被解析，也就是说我们不能操作 WrappedComponent 中的子组件了，这就是所谓的不能完全解析。例如我们有下面的代码： 12345678910111213141516171819202122232425262728293031// 定义 WrappedComponent 组件class WrappedComponent extends Component&#123; render()&#123; return ( &lt;&gt; &lt;div&gt;Hello World&lt;/div&gt; &lt;MyComponent /&gt; &lt;/&gt; ) &#125;&#125;export default propsProxyHoc(propsProsyHoc);// 定义 MyComponent 组件class MyComponent extends Component&#123; render()&#123; return ( &lt;div&gt;Hello World&lt;/div&gt; ) &#125;&#125;// HOC封装export function propsProxyHoc(WrappedComponent) &#123; return class propsProxy extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); console.log(elementsTree) return elementsTree; &#125; &#125;&#125; 最后得到下面的结果： 最后分析我们的组件返回的 element tree，最后发现 &lt;&gt; 组件下 div 被完全解析了，但是 MyComponent 是组件类型的，其子组件并没有完全被解析的。 操作 stateHOC 还可以进行读取、编辑、删除 WrappedComponent 实例的 state，但是我们最后不要去操作原组件的属性，不然很容易搞混，破坏掉一些逻辑。添加 WrappedComponent 实例的 state 时，也需要注意一些变量覆盖的问题，添加一些 state 命名空间，避免一些属性混在一起。例如我们可以通过 柯里化 添加一些 state 初始值： 12345678910const propsProxyHoc = (...params) =&gt; &#123; //?可以做一些改变 params 的事 return (WrappedComponent) =&gt; &#123; return class propsProxy extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125; &#125;&#125; 然后我们赋初始值便可以这些写： 1export default propsProxyHoc(&#123;data: &#x27;柯里化传参&#x27;&#125;)(propsProsyHoc); 这样 propsProsyHoc 组件中 state 便被 HOC 设置了一些初始值。 命名因为 HOC 是包裹 WrappedComponent 组件，返回新的组件这就使 WrappedComponent 失去了原先的名称，这样不利于开发或者进行调试。我们通常可以在 WrappedComponent 名称前面添加一些前缀作为 HOC 返回的组件名称，例如 React-Redux： 1HOC.displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)` 然后其 getDisplayName 的实现也很简单： 12345function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || ‘Component’&#125; HOC 封装注意我们不管使用那种方式去实现 HOC 都有下面几条事项，需要去注意： 修改原始组件例如这样去封装组件： 1234567891011function logProps(InputComponent) &#123; //?通过修改prototype来修改组件 InputComponent.prototype.componentDidMount = function() &#123; console.log(&#x27;componentDidMount&#x27;); &#125;; //?此处已经被修改了 return InputComponent;&#125;//!组件调用const EnhancedComponent = logProps(InputComponent); 通过这种直接去修改组件源代码的方式是不推荐的，应该尽量规避，我们可以使用 HOC 添加一些属性对 WrappedComponent 组件进行相应的扩展： 12345678910export function propsProxyHoc(WrappedComponent) &#123; return class propsProxy extends WrappedComponent &#123; componentDidMount()&#123; console.log(&#x27;componentDidMount&#x27;); &#125; render() &#123; return super.render(); &#125; &#125;&#125; 多个 HOC 结合使用HOC 是在 WrappedComponent 组件的基础上添加一层逻辑封装，返回一个加强的新组件。但是如果一个组件需要不同维度的增强，那么就需要多次 HOC 嵌套使用： 1const EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent)); 但是这样写代码可读性会非常低，维护成本也会增加。我们可以通过compose将上述代码改写为： 12345const enhance = compose( withRouter, connect(commentSelector))const EnhancedComponent = enhance(WrappedComponent) HOC 使用注意在使用 HOC 时下面的几点需要注意不要出下面的问题： HOC 不能在 render 中使用React的 diff算法 通过判断 component ID 来决定是否更新存在的子树或者删除的子树，并且重新加载一个新的。如果从 render 方法中返回返回组件(===)原来的渲染组件。但是 HOC 是一个函数，每次调用都会返回一个新的组件，所以 render 方法每次调用 diff处理。并将原有组件进行删除，重新加载一个新的组件。所以我们在 render 中不能使用 HOC。 HOC 不包含 WrappedComponent 静态方法我们实现 HOC 时，通过对原始组件的加强得到并返回一个新的组件。这就造成了新组件中没有原始组件的任何静态的方法，所以如果想要在新组件中使用该静态方法的话，就需要一些特别的处理： 1234567function enhance(WrappedComponent) &#123; //?需要返回的组件 class Enhance extends React.Component &#123;/*...*/&#125; //!定义静态方法 Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; 通过这种方式之后 HOC 返回的组件才能使用那些静态方法。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://www.bipch.cn/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"}]},{"title":"Vue插槽","slug":"web/Vue/Vue插槽","date":"2020-09-17T23:16:36.000Z","updated":"2021-03-07T12:47:37.286Z","comments":true,"path":"vue-slot/","link":"","permalink":"https://www.bipch.cn/vue-slot/","excerpt":"Vue项目开发过程中，经常遇到多个组件它们基础功能大致一样，但又存在足够的差异性，比如 Button、滚动条、表单提交 等等都需要 防抖 处理，或者多个组件，有一些共用的属性或方法，但又存在足够的差异，我们便可以使用 Vue 提供的 混入(mixin) 来进行封装。下面分析下 Mixins 实现以及它的一些缺点。","text":"Vue项目开发过程中，经常遇到多个组件它们基础功能大致一样，但又存在足够的差异性，比如 Button、滚动条、表单提交 等等都需要 防抖 处理，或者多个组件，有一些共用的属性或方法，但又存在足够的差异，我们便可以使用 Vue 提供的 混入(mixin) 来进行封装。下面分析下 Mixins 实现以及它的一些缺点。 匿名插槽我们可以在子组件设置占位符，具体显示内容由父级决定。我们可以这样合成组件： 123456789&lt;!-- 子组件 --&gt;&lt;div&gt; &lt;p&gt;我是子组件: &lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;&lt;!-- 父组件 --&gt;&lt;Child&gt; &lt;p&gt;slot&lt;/p&gt;&lt;/Child&gt; 最后得出下面的HTML界面: 1234&lt;div&gt; &lt;p&gt;我是子组件: &lt;/p&gt; &lt;p&gt;slot&lt;/p&gt;&lt;/div&gt; 这样便通过父组件默认替换了子组件中的&lt;slot&gt;。 编译作用域如果我们需要在插槽中使用数据那么我们只可以使用本组组件的数据，例如我们子组件这个样子： 123456789101112&lt;template&gt; &lt;div&gt; &lt;p&gt;我是子组件: &lt;/p&gt; &lt;slot&gt;我是默认的slot&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;slotComponents&#x27;, data()&#123;return &#123;num: 0&#125;&#125;&#125;&lt;/script&gt; 而父组件我们这样写： 12345678910111213141516&lt;template&gt; &lt;div&gt; // 这样 name 是可以获取到本组件 name 的 &lt;Child&gt;子组件数据：num: &#123;&#123;name&#125;&#125;&lt;/Child&gt; // 这样 获取子组件数据是不行的，虽然它会替换子组件 &lt;Child&gt;子组件数据：num: &#123;&#123;num&#125;&#125;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;...export default &#123; name: &#x27;list&#x27;, data()&#123;return &#123;name: &#x27;李四&#x27;&#125;&#125;, ...&#125;&lt;/script&gt; 这时Vue的一个规则，父级模块的所有内容都是在父级作用域中编译的；子模板中的所有内容都是在子作用域中编译的。有的时候我们需要在父组件插槽内容中去访问子组件的数据，这时我们可以在子组件中把需要分享的数据，作为 &lt;slot&gt; 元素的一个 attribute 绑定上去。例如子组件这样设置 组件： 12345678// 界面&lt;slot :num=&#x27;num&#x27;&gt;我是默认的slot&lt;/slot&gt;// 数据data()&#123; reurn &#123; num: 0 &#125;&#125; 这样绑定在 &lt;slot&gt; 元素上的 attribute 就被称为插槽prop，然后我们可以在父级组件中使用带值的 v-slot 来定义我们提供的插槽prop的名称： 123&lt;Child&gt; &lt;template v-slot=&quot;childSource&quot; &gt;子组件数据：num: &#123;&#123;childSource.num&#125;&#125;&lt;/template&gt;&lt;/Child&gt; 这样我们将包含所有的插槽prop的对象命名为childSource，我们可以使用其获取所有子组件提供的数据。 具名插槽如果我们具有多个占位符，那这种情况怎么办呢? &lt;slot&gt;元素有一个特殊的attribute: name。这个属性可以用来定义额外的插槽: 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 一个不带name的&lt;slot&gt;会带默认的名称”default”。向具名插槽提供的内容时，我们可以在&lt;template&gt;元素上使用v-slot指令，并以参数的形式提供其名称： 1234567891011&lt;Child&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt; &lt;/template&gt;&lt;/Child&gt; 这样&lt;template&gt;元素中的所有内容都将会被传入相应的插槽。而没有被&lt;template&gt;包裹的内容都会被认为是默认插槽的内容，当然我们也可以使用&lt;template v-slot:default&gt;代表默认的分组。因为它是一个指令，Vue的指令一般都有一个缩写的，在 2.6.0 新增了缩写#，例如以前遇到的v-slot:header都可以缩写为#header。 总结我们总结下相应的插槽使用总结： 有名称的父级填充内容如果指定到子组件没有对应名称的插槽，那么改内容不会被替换到任何插槽中。 若子组件没有默认插槽，而父级如果插入默认的内容，那么这块默认的内容不会替换到任何一个插槽中。 如果子组件有多个默认插槽，而父组件指定了默认的插入内容，将 会 全部 替换到子组件的每个默认插槽中。这里就先总结到这里，如果有不足，后面会进行补充。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.bipch.cn/tags/Vue/"}]},{"title":"keep-alive","slug":"web/Vue/keep-alive","date":"2020-09-14T16:08:49.000Z","updated":"2021-03-07T12:43:31.949Z","comments":true,"path":"vue-keep-alive/","link":"","permalink":"https://www.bipch.cn/vue-keep-alive/","excerpt":"keep-alive 是一个由 Vue 提供的一个抽象组件，可以用来对指定的组件进行缓存，从而避免组件重写渲染影响使用体验、以及多次重复渲染降低程序性能。而 keep-alive 组件可以将组件缓存下来，避免造成上面的那些问题。","text":"keep-alive 是一个由 Vue 提供的一个抽象组件，可以用来对指定的组件进行缓存，从而避免组件重写渲染影响使用体验、以及多次重复渲染降低程序性能。而 keep-alive 组件可以将组件缓存下来，避免造成上面的那些问题。 使用场景在不使用 keep-alive 组件时，我们界面进行回退是会刷新界面的，会触发相应的生命周期函数，这时用户体验并不好(例如: 我们从列表跳转到详情界面，再从详情返回列表，这时列表默认会进行刷新)，但是如果我们引入 keep-alive 组件不但会减少项目的网络请求，还可以显著的提升用户的体验。 生命周期keep-alive 具有 activated 和 deactivated 两个生命周期。 activated: 界面第一次进入，钩子触发的顺序为：create -&gt; mounted -&gt; activated。 deactivated: 界面退出时触发 deactivated。 界面每次进入都会触发 activated，而如果只需要触发一次那就放在 mounted 钩子中。 propskeep-alive 提供了一些组件属性： include： 类型为 string 或 正则，只有组件名称匹配会进行缓存。 exclude： 类型为 string 或 正则，匹配到的不会进行缓存。 max： 最多可以缓存多少组件实例。 activated 和 deactivate 生命周期钩子。 缓存界面我们可以结合 router 缓存部分的项目界面。我们可以这样配置项目的路由： 12345678910reoters: [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, meta: &#123; // 缓存配置，开启 keepAlive: true &#125; &#125;] 这样便配置了项目路由，我们要根据 keepAlive 字段，判断是否需要对路由进行缓存，修改 router-view 组件代码： 1234&lt;keep-alive v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-else&gt;&lt;/router-view&gt; 这样便根据项目路由配置，动态判断缓存是否缓存界面。 beforeEach它一般需要和 beforeEach 进行结合使用，删除一些无用的数据缓存。例如我们有 list 界面开启了前端缓存，那么可以看下这么问题： 当我们进入 list 界面，然后退出，此时再次进入 list 界面，此时因为界面缓存是不会进行刷新的，这明显不符合我们需求，我们要如果退出 list 再次进入，需要重新刷新界面。分析下上面的功能: 入口进入 list 界面需要重新刷新。 详情界面进入 list 需要进行缓存不能刷新。 为了处理上面的问题，我们需要借助 beforeEach 钩子： 1234567// 入口进入列表。不要缓存，进去要刷新界面to.meta.keepAlive = false;next();// 详情回退列表，不要刷新to.meta.keepAlive = true;next();","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.bipch.cn/tags/Vue/"}]},{"title":"Proxy","slug":"web/ES6/Proxy","date":"2020-09-07T21:48:10.000Z","updated":"2021-03-07T06:54:29.670Z","comments":true,"path":"es6-promise/","link":"","permalink":"https://www.bipch.cn/es6-promise/","excerpt":"ES6中推出了 proxy 对象，主要用于在对象外搭建一层拦截，外界对目标对象的某些操作时，必须通过这次拦截。它主要用于改变某些操作的默认行为，也可以理解为Object.defineproperty()方法的升级版。","text":"ES6中推出了 proxy 对象，主要用于在对象外搭建一层拦截，外界对目标对象的某些操作时，必须通过这次拦截。它主要用于改变某些操作的默认行为，也可以理解为Object.defineproperty()方法的升级版。 创建1var proxy = new Proxy(target, handler); 上面 Proxy 对象主要接收两个参数： target: 参数表示所要拦截的对象。 handler: 也是一个对象，用来定制拦截行为。 我们可以通过下面的方式进行使用： 12345678910111213141516171819202122let target = &#123; name: &#x27;poetries&#x27;&#125;;let logHandler = &#123; get: function(target, key) &#123; console.log(`$&#123;key&#125; 被读取`); return target[key]; &#125;, set: function(target, key, value) &#123; console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`); target[key] = value; &#125;&#125;let targetWithLog = new Proxy(target, logHandler); // 进入 Proxy,输出: name 被读取 targetWithLog.name;// 进入 Proxy,输出: name 被设置为 otherstargetWithLog.name = &#x27;others&#x27;; // 不会进入 Proxy,输出: othersconsole.log(target.name); targetWithLog读取属性的值时，实际调用logHandler.get，在控制台输出信息，并且读取被代理的对象target的属性。 targetWithLog设置属性的值时，实际调用logHandler.set，也会在控制台输出信息，并且设置代理对象target的属性值。 实例方法Proxy 还提供了一系列的操作方法，用于配置相应的拦截。 apply主要拦截函数的调用 call 和 apply 操作，apply(target, object, args)主要有3个参数，分别为： target：目标对象(也就是代理封装的函数)。 object：目标对象上的上下文对象(this); args：目标对象的参数数组(参数，是个数组，当然也可以不用，使用 arguments 也行)。 例如下面代码： 12345678910111213let twice = &#123; apply(target, ctx, args) &#123; return &#x27;I am the proxy&#x27;; &#125;&#125;;let target = function() &#123; return &#x27;I am the target&#x27;; &#125;;let proxy = new Proxy(target, twice);// 下面代码都会进入代理，值都为 I am the proxyproxy(1, 2);proxy.call(null);proxy.apply(null); 也可以计算一些数据，处理一些参数，例如： 1234567891011121314function sum(a, b) &#123; return a + b;&#125;const handler = &#123; apply: function(target, that, argumentsList) &#123; console.log(`Calculate sum: $&#123;argumentsList&#125;`); return target(argumentsList[0], argumentsList[1]) * 10; &#125;&#125;;const proxy1 = new Proxy(sum, handler);// 正常处理，输出3console.log(sum(1, 2));// 进入代理输出 Calculate sum: 1,2，并把结果 * 10返回console.log(proxy1(1, 2)); get可以拦截读取的操作。对于不可配置(configurable)、不可写(writable)的属性，不能被代理，硬要通过 Proxy 代理会报错。例如我们可以读取时，如果存在则返回，不存在则抛出异常： 1234567891011121314151617var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \\&quot;&quot; + property + &quot;\\&quot; does not exist.&quot;); &#125; &#125;&#125;);// 正常返回张三proxy.name// 不存在,抛出异常proxy.age 并且get方法是可以继承的： 12345678910let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(&#x27;GET &#x27; + propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);// 输出GET fooobj.foo 创建 Proxy 对象 proto，然后在通过Object.create根据 proto 创建一个新的对象 obj，通过obj访问是可以进入构造器的。我们还可以读取通过get创建数组，让其读取负数索引(负数索引表示数据倒着数)： 1234567891011121314function createArray(...elements) &#123; let handler = &#123; get(target, propKey, receiver) &#123; let index = Number(propKey); if (index &lt; 0) &#123; propKey = String(target.length + index); &#125; return Reflect.get(target, propKey, receiver); &#125; &#125;; return new Proxy(elements, handler);&#125;let arr = createArray(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);arr[-1]; 通过 new Proxy 创建 了一个 Proxy，数据就是函数传输的，而 get 方法判断下标是否小于0，小于0则添加数组长度让其从右侧开始，否则直接反射。 上面的 ownKeys 是 es6 提出的反射机制。 has主要用于判断对象是否具有某个属性，和in操作非常的相似(也是用于判断对象是否包含某个key)。如果原生对象不可配置、或者禁止扩展，是不能用 has 进行拦截的，不然会抛出异常。我们可以使用 has 隐藏一些内部属性(一般都是”_”开始)，不被外面的 in 发现： 12345678910111213141516171819202122// 代理const handler1 = &#123; has(target, key) &#123; if (key[0] === &#x27;_&#x27;) &#123; return false; &#125; return key in target; &#125;&#125;;// 对象const monster1 = &#123; _secret: &#x27;easily scared&#x27;, eyeCount: 1&#125;;// 封装代理const proxy1 = new Proxy(monster1, handler1);// 代理开始查找，有改属性返回 trueconsole.log(&#x27;eyeCount&#x27; in proxy1);// 代理开始查找，内部属性被隐藏，查找不到，返回 falseconsole.log(&#x27;_secret&#x27; in proxy1);// 查找原生的，没有代理的，可以正常查找console.log(&#x27;_secret&#x27; in monster1); 该方法主要用于隐藏一些内部字段和敏感字段。 set拦截对对象属性进行赋值的操作，返回布尔值。如果有的值不能进行赋值、不可写等都不能进行配置。比如我们有一些字段需要特定的值，需要先验证在赋值，验证失败直接抛出异常： 123456789101112131415161718192021222324252627let validator = &#123; set: function (obj, prop, value) &#123; // 开启 age 属性的验证 if (prop === &#x27;age&#x27;) &#123; // 不是数字 if (!Number.isInteger(value)) &#123; throw new TypeError(&#x27;The age is not an integer&#x27;); &#125; // 数据过大 if (value &gt; 100) &#123; throw new RangeError(&#x27;The age seems invalid&#x27;); &#125; &#125; // 成功赋值 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 60;// 拿到 60person.age// 无法赋值，抛出 The age is not an integerperson.age = &#x27;张三&#x27;;// 无法赋值，抛出 The age seems invalidperson.age = 110; 一旦数据更新便会进入代理，我们可以更新视图数据，而 Vue 中的观察 + 数据拦截，在 Vue 3.0 便是通过 Proxy 替代 Object.defineProperty 进行数据代理。 总结上面介绍了一些方法的简单使用，但是我们其实并不太需要这些的用法，因为有些 API 注定不会常用，只需有些印象，出现这种问题时，知道往那方面去学习。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.bipch.cn/tags/ES6/"},{"name":"代理","slug":"代理","permalink":"https://www.bipch.cn/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"let 和 const","slug":"web/ES6/let和const","date":"2020-09-06T10:26:06.000Z","updated":"2021-03-07T06:34:21.506Z","comments":true,"path":"es6-let-const/","link":"","permalink":"https://www.bipch.cn/es6-let-const/","excerpt":"Es6 不仅添加一些常用的方法、对象，还对 JavaScript 的基本变量进行了扩展，在原先 var 的基础上又提出了 let 和 const 关键字。那么这两个关键字到底有什么作用，到底解决了什么问题呢？","text":"Es6 不仅添加一些常用的方法、对象，还对 JavaScript 的基本变量进行了扩展，在原先 var 的基础上又提出了 let 和 const 关键字。那么这两个关键字到底有什么作用，到底解决了什么问题呢？ 为什么要有它们在 ES6 之前项目中是没有 let 和 const 关键字的，定义变量都是需要通过 var 来完成，但是由于 var 并没有作用域等概念，所以变量会比较混乱，并且如果变量定义过多也会出现一些意想不到的错误，比如下面的问题： 变量提升就是变量可以在声明前被使用，值为 undefined ，比如下面代码： 123// 输出 undefinedconsole.log(a);var a = 2; 这明显不是我们想要的，如果变量未声明便去使用，要抛出ReferenceError异常。 暂时性死区其实造成这个的原因便是上面的问题，例如我们有下面代码： 12345var a = 123;if(true)&#123; a = 456; let a;&#125; 上述代码回抛出 ReferenceError 异常，是因为在块级区域声明 a，那么该区域便会和这个变量进行绑定(binding)，而你在定义变量上面进行赋值，由于此时还未能声明所以对为声明变量赋值回抛出一个异常。 重复声明var 支持变量的重复声明，一个变量名，可以进行很多次的声明： 12345var a = 123;if (true) &#123; var a = 12; var a = 123;&#125; 作用域var 中并没有什么作用域划分，常用的变量全靠覆盖，比如： 12345if (true) &#123; var a = 10;&#125;// 正常输出 10console.log(a); 基于上面问题，ES6为了规范代码，提出了 let 和 const。 块级作用域和函数声明函数可以在块级作用域之中声明吗？ES5中规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域声明。 123456789// 情况一if(true)&#123; function f()&#123;&#125;&#125;// 情况二try&#123; function f()&#123;&#125;&#125; 上面函数声明在ES5中都是非法的。但是浏览器没有遵守该规定，为了兼容旧代码，还是支持在块级作用域之中声明函数，因此上面代码都能运行并不会报出错误。ES6则引入了块级作用域，明确允许在块级作用域中声明函数。ES6规定在块级作用域之中，函数声明语句类似于let，在块级之外不能使用。 12345678function f()&#123;console.log(&#x27;I am outside!&#x27;);&#125;(function()&#123; if(false)&#123; function f()&#123;console.log(&#x27;I am inside!&#x27;);&#125; &#125; f();&#125;()) 上述代码在浏览器中回报出错误TypeError，因为上述代码会被编辑为： 1234567function f() &#123; console.log(&#x27;I am outside!&#x27;);&#125;(function () &#123; if (false) &#123; var f; &#125; f();&#125;)(); 因为 var 没有作用域的划分，所以 f() 会抛出错误。而在ES6则会编译为下面的代码： 1234567function f() &#123; console.log(&#x27;I am outside!&#x27;);&#125;(function () &#123; if (false) &#123; var _f; &#125; f();&#125;)(); 可以正常打印出 I am outside!。 const用于定义一个常量，定义之后常量指向的内存地址不能发送改变，并且定义时一定要赋上初始值。注意是指向内存地址不能改变，不是数据不能改变： 12345678const f = &#123;&#125;;// 并没有改变指向，可以成功f.a = 123;// 但是数据被冻结，严格模式下会报错const foo = Object.freeze(&#123;&#125;);foo.prop = 123; 常量 foo 指向一个冻结的对象，所以添加熟悉时不起作用。除了将对象本身冻结，也可以将对象彻底冻结： 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, i) =&gt; &#123; if(typeof obj[key] === &#x27;object&#x27;)&#123; constantize(obj[key]); &#125; &#125;);&#125;","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://www.bipch.cn/tags/ES6/"}]},{"title":"create-react-app","slug":"web/webpack/create-react-app","date":"2020-08-27T00:11:39.000Z","updated":"2021-03-02T04:33:59.609Z","comments":true,"path":"create-react-app/","link":"","permalink":"https://www.bipch.cn/create-react-app/","excerpt":"由于 webpack 的兴起，不少技术使用 webpack 都能很方便的进行开发，但是由于其需要过多的配置，这样便浪费很多的开发时间，于是前端便出现了一系列的 webpack 相关的脚手架，目的便是更方便的进行相关开发，而 React 作为前端非常火的技术脚手架的数量更是非同一般，这里只是简单总结下使用 create-react-app 在开发过程中经常遇到的问题。","text":"由于 webpack 的兴起，不少技术使用 webpack 都能很方便的进行开发，但是由于其需要过多的配置，这样便浪费很多的开发时间，于是前端便出现了一系列的 webpack 相关的脚手架，目的便是更方便的进行相关开发，而 React 作为前端非常火的技术脚手架的数量更是非同一般，这里只是简单总结下使用 create-react-app 在开发过程中经常遇到的问题。 CSS ModulesCSS Modules 允许你在不同的文件中使用相同的 CSS classname，而无需担心命名冲突。例如我们 css 样式为： 123.red &#123; color: red;&#125; 默认情况编写 className 为 red 即可，而使用 CSS Modules 便可以这么写： 123456789101112import styles from &#x27;.....css&#x27;;function App() &#123; return ( &lt;div&gt; &lt;p className=&#123;styles.red&#125;&gt;CSS Modules&lt;/p&gt; &lt;p className=&quot;red&quot;&gt;classname&lt;/p&gt; &lt;/div&gt; );&#125;export default App; 最后结果 styles.red 样式为红色，而 red 样式是空的。这便是 CSS Modules 它可以完美解决 css 样式覆盖的问题。而 create-react-app 默认便是支持 CSS Modules 的，但是只能是指定格式的文件名，例如如果文件名为：index.css，这样 CSS Modules 是不会生效的，只能为：index.module.css才能生效，根据官网的提示，命名规则必须为：[name].module.css否则都会无效的。 proxy随着前后端的分离，开发过程中跨域的情况是无法避免的，前端的请求接口如果不是在后台设置相应白名单的情况下大部分都会面临着跨域的问题，而前端解决这种问题的方式也很简单，大部分都是通过 proxy 去完成，而 React 默认情况下只能在 package.json 中 proxy 属性添加配置，例如： 1&quot;proxy&quot;: &quot;http://localhost:6060&quot;, 但是大部分情况下，我们需要更灵活的配置，例如： 12345678910111213proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;******&#x27;, ws: true, changeOrigin: true &#125;, &#x27;/searchData&#x27;: &#123; target: &#x27;******&#x27;, ws: true, changeOrigin: true &#125; ...&#125; 而它如果要实现这种情况只能借助一个插件http-proxy-middleware去完成。 devtool主要用于判断是否生成 source map，因为文件打包之后，和原本文件有着许多的差别，而为了方便调试找出错误，需要将打包之后的文件和源文件进行管理，此时一般需要 source map，虽然它很方便我们的代码调试，但是如果我们将打包放到生产环境下，会很容易保留我们项目的源码，例如下面情况： 而源码的暴露显然不符合我们的预期，所以我们要打包部署时关闭 devtool，防止源码暴露，但是 create-react-app 已经隐藏了 webpack 的配置，如需重新暴露，需要运行：npm run eject，但会暴露出全部配置，添加项目可阅读性，显然不是我们想要的，我们一般使用：react-app-rewired 或者 craco 去覆盖配置，但不论何种方法，我们需要覆盖 webpack devtool 配置： 1devtool: &#x27;inline-source-map&#x27;, // 调试代码用 覆盖为这样的值，便解决了这个问题。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"脚手架","slug":"脚手架","permalink":"https://www.bipch.cn/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"}]},{"title":"dva","slug":"web/React/dva/dva","date":"2020-08-27T00:11:39.000Z","updated":"2021-03-07T12:20:30.920Z","comments":true,"path":"dva/","link":"","permalink":"https://www.bipch.cn/dva/","excerpt":"一款基于 redux 和 redux-saga 基础上进行开发的数据流管理方案，并对其进内部行了封装，添加了一些代码约束。重点在于没有引入新的概念和语法，所以比较容易上手，只需明白其代码结果即可。","text":"一款基于 redux 和 redux-saga 基础上进行开发的数据流管理方案，并对其进内部行了封装，添加了一些代码约束。重点在于没有引入新的概念和语法，所以比较容易上手，只需明白其代码结果即可。 dva-cli首先通过npm安装 dva-cli 脚手架，帮助我们快速搭建项目： 1npm install dva-cli -g 安装完成后使用-v查看安装版本： 1dva -v 安装完成后，使用new命令生成项目： 1dva new project 可以看项目代码和结构，已经帮我们省略许多的代码。 路由由于其内置并封装了 react-router 我们并不需要重新安装和配置依赖，只需根据其规则书写即可。在 /src/router.js 添加下面代码： 1&lt;Route path=&quot;/counter&quot; exact component=&#123;CountPage&#125; /&gt; 即可完成添加，但是项目的访问路径却是：/#/counter，这并不符合我们需求，需求是并不需要 #，我们需要把 # 去掉，那么问什么会出现这个符合呢？是因为 router 分为 HashRouter 和 BrowserRouter，那么这两个路由是有什么区别呢？ HashRouter：是最基础的路由，不需要浏览器 web server 支持。原理为 URL 的hash，“#”代表网页中的一个位置。其右面的字符，就是位置的标识符。单界面应用正是通过hash实现 “界面跳转” 。 BrowserRouter：H5 新增了history API，IE9及以下不兼容，需要由 web server 支持。可以通过 js解析、修改界面地址，达到渲染的效果。 而dva默认路由为 HashRouter，若想去掉 # 只需改为 BrowserRouter： 安装history，因为 BrowserRouter 的核心为 history，所以一定要给项目添加 history：1yarn add history 添加 history，安装完成后，要在根文件(/src/index.js)里面配置：1234import createHistory from &#x27;history/createBrowserHistory&#x27;;const app = dva(&#123; history: createHistory(),&#125;); 这样路由就修改完成了，首页地址变为了：http://localhost:8000/。 Modeldva 通过 Model 层将数据和逻辑连接在一起管理，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions。下面介绍下Model里面的 5 个重要属性： namespace命名空间，为了防止 state 或者一些方法重复的属性，只能用字符串。 state初始值，注意他的优先级低于创建dva时的 opts.initialState 属性。 访问的时候前面要加上命名空间。 reducers主要用于处理同步操作，唯一 可以修改 state 的地方。和 redux 中 reducer 非常相似。一般格式为：(state, action) =&gt; newState。 effects主要用于处理异步操作，他不能直接修改 state。他也是由 action 触发，也可以触发 action、和服务器交互、获取全局 state 等等。 effects 和 reducers 属性里面的方法名不能相同，如果相同会两个都执行，然后陷入死循环。 subscriptions主要用于监听一个数据源，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"脚手架","slug":"脚手架","permalink":"https://www.bipch.cn/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"}]},{"title":"MobX","slug":"web/React/Mobx/mobx","date":"2020-08-07T00:46:50.000Z","updated":"2021-03-07T12:26:54.870Z","comments":true,"path":"react-introduce/","link":"","permalink":"https://www.bipch.cn/react-introduce/","excerpt":"和 redux 很相似的一种数据流管理框架，但是 redux 基于函数式编程，采用单一根节点，过多的API，以及冗余的代码等问题，造成其比较难以真正的掌握，往往学习到底都是一些皮毛。而 Mobx 主要基于 观察者模式，并且具有多节点数据，相较于 redux 更加容易的掌握。","text":"和 redux 很相似的一种数据流管理框架，但是 redux 基于函数式编程，采用单一根节点，过多的API，以及冗余的代码等问题，造成其比较难以真正的掌握，往往学习到底都是一些皮毛。而 Mobx 主要基于 观察者模式，并且具有多节点数据，相较于 redux 更加容易的掌握。 简介Mobx 的核心概念也很简单，简单一个案例便能看清楚，根据官网的介绍 Mobx 主要有 3 个要点：observable、observer、action。分别用于表示： observable：定义观察状态，将状态设置为可观察的。 observer：将组件设置为可以响应状态的变化。 action：严格模式下，修改数据的唯一途径。 三个核心的概念，用户操作视图发送 action，导致 observable 的状态发生了改变，状态改变后通过 observer 影响到最终展示的组件，最终用户看到的界面更新。一种挺常见的单向数据流，通过 动作 修改 状态，而状态更新影响视图，官网给的图例如下所示： 首先定义一个可观察的 Sotre 数据： 1234567891011121314151617181920import &#123; observable, action &#125; from &#x27;mobx&#x27;;class NameStore &#123; name = &#x27;&#x27; constructor() &#123; this.name = &#x27;blog&#x27;; &#125; setName= (name) =&gt; &#123; this.name = name; &#125;&#125;// 将birds标为被观察状态，这样在birds有变动的时候，组件里才会更新decorate(NameStore, &#123; birds: observable, setName: action&#125;)const store = new NameStore();export default store; 然后在需要定义一个观测状态的组件： 12345678910111213import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123;observer, inject&#125; from &#x27;mobx-react&#x27;;class App extends Component &#123; render() &#123; const&#123;NameStore&#125; = this.props; return &lt;div onClick=&#123;() =&gt; NameStore.setName(&#x27;action&#x27;)&#125;&gt; &#123;NameStore.name&#125; &lt;/div&gt; &#125;&#125;;export default inject(&#x27;NameStore&#x27;)(observer(App)); 这样一个观测组件便定义好了，下面只需在根组件注册 Store 数据即可： 12345678import React from &#x27;react&#x27;;import &#123; render &#125; from &#x27;react-dom&#x27;;import NameStore from &#x27;./stores/NameStore&#x27;;render( &lt;App NameStore=&#123;NameStore&#125; /&gt; document.getElementById(&#x27;root&#x27;)); 这样一个基本的 Mobx 的 demo 便完成了，使用 Mobx 可以很方便的将项目的逻辑和视图层进行分离，视图层只需获取指定数据，发送相对于的 action 即可。并且由于 Mobx 是使用观察者模式，状态改变后会自动判断哪有组件需要重新渲染，不需要用户在使用 shouldComponentUpdate 判断是否渲染，对性能有进一步的提升。 observable将数据设置为可观察数据，就是数据拦截，观察的数据一旦修改或者获取都会触发指定的拦截。Observable 封装的数据类型可以有很多种，可以是基本类型、引用类型、普通对象、类、数组等，封装完成后 Mobx 会对数据进行微调，例如： 如果类型是 Map，那么会返回一个全新的 Observable Map 对象。 如果类型是数组，那么会返回一个全新的 Observable Array 对象。 …虽然封装之后数据类型发生了改变，但是其相应的方法被没有改变，之前的方法还是能够正常的使用： 1234const observableList = mobx.observable([1,2,3]);console.log(observableList[0]);console.log(observableList.length); 都是可以正常访问的。其绑定的原理和 Vue 的双向绑定是相似的，都可以通过 Object.defineProperty 来实现： 12345678910Object.defineProperty(object, key, &#123; get : function()&#123; // 获取属性时进行拦截 return value; &#125;, set : function(newValue)&#123; // 设置属性的拦截 value = newValue &#125;,&#125;); 这样无论读取和设置都会调用相应的逻辑，一旦数据变化，便可以通知视图组件，进行相应的界面更新。 observer接收一个组件作为函数的参数，返回一个对变化响应式组件。 12345678import &#123;observer, inject&#125; from &#x27;mobx-react&#x27;;class App extends Component &#123; render() &#123; ... &#125;&#125;;export default inject(&#x27;NameStore&#x27;)(observer(App)); 使用 inject 函数将指定数据，注入到组件数据中，通过 observer 将组件设置为可响应状态变化的组件，一般这两个方法需要进行配合的使用。 action严格的模式下 Mobx 只能通过 action 来修改项目的 Store，不能让项目任何情况下都可以更新数据，这样项目就会难以维护。项目中修改 Store 一定要在 action 中进行： 123decorate(object, &#123; setName: action&#125;) 将方法设置为 action 类型，然后我们便可以在该方法里面更新数据了。action 可以很好的将我们的 Store 和逻辑代码分离，便于后面维护代码。 对比 ReduxMobx 和 Redux 都是 React 中比较好的数据流管理工具，但是由于其核心不一样，所以两个框架还是有着很大区别的： 单一数据源和多数据源，Redux 强调的便是单个 Store，而 Mobx 可以有多个 Store。 Reudx 只能通过手动处理数据，通过 shouldComponentUpdate 判断组件是否需要重新渲染，而 Mobx 通过 观察者模式 可以自动判断哪些组件需要重新渲染。 Redux 强调状态的不可变性，就算在 reducer 更新，但是只能返回新的 Store 覆盖，不能直接更新，而 Mobx 可以直接更新 Store。 由于 Mobx 很多逻辑代码都是封装好的，调试比较困难，也更加难以预测，而 Redux 以纯函数的形式可以让调试更简单。 虽然 Mobx 相对来说比较容易上手，因为其运用面向对象思维，引入一些抽象概念。而 Redux 通过函数式编程，同时借助一些中间件处理异步，所以上手难度略高于 Mobx。 但是这只是一个简单的对比，具体选用还是要看团队的技术，如果简单的话可以使用 Mobx 可以，但是如果项目有着复杂的 Store 结构，Mobx 不是不可以，但是 Redux 会可以更方便的调试。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"Mobx","slug":"Mobx","permalink":"https://www.bipch.cn/tags/Mobx/"}]},{"title":"react-hooks","slug":"web/React/react-hooks","date":"2020-05-18T00:20:34.000Z","updated":"2021-03-07T12:03:50.458Z","comments":true,"path":"react-hooks/","link":"","permalink":"https://www.bipch.cn/react-hooks/","excerpt":"hooks 是 React 16.8 引入的新特性，它可以使我们在不编写 class 组件的情况下可以去使用 state、生命周期函数、 和其他 React 功能。并且 hooks 可以从各个组件中提取状态逻辑，以便于代码的复用，这样组件之间共享数据就变得很简单。","text":"hooks 是 React 16.8 引入的新特性，它可以使我们在不编写 class 组件的情况下可以去使用 state、生命周期函数、 和其他 React 功能。并且 hooks 可以从各个组件中提取状态逻辑，以便于代码的复用，这样组件之间共享数据就变得很简单。 为什么使用 hooks项目组件起初很简单，但随着状态、逻辑、副作用的增多变为难以控制的混乱状态，每一个生命周期都包含着毫不相关逻辑代码的混合。比如我们的组件可能会在 componentDidMount 、componentDidUpdate 周期中获取处理数据，但是在同一个 componentDidMount 中还包含着其他的逻辑比如，注册事件的监听，最后需要在 componentWillUnmount 清除。这样我们毫不相连的代码就结合在了一起。这样就会导致一些逻辑的不一致。而 Hook 将组件中相互关联的部分拆分成更小的函数。 State Hookstate hook 提供了在 function 组件中使用 state。并且可以抽取相同的 state 状态和逻辑是数据得到更好的复用。下面举一个简单的例子： 1234567891011121314import React, &#123;useState&#125; from &#x27;react&#x27;;function App() &#123; // 赋值，初始值 0 const [count, setCount] = useState(0); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;p&gt;num: &#123;count&#125;&lt;/p&gt; &lt;p onClick=&#123;() =&gt; setCount(state =&gt; state + 1)&#125;&gt;+&lt;/p&gt; &lt;p onClick=&#123;() =&gt; setCount(state =&gt; state - 1)&#125;&gt;-&lt;/p&gt; &lt;/header&gt; &lt;/div&gt; );&#125; 上面只是调用了 useState 方法，那么 useState 到底做了什么呢？ 它定义了一个变量count，这个名称可以是任意的，useState 返回值是个数组，我们可以使用任意名称接收。setCount 为修改数据需要调用的方法，它与 class 里的 this.state 提供的功能完全相同。但是函数中的变量退出后会消失，而 state 中的变量会在 React 中保留。 useState 进行数据赋值是覆盖式更新，并不会合并数据 如果数据格式复杂注意不要覆盖一些变量。一些复杂的数据格式我们可以使用 es6 的扩展运算符帮助我们解决数据覆盖的问题，如 {…source, count: 1} 这样 count 就会覆盖 source 中的 count。 Effect HookEffect Hook 可以让我们在函数组件中执行副作用操作，如果你熟悉 React class 的生命周期那么就可以将 Effect Hook 看作 componentDidMount， componentDidUpdate， componentWillUnmount 这三个函数的组合。我们可以在这个地方获取数据、设置订阅，手动的更改 DOM等操作，也可以在卸载一些订阅。 123456789101112131415161718import React, &#123;useState&#125; from &#x27;react&#x27;;function App() &#123; // 赋值，初始值 0 const [count, setCount] = useState(0); useEffect(() =&gt; &#123; document.title = `you clicked $&#123;count&#125; times`; &#125;, [count]); return ( &lt;div className=&quot;App&quot;&gt; &lt;header className=&quot;App-header&quot;&gt; &lt;p&gt;num: &#123;count&#125;&lt;/p&gt; &lt;p onClick=&#123;() =&gt; setCount(state =&gt; state + 1)&#125;&gt;+&lt;/p&gt; &lt;p onClick=&#123;() =&gt; setCount(state =&gt; state - 1)&#125;&gt;-&lt;/p&gt; &lt;/header&gt; &lt;/div&gt; );&#125; 这样就会监听 count 的变化，如果 [count] 中的任意数据有所变化，便会执行相应的 useEffect 中的代码。主要有下面几点需要说明： useEffect(callback: () =&gt; void，deps: array[]) 方法接收两个参数，第二个为选填参数。表示 Effect 更新需要依赖那些属性。 由于一个组件可以有多个 Effect 所以我们有的 Effect 并不是有属性更新便会调用，而是具体指定 Effect 的依赖列表。 第一个参数界面加载完成后便会执行相当于 componentDidMount ，如果有依赖列表数据变化，便会在执行该函数，这时相当于 componentDidUpdate，如果该函数返回了一个函数，则返回的函数会在组件卸载时调用，这时相当于 componentWillUnmount。useContext1const value = useContext(MyContext); 接收一个 Context 对象(使用 React 提供的 createContext 创建)，并会寻找距离当前组件最近的一个 Provider 的 value 值。首先创建一个 context 对象：123import &#123; createContext &#125; from &#x27;react&#x27;;export const UserContext = createContext(&#123;&#125;); 这样 context 对象就被创建好了，下面在调用其 Provider 组件设置初始值：123456789101112131415import React, &#123; useState &#125; from &#x27;react&#x27;;import &#123;UserContext&#125; from &#x27;./UserContext&#x27;;import UserInfo from &#x27;./user&#x27;;const User = () =&gt; &#123; const [user, setUser] = useState(&#x27;blog&#x27;); return ( &lt;UserContext.Provider value=&#123; &#123; user, setUser &#125; &#125;&gt; &lt;UserInfo /&gt; &lt;/UserContext.Provider&gt; );&#125;export default User; 这样 context 组件已经创建完成了，下面写子组件并使用 useContext 获取到设置的初始值即可：1234567891011121314import React, &#123; useContext &#125; from &#x27;react&#x27;;import &#123;UserContext&#125; from &#x27;./UserContext&#x27;;export default () =&gt; &#123; const &#123; user, setUser &#125; = useContext(UserContext); return ( &lt;div&gt; &lt;p&gt;&#123;user&#125;&lt;/p&gt; &lt;button onClick = &#123;() =&gt; setUser(&#x27;123123&#x27;)&#125;&gt; set name &lt;/button&gt; &lt;/div&gt; )&#125; 这样我们就通过 context 完成了组件之间数据的传输。useMemo用于缓存组件中一些方法计算的结果，比如组件中的某一数据需要复杂计算而来，为了节约性能可以通过缓存计算结果并在下一个操作中重新使用缓存来加速查找费时的操作。而 useMemo 就是使用 memoization 来提升组件的性能，这里不过多介绍。这里我们需要传给它一个依赖列表，它的值会作为 key，如果 key 值不变函数只会执行第一次后面便会从缓存获取，只有 key 修改才会进行重新计算。修改下上面组件代码：123456789101112131415import React, &#123; useState &#125; from &#x27;react&#x27;;import UserInfo from &#x27;./user&#x27;;const User = () =&gt; &#123; const [user, setUser] = useState(&#123; name: &#x27;blog&#x27;, other: 1 &#125;); return ( &lt;UserInfo user=&#123;user&#125; setUser=&#123;setUser&#125; /&gt; );&#125; export default User; 修改子组件代码：1234567891011121314151617181920212223242526272829303132import React, &#123;memo, useMemo&#125; from &#x27;react&#x27;;export default memo( (&#123;user, setUser&#125;) =&gt; &#123; const &#123;name, other&#125; = user; const useOther = useMemo(() =&gt; &#123; // 复杂的逻辑 //... console.log(&#x27;没有缓存&#x27;); return other; &#125;, [other]); return ( &lt;div&gt; &lt;p&gt;name: &#123;name&#125;&lt;/p&gt; &lt;p&gt;other: &#123;useOther&#125;&lt;/p&gt; &lt;button onClick = &#123;() =&gt; setUser(&#123; ...user, name: &#x27;123123&#x27; &#125;)&#125;&gt; set name &lt;/button&gt; &lt;button onClick = &#123;() =&gt; setUser(&#123; ...user, other: 0 &#125;)&#125;&gt; set other &lt;/button&gt; &lt;/div&gt; ) &#125;)export default User; 这样只有 useMemo 函数中依赖项中的数据变化，才会执行函数中的值，否则会在缓存中进行获取。这样就极大提升了程序的性能。 注意 useMemo 函数会在渲染期间执行。不要在该函数内部执行与渲染无关的操作，如果需要添加一些副作用函数要在 useEffect 而不是 useMemo。 useCallback该函数的作用和上面的 useMemo 作用非常的相似，但是它返回的是一个缓存函数。比如我们和上面一样也做一个测试: 123456789101112131415161718192021222324import React, &#123; useState, useCallback &#125; from &#x27;react&#x27;;const set = new Set();const Count = () =&gt; &#123; const [count, setCount] = useState(1); const [val, setVal] = useState(&#x27;&#x27;); const callback = useCallback(() =&gt; &#123; console.log(0); return count; &#125;, [count]); set.add(callback); console.log(set); return ( &lt;div&gt; &lt;h4&gt;size: &#123;set.size&#125;&lt;/h4&gt; &lt;h4&gt;count: &#123;count&#125;&lt;/h4&gt; &lt;h4&gt;val: &#123;val&#125;&lt;/h4&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125; /&gt; &lt;/div&gt; );&#125;export default Count; 可以看到如果依赖项 count 不改变，set 集合大小就不会改变。打印出的 set 集合存放的各种缓存函数。其实 useCallback(fn， deps) 和 useMemo(() =&gt; fn， deps) 作用是相同的。比如我们有一个父组件，包含一个子组件，子组件接收一个函数作为props。这样无论父组件那个数据修改了，子组件便会执行更新，但是有很多情况下更新是没有必要的，我们可以借助 useCallback 和 memo 一起避免不必要的更新。 1234567891011121314151617181920import React, &#123; useState, useCallback &#125; from &#x27;react&#x27;;import ViewCount from &#x27;./viewCount&#x27;;const Count = () =&gt; &#123; const [count, setCount] = useState(1); const [val, setVal] = useState(&#x27;&#x27;); const callback = useCallback(() =&gt; &#123; return count; &#125;, [count]); return ( &lt;div&gt; &lt;ViewCount callback=&#123;callback&#125; /&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125; /&gt; &lt;/div&gt; );&#125;export default Count; 编写子组件，需要结合 memo 避免重复渲染。 123456789101112import React, &#123; useState, useEffect, memo &#125; from &#x27;react&#x27;;const viewCount = memo((&#123; callback &#125;) =&gt; &#123; const [count, setCount] = useState(() =&gt; callback()); console.log(0); useEffect(() =&gt; &#123; setCount(callback()); &#125;, [callback]); return &lt;p&gt; &#123; count &#125; &lt;/p&gt;&#125;)export default viewCount; 这样只有子组件数据改变才会重新进行渲染。 无论是useCallback还是useMemo避免子组件重复渲染都需要memo的配合，不然不仅不会提示性能，还是对程序性能造成一些影像。 memo避免一些组件重复的渲染，比如下面会造成很大的资源浪费，简单修改下上面写的组件: 123456789101112131415161718import React, &#123; useState, useCallback &#125; from &#x27;react&#x27;;import &#123;UserContext&#125; from &#x27;./UserContext&#x27;;import UserInfo from &#x27;./user&#x27;;const User = () =&gt; &#123; const [user, setUser] = useState(&#x27;blog&#x27;); const [count, setCount] = useState(0); return ( &lt;UserContext.Provider value=&#123; &#123; user, setUser &#125; &#125;&gt; &lt;UserInfo user=&#123;user&#125; setUser=&#123;setUser&#125; /&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; + &lt;/button&gt; &lt;/UserContext.Provider&gt; );&#125;export default User; 然后在子组件中添加一些渲染提示: 12345678910111213import React, &#123;memo&#125; from &#x27;react&#x27;;export default (&#123;user, setUser&#125;) =&gt; &#123; console.log(&#x27;assembly Rendering&#x27;); return ( &lt;div&gt; &#123;user&#125;&lt;br /&gt; &lt;button onClick = &#123;() =&gt; setUser(&#x27;123123&#x27;)&#125;&gt; set name &lt;/button&gt; &lt;/div&gt; )&#125; 这样父组件中的 count 发送变化 user 子组件就会重新渲染。按照正常逻辑来讲，count 和 user 组件没有关系，count 无论怎么变化都不该将 user 组件重新渲染，如果 user 组件逻辑很复杂会造成很大的性能的浪费。我们可以使用 memo 解决这个问题: 123456789101112131415import React, &#123;memo&#125; from &#x27;react&#x27;;export default memo( (&#123;user, setUser&#125;) =&gt; &#123; console.log(&#x27;assembly Rendering&#x27;); return ( &lt;div&gt; &#123;user&#125;&lt;br /&gt; &lt;button onClick = &#123;() =&gt; setUser(&#x27;123123&#x27;)&#125;&gt; set name &lt;/button&gt; &lt;/div&gt; ) &#125;) 我们只需要使用 memo 包括函数，就会自动判断该组件依赖值是否改变，如果不改变便不会重新渲染。 如果使用 class 组件该怎么解决重复渲染的问题呢? 熟悉 React 应该了解 PureComponent 和 Component 区别，主要靠钩子函数 shouldComponentUpdate 来进行比对，如果返回 true，则表示重复渲染，如果返回 false 则不会重新进行渲染。 useReducer1const [state, dispatch] = useReducer(reducer, initialArg, init); 该方法为 userState 的替代方案。总共接收三个参数: reducer: 一个 reducer 函数，和以前的 redux 函数的 reducer 相同，主要根据发送过来的 Action 处理 state 数据。 initialArg: 设置 useReducer state 的初始值。 init: 惰性地创建初始 state。其是一个函数，该函数返回初始化后的状态。 如果您 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。这些情况都可以使用 useReducer 来替代 useState。并且使用 useReducer 还能给那些会触发深更新的组件做性能优化。 1234567891011121314151617181920212223242526import React, &#123; useReducer &#125; from &#x27;react&#x27;;const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;add&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;reduce&#x27;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;const Reducer = () =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div&gt; &lt;p&gt;count: &#123;state.count&#125;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;add&#x27;&#125;)&#125;&gt;+&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reduce&#x27;&#125;)&#125;&gt;-&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; );&#125;export default Reducer; 这样就可以使用 useReducer 来替代 userState 进行组件间的 state 管理。如果需要和子组件共享数据，可以将 useReducer 和 useContext 结合起来，这样所有子组件都可以共享这些数据了。 immer既然我们已经开启了useReducer，那么结合immer可以使代码更整洁。由于 reducer 只能返回一个新的 state 并不能在老的 state 上进行修改，但数据格式复杂的时候，这种处理数据的方式会添加许多无用代码，而immer就是为了解决该问题。 123456789101112131415161718192021222324252627282930import React, &#123; useReducer &#125; from &#x27;react&#x27;;import produce from &#x27;immer&#x27;;const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;add&#x27;: return produce(state, (defaultState) =&gt; &#123; defaultState.count = defaultState.count + 1; &#125;); case &#x27;reduce&#x27;: return produce(state, (defaultState) =&gt; &#123; defaultState.count = defaultState.count - 1; &#125;); default: return state; &#125;&#125;const Reducer = () =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div&gt; &lt;p&gt;count: &#123;state.count&#125;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;add&#x27;&#125;)&#125;&gt;+&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reduce&#x27;&#125;)&#125;&gt;-&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; );&#125;export default Reducer; 这样只需我能用produce包裹就能之间操作 state。 use-immer上面说了immer 那么有没有针对hooks设计的该插件呢？有。use-immer 就是为 hooks 封装之后的一个插件。 1234567891011121314151617181920212223242526272829303132333435import React from &#x27;react&#x27;;- import produce from &#x27;immer&#x27;;+ import &#123; useImmerReducer &#125; from &#x27;use-immer&#x27;;const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;add&#x27;:- return produce(state, (defaultState) =&gt; &#123;- defaultState.count = defaultState.count + 1;- &#125;);+ state.count = state.count + 1;+ return; case &#x27;reduce&#x27;:- return produce(state, (defaultState) =&gt; &#123;- defaultState.count = defaultState.count - 1;- &#125;);+ state.count = state.count - 1;+ return; default: return state; &#125;&#125;const Reducer = () =&gt; &#123;- const [state, dispatch] = useImmerReducer(reducer, initialState);+ const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div&gt; &lt;p&gt;count: &#123;state.count&#125;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;add&#x27;&#125;)&#125;&gt;+&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reduce&#x27;&#125;)&#125;&gt;-&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; );&#125;export default Reducer; 只需这样修改useImmerReducer创建的对象我们可以直接在 reducer 中修改 state。这样就和userState很相似，第一个都为 state，第二个为修改 state 的对象。 自定义Hook自定义 hooks 是代码逻辑复用的利器，比如以前组件逻辑复用只能用高阶组件实现，而自定义hooks可以在不添加组件的情况下实现同样的效果。 12345678910111213141516171819202122232425262728import React, &#123; useState &#125; from &#x27;react&#x27;;function useCount(defaultValue)&#123; const [count, setCount] = useState(defaultValue); const addCount = () =&gt; &#123; setCount(count + 1); &#125;; const reduceCount = () =&gt; &#123; setCount(count - 1); &#125;; return [ count, &#123; addCount, reduceCount &#125; ]&#125;const Reducer = () =&gt; &#123; const [count, setCount] = useCount(0); return ( &lt;div&gt; &lt;p&gt;count: &#123;count&#125;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; setCount.addCount()&#125;&gt;+&lt;/button&gt;&lt;/p&gt; &lt;p&gt;&lt;button onClick=&#123;() =&gt; setCount.reduceCount()&#125;&gt;-&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; );&#125;export default Reducer;","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"hooks","slug":"hooks","permalink":"https://www.bipch.cn/tags/hooks/"}]},{"title":"数组常见操作","slug":"web/JavaScript/数组常见操作","date":"2020-02-22T06:27:39.000Z","updated":"2021-03-07T07:58:56.367Z","comments":true,"path":"javascript-array-operation/","link":"","permalink":"https://www.bipch.cn/javascript-array-operation/","excerpt":"数组在 JavaScript 中很常见，下面简单叙述下数组中经常使用的一些方法，方便以后进行使用。","text":"数组在 JavaScript 中很常见，下面简单叙述下数组中经常使用的一些方法，方便以后进行使用。 去重LodashLodash是一款很常用的 JavaScript 工具库，里面封装了很多常见的方法，我们可以直接调用其uniq方法进行去重操作： 1_.uniq([2, 1, 2]); 会返回去重之后的数组。 SetES6 也提出了一些数组相关的数据结果，Set 便是一种数组类型的结构，其特点是 Set 中的数据不会重复，如果重复添加会自动去重。例如： 1234let list = [1, 2, 1, 4, 8, 4];let uniqList = new Set(list);console.log(Array.from(uniqList)); 这样将数组直接传给 Set 即可，去重之后使用Array.from转换回数组即可。 双重 for 循环 + splice当然除了上面别的库提供的，我们也可以自己封装，这样会更灵活： 12345678910111213function unique(arr) &#123; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; for (var j = i + 1, len = arr.length; j &lt; len; j++) &#123; if (arr[i] === arr[j]) &#123; arr.splice(j, 1); // 一项数据被删除，长度和下标需要重新计算 j--; len--; &#125; &#125; &#125; return arr;&#125; 这样也能实现去重。 indexOf最容易理解的一个方法，实现起来也很简单： 12345678910function unique(arr) &#123; var arr1 = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; if (arr1.indexOf(arr[i]) === -1) &#123; arr1.push(arr[i]); &#125; &#125; return arr1;&#125; 这样利用新定义的数组，实现数据的去重。 多维转一维数组Lodash可以直接调用其flattenDepth便可展开数组： 1234let list = [1, 2,[3, 4, [5, &quot;ad&quot;, [&quot;cd&quot;,[&#x27;12&#x27;,32,[&#x27;cc&#x27;,13]], 5], 9]]];// 展开层数，Infinty 为全部展开console.log(_.flattenDepth(list, Infinity)); 不仅可以展开数组，还定义了展开数组的层数。 FlatES6 为数组提供的，用于展开数组的方法： 1234let list = [1, 2,[3, 4, [5, &quot;ad&quot;, [&quot;cd&quot;,[&#x27;12&#x27;,32,[&#x27;cc&#x27;,13]], 5], 9]]];// 展开层数，Infinty 为全部展开console.log(list.flat(Infinity)); 使用起来也是非常的方便。 递归除了上面库封装的，我们也可以自己封装更灵活的： 12345678910111213function fun(array, newArr = []) &#123; for (var i = 0; i &lt; array.length; i++) &#123; // 如果是数组，递归展开 if (Array.isArray(array[i])) &#123; fun(array[i], newArr); &#125; else &#123; // 最终数组 newArr.push(array[i]); &#125; &#125; return newArr&#125;console.log(fun([1, [2, 3], [3, 2, [1, 6, [3, 5, &#x27;3&#x27;]],&#x27;你好&#x27;,&#123;a:1,b:2&#125;]])); 这种方式递归也可以展开数组。 ReduceES6 中提供的数组的方法，主要用于方便数组累计的操作，用于展开数组我们可以这样写： 123456var fun = (arr) =&gt; arr.reduce((prev, curr) =&gt; &#123; if (Array.isArray(curr)) &#123; return prev.concat(...fun(curr)); &#125; return prev.concat(curr);&#125;, []);","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"},{"name":"Array","slug":"Array","permalink":"https://www.bipch.cn/tags/Array/"}]},{"title":"redux-action","slug":"web/React/Redux/redux-action","date":"2020-02-01T02:39:18.000Z","updated":"2021-03-07T12:35:15.295Z","comments":true,"path":"react-redux-action/","link":"","permalink":"https://www.bipch.cn/react-redux-action/","excerpt":"虽然 react-redux 非常的强大，但是发送和处理 action，需要很多的冗余代码，如果项目过多冗余代码肯定会对打包和运行速度有所影响，这时我们便要对其代码进行简写和封装，为了避免重复的轮子，一般需要网上进行查找，而 redux-action 便可以很好的对 action 进行代码的简写。","text":"虽然 react-redux 非常的强大，但是发送和处理 action，需要很多的冗余代码，如果项目过多冗余代码肯定会对打包和运行速度有所影响，这时我们便要对其代码进行简写和封装，为了避免重复的轮子，一般需要网上进行查找，而 redux-action 便可以很好的对 action 进行代码的简写。 传统的Redux为了更方便其对 redux 的封装，我们将其和原本的代码进行比较。 默认的 Redux 代码创建 actions： 123456export const addGame = (game) =&gt; &#123; return &#123; type: &#x27;ADD_GAME&#x27;, game &#125;&#125;; 创建 reducer： 12345678910111213const gameList = [];const gameReducer = (state = gameList, action) =&gt; &#123; switch (action.type) &#123; case &#x27;ADD_GAME&#x27;: return [ ...state, action.game ]; default: return state; &#125;&#125;;export default gameReducer; 组件中进行调用： 12345678910111213141516171819202122import React from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; addGame &#125; from &#x27;./actions&#x27;;import AddGame from &#x27;./components/addGame&#x27;;/** * 使用 */class PageMain extends React.Component &#123; render() &#123; return ( &lt;AddGame addGame=&#123;this.props.addGame&#125; /&gt; ); &#125;&#125;export default connect((state) =&gt; &#123; return &#123; gameList: state.game, &#125;;&#125;, &#123; addGame: addGame,&#125;)(PageMain); 这样就完成调用了，子组件使用的时候调用父组件的 addGame 方法即可。 使用 redux-action 处理 action 与 reducerredux-action 主要依靠提供的 createAction、handleAction 完成工作。我们可以依靠 createAction 来帮助我们进行对象的创建： 12345import &#123; createAction &#125; from &#x27;redux-actions&#x27;;export const addGame = createAction(&#x27;ADD_GAME&#x27;, game =&gt; &#123; return game;&#125;); 处理的时候也可以借助 handleAction 进行处理，防止出现 switch 等冗余的代码： 123456789101112import &#123; handleAction &#125; from &#x27;redux-actions&#x27;;import &#123;addGame&#125; from &#x27;./actions&#x27;;const gameList = [];const gameReducer = handleAction(&#x27;ADD_GAME&#x27;, (state, action) =&gt; &#123; return &#123; ...state, action.game &#125;;&#125;, gameList);export default gameReducer; 使用的方式和基础的一样，都需要通过 concat 高阶组件进行连接。主要是要熟悉 createAction、handleAction 两个API的用法： createAction: 创建一个 action 工厂的操作，主要用于返回一个 action 工厂。参数一：action 的 type。参数二：用于传递一些参数，方便 reducer 对数据进行处理。 handleAction: 用于处理一些 action 请求，返回一个 reducer。参数一：需要处理的 action type。参数二：reducer 处理 store 的函数。参数三：用于初始化的 state 。 createActions 与 handleActions上述操作只能创建或处理一条 action 。而项目不可能只有一条 action，redux-action 不可能不处理这种情况，所以 redux-action 提供了 createActions 与 handleActions 用来处理多条 action。使用createActions创建 action： 1234567import &#123; createActions &#125; from &#x27;redux-actions&#x27;;export default createActions(&#123; [&#x27;ADD_GAME&#x27;]: game =&gt; &#123; return game; &#125;&#125;); 使用handleActions创建 reducers： 123456789101112import &#123; handleActions &#125; from &#x27;redux-actions&#x27;;const gameList = [];const gameReducer = handleActions(&#123; [&#x27;ADD_GAME&#x27;]: (state, action) =&gt; &#123; return &#123; ...state, action.game &#125;; &#125;&#125;, gameList);export default gameReducer; 然后在使用的时候和以前一样调用即可： 12345678910import actions from &#x27;./actions&#x27;;import &#123; addGame &#125; from &#x27;./actions&#x27;;export default connect((state) =&gt; &#123; return &#123; gameList: state.game &#125;;&#125;, &#123; addGame: actions.addGame&#125;)(...); handleActions 返回一个对象，对象针对每个 action 创建了属于自己一些属性，使用的时候下划线去掉，然后采用驼峰式命名。而 handleActions 仍然返回一个 reducer 函数。 总结redux-action 简写了 redux 发送和处理 action 的操作，并没有引入特别的一些语法和概念，如果项目中 action 和 reducer 冗余代码过多，可以考虑使用其减少代码的书写量。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://www.bipch.cn/tags/Redux/"}]},{"title":"react-redux","slug":"web/React/Redux/react-redux","date":"2020-01-28T04:57:53.000Z","updated":"2021-03-07T12:34:26.071Z","comments":true,"path":"react-redux/","link":"","permalink":"https://www.bipch.cn/react-redux/","excerpt":"由于在 React 中数据流都是单向的，即只能父组件 -&gt; 子组件，但是开发过程中单向数据流面临着很多问题，所以需要一个框架为我们管理项目的数据流，Redux 便出现了，其主要目的便是管理项目中的数据流。但是我们也有明白 React 项目并不是一定要用 Redux、而 Redux 也不一定要在React 上使用。","text":"由于在 React 中数据流都是单向的，即只能父组件 -&gt; 子组件，但是开发过程中单向数据流面临着很多问题，所以需要一个框架为我们管理项目的数据流，Redux 便出现了，其主要目的便是管理项目中的数据流。但是我们也有明白 React 项目并不是一定要用 Redux、而 Redux 也不一定要在React 上使用。 你可能不需要它这一点官网说的很清楚，Redux 只是一个很好的项目数据流管理工具，但不是非用不可。因为如果不设计到过多的数据需要维护，那么只用 React 就足够了，就算有很多状态需要我们维护，我们也可以使用 Mobx。换句话说如果 UI 层很简单，或者没有太多的数据交互那么便可以放弃使用 Redux，否则只会增加项目难度。但是如果出现下面情况，我们可以考虑进行使用： 一些组件的数据需要共享给其它组件。 一些值比较重要，需要在任何组件都可以访问到。 一个组件需要改变其它组件的状态。 出现这种情况，我们可以考虑使用 Redux 进行状的管理。 三大原则Redux 可以用这三个基本原则来描述： 单一数据源：整个项目有且只有一个Store。 State是只读的：唯一改变State的方法就是触发action，action是用来描述发生事件的普通对象。 使用纯函数进行修改：Reducer 根据 action 覆盖 state。Reducer 必须是一个纯函数，它接收先前的 state 和 action，并返回新的 state。APIStore主要用于维护应用中的所有的 state树 的对象，改变其的唯一方法只能依靠 dispatch 发送 action 对象。但有一点需要注意：整个项目有且只能有一个 Store，创建时需要通过 createStore 方法，生成 Store：12import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(reducer); 很简单的方式，但是项目中不可能只有 1 个 Reducer，那么如果有多个 Reducer 怎么办呢？这就需要 React 提供的另外一个方法 combineReducers 来拆分 Reducer：123456import &#123;combineReducers&#125; from &#x27;redux&#x27;;import user from &#x27;./user&#x27;;export default combineReducers(&#123; user&#125;) 很简单便将 Reducer 进行了拆分，使用的时候，添加 key 进行访问即可。 Statestate 是项目的主要数据，我们可以通过 store.getState() 来获取项目中的 state 状态树。它与 reducer 的返回值相同。调用方式如下： 1234import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(reducer);const state = store.getState(); 调用也很简单。 Action准确来说它并不是特定的格式，只是大多数这么写，便默认了其默认的格式。其主要用于描述动作类型。基本格式如下所示： 1234const action = &#123; type: &#x27;ADD_TODO&#x27;, data: &#x27;&#x27;&#125;; 也就是一个普通的 JavaScript 的对象。Reducer 会判断类型，然后根据参数，返回新的 state 进行数据的覆盖。 store.dispatchstore.dispatch() 项目中发送 action 的唯一途径： 1234567import &#123; createStore &#125; from &#x27;redux&#x27;;const store = createStore(reducer);store.dispatch(&#123; type: &#x27;ADD_TODO&#x27;, data: &#x27;&#x27;&#125;); 可以很简单的将一个 action 发送出去。 ReducerRedux 接收到新的 Action 以后，经过 Reducer 处理之后，返回新的 state，覆盖项目的 store，形成行动 store，最后通知界面视图进行更新。基本格式如下： 12345const defaultState = &#123;&#125;;const reducer = function (state = defaultState, action) &#123; // ... return state;&#125;; 基本格式如上，Reducer 会使用 switch 判断发送的 action 的 type，执行不同的逻辑，而返回不同的 state。 结合 React上面介绍了 Redux 的简单 API，但是还没有和 React 结合使用，和 React 结合其实很简单，但是还需要借助 react-redux 来帮助。项目整理完成后，第一步创建 Store，这是项目的唯一数据源： 123456import &#123;combineReducers&#125; from &#x27;redux&#x27;;import user from &#x27;./user&#x27;;export default combineReducers(&#123; user&#125;) 这样 Store 便创建完成了，然后我们需要将数据注入到组件中，默认如下： 12345678910...import Store from &#x27;./reducer/store&#x27;;import &#123;Provider&#125; from &#x27;react-redux&#x27;;ReactDOM.render( &lt;Provider store=&#123;Store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; , document.getElementById(&#x27;root&#x27;)); 这样便通过 react-redux 提供的组件，将 Store 成功的注入。数据成功注入后需要在相应的组件中进行调用，主要依靠 react-redux 提供的 connect 高阶函数 1234567891011121314151617181920...import &#123;connect&#125; from &#x27;react-redux&#x27;;class App extends React.Component&#123; render()&#123; return (....) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; ... &#125;&#125;;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; .... &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(App); 这样在组件中不论是 state 中定义的变量，还是 dispatch 都能操纵了。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://www.bipch.cn/tags/Redux/"}]},{"title":"react-context","slug":"web/React/react-context","date":"2020-01-14T06:38:41.000Z","updated":"2021-03-07T12:12:18.310Z","comments":true,"path":"react-context/","link":"","permalink":"https://www.bipch.cn/react-context/","excerpt":"由于 React 的数据流都是 单向传递 的，只能由父级组件定义数据子组件使用，但是只能嵌套一层，如果涉及到多层嵌套，便只能层层向下传递。而 Context 的存在提供了另外一种数据的传输方式，可以在父级定义上下文对象，所有子组件都能获取到上下文对象，从而避免了在每一个层级手动的传递 props 属性。","text":"由于 React 的数据流都是 单向传递 的，只能由父级组件定义数据子组件使用，但是只能嵌套一层，如果涉及到多层嵌套，便只能层层向下传递。而 Context 的存在提供了另外一种数据的传输方式，可以在父级定义上下文对象，所有子组件都能获取到上下文对象，从而避免了在每一个层级手动的传递 props 属性。 API我们可以看下官网提供的 资料，其为我们提供了很多常用的方法。 React.createContext我们需要在父组件中使用 React.createContext(defaultValue) 方法创建 Context对象，defaultValue 表示默认需要共享的数据。 123import React from &#x27;react&#x27;;// 通过createContext方法创建const &#123; Provider, Consumer &#125; = React.createContext(); Context.ProviderContext 所返回的对象中包含一个 Provider 组件，该组件包含一个 value 属性，该值可以被所有子组件直接获取，这样就可以避免 props 向深层级的组件传递的问题了，并且当 Context 的值放生变化的时候组件会自动重新render。 123&lt;Provider value=&#123;/*共享的数据*/&#125;&gt; &#123; this.props.children &#125;&lt;/Provider&gt; 简单来说：该组件相当于一个生产者，供所有子组件使用。 Context.ConsumerConsumer 组件可以帮助我们获取 Provider 里的数据，Consumer 组件的子组件是一个函数，这个函数的第一个参数就是共享的值，函数的返回值必须是一个 React元素。 123&lt;Consumer&gt; &#123; (state) =&gt; &lt;... /&gt; &#125;&lt;/Consumer&gt; 我们可以简单的理解它为消费者，我们可以借此来获取 Provider 中的数据。 结合 React上面简单的介绍了一些常用的 API，下面主要还是和 React 简单的结合一起使用。 整理项目首先在项目中新建一个 contexts 文件夹，里面放入我们需要的 Context，这样更适合我们维护项目。 创建一个简单的Context创建一个简单的 Context，方便后面继续使用： 1234567891011121314151617181920import React, &#123; Component &#125; from &#x27;react&#x27;;// 导出 Context 方便后面调用其 APIexport const UserContext = React.createContext();// 父组件使用export class UserProvider extends Component &#123; state = &#123; user: &#123; name: &#x27;blog&#x27;, age: 23 &#125; &#125;; render() &#123; return ( &lt;UserContext.Provider value=&#123;this.state.user&#125;&gt; &#123; this.props.children &#125; &lt;/UserContext.Provider&gt; ); &#125;&#125; 子元素获取数据任何子元素获取上下文对象中的数据，必须依靠 Consumer 组件： 123456789101112import App from &#x27;./App&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import * as serviceWorker from &#x27;./serviceWorker&#x27;;import &#123; UserContext &#125; from &#x27;./contexs/userContext&#x27;;ReactDOM.render( &lt;UserContext.Consumer&gt; // 通过这种方法传递给需要的子组件 &#123;(&#123;user&#125;) =&gt; &lt;App user=&#123;user&#125; /&gt;&#125; &lt;/UserContext.Consumer&gt;, document.getElementById(&#x27;root&#x27;)); 这样我们就获取到了 Context 的数据，并通过 props 传递给子组件，子组件通过 props 获取即可。 总结所以结合上面我们可以得出下面步骤： 就是需要创建一个一个 Context。 创建 Provider，提供需要共享的数据，剩余交给 Context。 子组件通过 Consumer 进行访问 Context 管理的数据，但是需要注意函数的返回值必须是一个 React元素。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"}]},{"title":"webpack 4.0","slug":"web/webpack/webpack 4.0","date":"2020-01-12T05:25:01.000Z","updated":"2021-03-02T04:33:04.807Z","comments":true,"path":"webpack4/","link":"","permalink":"https://www.bipch.cn/webpack4/","excerpt":"随着前端的开发复杂度越来越庞大，简单的前端开发已经不满足我们需求了，一些代码浏览器并不能进行识别(如jsx、es6、vue…)，只有编译成浏览器能识别的才能使用，那么如果前端开发不使用打包工具，开发效率会大幅下降。而在众多的工具中 webpack 便是较为流行的前端构建工具。webpack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。","text":"随着前端的开发复杂度越来越庞大，简单的前端开发已经不满足我们需求了，一些代码浏览器并不能进行识别(如jsx、es6、vue…)，只有编译成浏览器能识别的才能使用，那么如果前端开发不使用打包工具，开发效率会大幅下降。而在众多的工具中 webpack 便是较为流行的前端构建工具。webpack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 webpack-cli自从 webpack 4.0+ 之后，我们使用 webpack 还需要安装 webpack-cli 用于提供 webpack 的命令行工具。使用下面的命令进行安装： 1npm install --save-dev webpack webpack-cli 也可以进行全局安装如下： 1npm install -global webpack 可以使用 webpack -v 查看版本。全局安装完成后，可以新建一个文件 /src/index.js: 1234let global = () =&gt; &#123; console.log(&#x27;hello word&#x27;);&#125;global(); 一个简单的 es6 语法，下面使用 webpack 打包，执行 webpack 命令，可以看到打包的一些信息，默认webpack 会打包 /src/index.js 文件，输出到 /dist/main.js 文件，当然我们也可以自己配置，例如执行下面的命令 webpack ./src/index.js –output ./dist/index.js 便能把指定的文件打包到指定路径。 官网并不太推荐全局进行安装，全局安装不容易管理和升级项目。我们也可以使用 node_modules/.bin/webpack 指定相应的 webpack 进行打包处理(当然也可以使用npx解决)。 mode告诉webpack打包模式，以便于内置优化。主要有下面几种模式： production：告诉webpack执行生产模式打包，也就是需要把项目发布到服务器上。 development：开发模式，我们本地的调试，需要一些日志插件、浏览器插件等调试工具。 none：退出任何默认优化选项。 我们这些执行进行打包：webpack –mode=development ./src/index.js –output ./dist/index.js scripts由于上方的 webpack 打包命令过长，运行并不好使，我们可以在 package.json 添加配置，执行 npm init -y 初始化，然后再 scripts 属性添加配置： 1234567&#123; ... &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack --mode=development ./src/index.js --output ./dist/index.js&quot; &#125;, ...&#125; 执行下面的命令启动 yarn dev。 webpack.config.js上面都是在启动命令上添加参数，但项目开发最好还是需要config文件配置，而不是启动命令行进行配置。然后我们可以配置启动入口、和输出入口、打包模式等： 12345678910const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &quot;./src/index.js&quot;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &quot;app.bundle.js&quot; &#125;, mode: &#x27;development&#x27;&#125; 这样配置便完成了，然后去掉打包命令的参数： 1234567&#123; ... &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack&quot; &#125;, ...&#125; 即可自动读取config文件，添加打包的配置。 webpack默认的配置文件为 webpack.config.js ，我们也可以使用 webpack –config webpack.config.js 修改配置文件默认路径。 多入口项目有时需要多个入口文件，我们可以修改webpack.config.js文件，用于配置入口文件： 12345678910111213const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#123; app: &#x27;./src/index.js&#x27;, hello: &#x27;./src/hello.js&#x27; &#125;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &quot;[name].bundle.js&quot; &#125;, mode: &#x27;development&#x27;&#125; 入口提供了多个，打包到dits目录[name].bundle.js文件。 [name] 为项目入口文件的name，例如 app：’./src/index.js’ 文件，那么打包输出的便是 app.bundle.js 文件。 Loaderswebpack进行文件编译的主要配置。webpack可以通过对文件类型进行匹配，对匹配到的文件进行相应的 loading 插件处理，比如处理 scss 有 scss-loader、less 有 less-loader、es6 有 babel、css 有 css-loader、vue-loader… babel随着es6越来越火，前端开发也逐渐进行使用，但是浏览器五花八门，有些较好的浏览器开始逐渐识别es6，但是还有一些并不能识别es6，这给前端开发带来许多问题。这时 babel 便出现解决这些问题了，它可以将 es6 代码转换为浏览器可以正常识别的代码，很优雅解决了浏览器不能识别 es6 不能被浏览器识别的问题，并且还可以和webpack进行结合，使项目更加自动化。那么怎么结合呢?我们可以看下webpack的GitHub，提供了和一系列插件结合的方法。babel 通过 babel-loader 和 webpack 进行结合。 babel-loader主要提供了下面几个插件： @babel/core：babel的核心库。 babel-loader：webpack和babel结合需要的插件。 @babel/preset-env：babel 对es6的常用解析插件集合(可以配置按需加载)。 但是安装完成后，根据官网给出的提示复制进 webpack.config.js，发现并没有解析 es6 中的代码，这是为什么呢？经过研究发现 babel 如果要解析特点 es6 代码，需要插件的支持，把es6代码主要分为很多类： @babel/plugin-transform-arrow-functions：箭头函数转换为普通的函数 @babel/plugin-transform-classes： 解析class。 @babel/plugin-proposal-decorators： 解析项目的注解。 … 可以根据自己需求选择所需插件，执行下面命令进行安装： 1yarn add @babel/plugin-transform-arrow-functions 安装完成后，我们添加 babel 配置 .babelrc 文件，但是我们每一个 es6 都这样配置会非常的麻烦，那么有没有一个已经完成的插件，可以将es6语法常用的插件添加进去。肯定有的： @babel/preset-env：将es6常用的语法插件加入到项目中。 我们这么配置即可： 123456&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ], &quot;plugins&quot;: []&#125; 即可将 es6 转换为浏览器能识别的 es5 代码。 @babel/preset-env不是es6所有的语法插件，比如注解插件(@babel/plugin-proposal-decorators)便没有，我们可以根据官网将 debug设置为true来查看具体包含哪有插件。 @babel/polyfill上面已经介绍了 @babel/preset-env 可以将 es6 语法解析为浏览器能识别的 es5 语法，如果我们使用es6箭头函数( =&gt; )，是正常可以转换的，但是如果使用别的es6语法呢？例如： 12345Object.assign(&#123;&#125;)Array.from([1, 2, 3])new Promise(resolve =&gt; console.log(&#x27;promise&#x27;)) 然后将 devtool 设置为 false，方便我们看打包之后的代码，最后惊奇的发现，wdnmd就转换了一个箭头函数，其余的完全复制过来了，老版本浏览器肯定不能识别的，那么该如何解如何形成的、又该如何决、怎么解决呢、怎么使用？ 问题如何形成：形成是因为Babel默认只转换新的JavaScript语法(比如箭头函数)，但是转化不了新的API(Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象)，以及一些定义在全局对象上的方法(Object.assign)都不会转码，所以造成了该问题。 如何解决：可以使用 polyfill 来解决，它的解决方式便是在window上定义全局属性，以后调用便是调用window上的方法，这样便解决这个问题。 我们要使用 polyfill 使它在源代码之前运行，让他成为一个 dependency(生成环境) 的依赖。首先安装依赖：1npm install --save @babel/polyfill 安装成功后，有两种使用方式： 在 webpack.config.js 定义打包配置： 1234...module.exports = &#123; entry: [&quot;@babel/polyfill&quot;, &#x27;./src/index.js&#x27;],&#125; 修改 .babelrc 文件 babel 打包方式： 12345...&#123; &quot;presets&quot;: [[&quot;@babel/preset-env&quot;, &#123; &quot;debug&quot;: true, &quot;useBuiltIns&quot;: &quot;entry&quot; &#125;]], &quot;plugins&quot;: []&#125; 配置useBuiltIns属性便可，然后在需要的文件引入 import “@babel/polyfill” 这样便完成了。但是由于每个文件都需要引入 @babel/polyfill 并且打包面积过大，它是将所有的依赖都加载进去，这样我们项目便会过大，如果需要根据自己的需求进行按需加载该如何配置呢？很简单只需将 useBuiltIns 属性设置为 usage 即可(设置为usage后，界面需要引入@babel/polyfill 依赖)，这样便在打包前添加了 @babel/polyfill 处理文件。 @babel/runtime上面说了 @babel/polyfill 解决babel打包的一些问题，但是它解决问题的同时也代码很多的问题例如： 全局变量污染：由于它解决问题是在全局变量上定义属性，很容易造成全局变量的污染，比如它在全局变量定义了一个Promise，而一些其他的库也需要定义Promise，这便造成了冲突。 修改全局对实例的方法：由于它为了解决全局实例问题(Array.form、Object.assign)，它是之间在全局实例定义方法这也可能造成以后的代码冲突。 总体来说便是 @babel/polyfill 可以解决我们的问题，但是其侵入性过强。那么我们还有别的更优的选择吗? @babel/runtime 便可以解决这样的问题，至于它如何解决并和@babel/polyfill的差异可以看下知乎大牛的文章。这里简单说下如何使用。首先安装: 1npm install --save @babel/runtime 但是为了避免一些代码的重复(代码可能会有多个文件)我们还需要搭配一个插件: 1npm install --save-dev @babel/plugin-transform-runtime 然后修改 .babelrc 文件: 1234567891011121314&#123; &quot;presets&quot;: [[&#x27;@babel/preset-env&#x27;, &#123; &quot;debug&quot;: true &#125;]], &quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;corejs&quot;: 2, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125; ] ]&#125; 发现还需要安装@babel/runtime-corejs2主要添加项目对Promise的打包支持: 1npm install --save @babel/runtime-corejs2 最后打包项目，果然全局变量没有那些属性了，并且是按需加载。 css-loader &amp; style-loadercss样式是前端开发不可缺少的文件，但是一些css样式需要添加浏览器内核前缀，例如-moz-、-webkit-、-o-…这些前缀都非常统一，那么我们可以不可以使用一个插件让其自动给某些属性添加浏览器前缀，并且还可以为我们压缩 css 空格，减少代码体积等，那么 css-loader 和 style-loader 会是个不错的选择。执行下面的命令安装： 1npm install --save-dev style-loader css-loader 然后添加webpack配置: 12345678910111213...module.exports = &#123; ... module: &#123; rules: [ ..., &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125;] &#125;, ...&#125; 注意执行顺序为 从右到左，也就是 css-loader 处理后交给 style-loader。 sass-loader &amp; less-loader现在前端预编译样式也是使用者越来越多，但是浏览器并不支持这种语言，也需要webpack插件sass-loader 和 less-loader 进行相应的解析，它们可以把 scss 或 less 解析为css。这里只介绍less如何编译，至于scss其实方式一样，只是依赖插件不同。安装插件： 1npm install less less-loader --save-dev 成功后，设置webpack配置即可： 12345678910111213...module.exports = &#123; ... module: &#123; rules: [ ..., &#123; test: /\\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;] &#125;] &#125;, ...&#125; 注意 webpack 执行顺序为从右向左，也就是 less-loader -&gt; css-loader -&gt; style-loader。顺序不要搞反了。 file-loader &amp; url-loader主要用于处理项目中出现的文件，主要靠 url-loader 和 file-loader 处理项目的文件，这里已 file-loader 为例，首先安装： 1npm install file-loader --save-dev 成功后，设置webpack配置即可： 1234567891011121314151617...module.exports = &#123; ... module: &#123; rules: [ ..., &#123; test: /\\.(png|jpe?g|gif)$/i, use: [ &#123; loader: &#x27;file-loader&#x27;, &#125;, ], &#125;] &#125;, ...&#125; image-webpack-loader项目中的图片有时候大小过大，打包发布后在生产环境下并不太好的加载，这时我们便需要在打包时压缩一下项目的图片文件。执行下面的命令安装： 1npm install image-webpack-loader --save-dev 完成后，修改webpack配置文件： 123456789101112131415161718192021222324...module.exports = &#123; ... module: &#123; rules: [ ..., &#123; test: /\\.(png|jpe?g|gif|svg)$/, use: [ &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[ext]&#x27;, outputPath: &#x27;images/&#x27; &#125; &#125;, &#123; loader: &#x27;image-webpack-loader&#x27; &#125; ] &#125;] &#125;, ...&#125; plugins上面介绍了 webpack 的 Loaders 主要用于解析项目的文件，将一些浏览器不支持的语法(less、scss、es6、jsx、vue…)解析为浏览器可以识别的，而 plugins 则可以给指定文件添加一些拓展。 html-webpack-pluginhtml 的拓展插件，可以拓展html的一些功能。例如：我们一般 js 和 css 都是添加 hash 防止浏览器缓存，造成 js 和 css 修改而浏览器不刷新的问题。但是添加 hash 后文件名称一直改变，所以我们需要使用html-webpack-plugin根据一个模板文件动态引入 js 和 css 文件。首先只需下面命令进行安装： 1yarn add --dev html-webpack-plugin 成功后，在webpack进行配置： 12345678910111213...const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; ... plugins: [ ... new HtmlWebpackPlugin(&#123; filename: &#x27;./index.html&#x27;, template: &#x27;./public/index.html&#x27; &#125;) ]&#125; 很简单根据模板引入所需文件，它还有其他的一些配置，详细可以看下github上的介绍。 也可以进行多界面的配置，可以靠 chunks 配置多入口，如果多个界面入口，可以使用该配置，较多用于项目前端一个入口、后端一个入口，最好不要太多的界面入口。 mini-css-extract-plugin应为 webpack 处理样式默认都是设置到了 style 上，但是项目样式一般都提取到一些样式文件(css)中，这些既有利于代码复用，也有利于调整项目的样式。我们可以使用 mini-css-extract-plugin 提取 style css 到一个文件中。执行下面的命令进行安装： 1npm install --save-dev mini-css-extract-plugin 然后再webpack添加配置： 123456789101112131415161718192021222324......const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const devMode = process.env.NODE_ENV !== &#x27;production&#x27;;module.exports = &#123; ... module: &#123; rules: [...,&#123; test: /\\.css$/, use: [ devMode ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader, &#x27;css-loader&#x27; ] &#125;] &#125;, plugins: [ ... new MiniCssExtractPlugin(&#123; filename: devMode ? &#x27;[name].css&#x27; : &#x27;[name].[hash].css&#x27;, chunkFilename: devMode ? &#x27;[id].css&#x27; : &#x27;[id].[hash].css&#x27;, &#125;) ]&#125; 这样便根据条件进行判断，开发模式下继续使用 style-loader 不会生成css文件，生成环境下会使用 mini-css-extract-plugin 提取 style 到一些文件中。 webpack-dev-server项目的开发过程中，不能像上面代码，没修改一下都需要重新打包下，但是真实开发环境中需要开启服务，并监听代码的修改，一旦修改便自动刷新界面。这样便能大大的缩减项目的开发时间。执行下面的命令安装： 1npm install webpack-dev-server --save-dev 然后修改启动命令： 12345678...&#123; ... &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;npx webpack-dev-server&quot; &#125;, ...&#125; 我们还可以添加一下具体的配置，详细可以看下github。 clean-webpack-plugin因为项目文件打包多半文件名打包之后名称含有hash值，这样一旦打包次数过多，会堆积许多hash文件，我们需要每次打包前令项目自己清空文件夹，然后放入打包之后的内容。执行下面的命令安装： 1npm install --save-dev clean-webpack-plugin 然后修改启动命令： 12345678910111213...const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;);let pathsToClean = [ &#x27;dist&#x27;];module.exports = &#123; ... plugins: [ ... new CleanWebpackPlugin(), ]&#125; 我们还可以添加一下具体的配置，详细可以看下github。 webpackbarwebpack打包时生成进度条，方便查看webpack打包进度和打包时间。执行下面命令安装： 1npm install webpackbar -D 修改webpack配置： 12345678910...const WebpackBar = require(&#x27;webpackbar&#x27;);module.exports = &#123; ... plugins: [ ... new WebpackBar() ]&#125; devtool主要用于项目的调试，可以在找错的时候给我们一些帮助(可以为我们生成 sourcemap，非常在开发模式下找出错误)。也就是设置项目打包之后的代码。它的值有下面很多种，具体用法可以看官网的介绍，它的配置方式很简单，只需在webpack.config.js添加： 123456...module.exports = &#123; ... devtool: ... ...&#125;","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.bipch.cn/tags/webpack/"}]},{"title":"call、apply、bind区别","slug":"web/JavaScript/call、apply、bind","date":"2019-12-13T03:48:10.000Z","updated":"2021-03-07T07:10:20.425Z","comments":true,"path":"call-apply-bind/","link":"","permalink":"https://www.bipch.cn/call-apply-bind/","excerpt":"call、apply、bind 三个函数在 JS 中都可以用来修改函数的上下文对象，并且三个方法作用相同，但使用方式却各不相同。那么它们的区别是什么？以及怎么实现的呢？","text":"call、apply、bind 三个函数在 JS 中都可以用来修改函数的上下文对象，并且三个方法作用相同，但使用方式却各不相同。那么它们的区别是什么？以及怎么实现的呢？ 相同和区别相同它们都是用来改变函数的上下文，也就是this指向。 不同fn.call：立即调用，返回函数指向结果，this指向第一个参数，后面可以有更多的参数，并且这些都是 fn 函数的参数。fn.apply：立即调用，返回函数指向结果，this指向第一个参数，第二个参数是个数组，这个数组内容是 fn 函数的参数。fn.bind：不会立即调用，而是返回一个绑定后的新函数，一个典型的 柯里化 函数。 柯里化如果一个函数接收多个参数，我们可以把这个函数转化为每次只接收一部分参数的多次调用形式，这就是函数的柯里化。听着定义很难懂，但是我们看代码就很简单了。首先如果我们有下面的函数： 1function add(a, b, c)&#123;return a + b + c&#125;; 我们可以将上面函数柯里化，那么函数定义为： 12345678910// 普通的函数定义function add(a)&#123; return function(b, c)&#123; return a + b + c; &#125;&#125;// 也可以使用es6方式定义const add = (a) =&gt; (b, c) =&gt; (a + b + c);// 使用add(1)(2, 3); 项目中还是有些常用的，具体就不介绍了，我们可以总结下柯里化的 4 种功能： 性能优化。 代码复用。 使代码清晰，更难以理解。 扩展JS能力。 callcall 函数接收第一个参数作为上下文，其余参数传递给需要执行的函数。那么我们在调用 call 到底发生了什么： 改变 this 的指向，指向第一个参数。 执行相应的函数。 我们把上面执行逻辑转换为代码： 12345678910111213// call 的 “this” 默认值为 windowFunction.prototype.myCall = function(thisObj = window)&#123; // 这里的 this 指向 调用的函数(也就是bar) thisObj.fn = this; // 处理 arguments 参数，去除第一个(第一个参数为 this) let arg = [...arguments].slice(1); // 把参数传递给，调用的函数，并修改 this 的指向 let result = thisObj.fn(...arg); // 已经构建完成，删除多余的参数 delete thisObj.fn; // 返回修改后的对象 return result;&#125; 我们使用代码进行验证： 12345678910let foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name); console.log(age); console.log(this.value);&#125;// 最后得出下面的输出: kevin 18 1bar.myCall(foo, &#x27;kevin&#x27;, 18); 完成 call 函数。 apply这个和上面的 call 非常的相似，只是参数的传递并不相同： 123456789101112// call 的 “this” 默认值为 window，arr 为参数列表Function.prototype.myApply = function(thisObj = window, arr)&#123; thisObj.fn = this; let result; if(!arr)&#123; result = context.fn(); &#125; else &#123; result = context.fn(...arr); &#125; delete context.fn; return result;&#125; 这样也可以实现 apply 和上面的 call 及其相似，只是多了一个参数 arr。 bind这个和上面的两个(call、bind)都不相同，其创建后不会第一时间执行，还需要用户手动调用： 12345678910111213141516171819Function.prototype.myBind = function(thisObj)&#123; // 只有函数类型才能继续执行 if(typeof this !== &#x27;function&#x27;)&#123; throw new TypeError(&#x27;must be a function&#x27;); &#125; // 这里的 this 指向 调用的函数 let self = this; // 参数，去掉第一个 this let argsArr = [...arguments].slice(1); // 注意，bind 和 call 参数相似，但是 bind 返回一个函数 return function()&#123; // 第二次传递的参数 let bindFuncArg = [...arguments] // 因为是执行了两次，需要进行数据合并 let totalArgs = argsArr.concat(bindFuncArg); // 借助上面定义的 apply 实现 return self.apply(thisObj, totalArgs) &#125;&#125; 上面便借助了 call 实现了 bind。 总结call、apply、bing 各有各的特点，虽然功能相似但却各有各的长处，如果正常使用还是 call 比较的常用，当然这也是依靠个人的编程习惯。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"},{"name":"柯里化","slug":"柯里化","permalink":"https://www.bipch.cn/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"}]},{"title":"函数柯里化","slug":"web/JavaScript/JS函数柯里化","date":"2019-10-27T07:36:34.000Z","updated":"2021-03-07T07:20:13.213Z","comments":true,"path":"js-currying/","link":"","permalink":"https://www.bipch.cn/js-currying/","excerpt":"函数的柯里化其实在开发中很常用，其能为我们节约开发的很多的代码，也可以更灵活的封装函数，或许代码中使用过，但并不知道其是柯里化。","text":"函数的柯里化其实在开发中很常用，其能为我们节约开发的很多的代码，也可以更灵活的封装函数，或许代码中使用过，但并不知道其是柯里化。 柯里化是什么柯里化(Currying)：就是把接收多个参数的函数变换成接收第一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 定义非常的抽象，下面看下简单的一些使用： 12345678// 普通的函数const plus = (a ,b) =&gt; a + b;console.log(plus(1, 3)); // 4// 柯里化后const curryingPlus = a =&gt; b =&gt; a + b;let currying = curryingPlus(1);console.log(currying(3)); // 4 上面两个函数返回值相同的，就是plus函数 a,、b 两个参数，先接收第一个参数，然后返回一个函数去处理b这个参数。这思路就更清晰了，就是只传递一个第一参数来创建它，让它返回一个函数来处理下面的参数。 但是问题来了，这似乎并没有太大的作用，那包装这一层究竟有什么作用呢？那些技术大牛也不会闲着没事包装一层没有用的函数，下面看下Currying怎么使用。 Currying好处参数复用函数的参数复用： 12345678// 普通的正则表达式匹配函数const find = (replace, text) =&gt; replace.test(text);console.log(plus(/a/, &#x27;The best things in life are free!&#x27;)); // true// 柯里化后const curryingFind = replace =&gt; text =&gt; replace.test(text);let currying = curryingFind(/a/);console.log(currying(&#x27;The best things in life are free!&#x27;)); // true 两次结果是一致的，但是柯里化后明显比第一个少定义了一次正则表达式。柯里化先用正则表达式创建一个函数，然后传入字符串给返回函数，这样就少定义正则表达式的代码。 延迟执行柯里化的延迟执行为不断的传入参数，函数不断收集传入的参数，最后在执行函数。例如累加： 1234567891011121314151617function curryingPush()&#123; let list = [...arguments]; const _sum = function () &#123; list = [...list, ...arguments]; if(arguments.length &lt;= 0)&#123; return list.reduce((a, b) =&gt; a + b); &#125;else&#123; return _sum; &#125; &#125;; return _sum;&#125;let currying = curryingPush(1);currying(2);currying(3);console.log(currying()); // 6 上述例子函数不断收集参数，放入list中，直到我们传入空参数结束循环，最后累加我们的list返回相加的值，并结束柯里化的过程。 Function.prototype.bindbind函数在开发过程中很常见。那么看下bind怎么实现的： 1234567Function.prototype.bind = function (context) &#123; var _this = this; var args = Array.prototype.slice.call(arguments, 1); return function() &#123; return _this.apply(context, args) &#125;&#125; 很明显，bind也是通过Currying来实现的。 有趣的问题实现下面的一种结果： 123console.log(add(1, 2, 3)); // 6console.log(add(1)(2, 3)); // 6console.log(add(1)(2)(3)); // 6 这就需要柯里化逐渐收集参数，满足需求后结束函数返回累加。 1234567891011121314151617181920function curryingPush(_sum)&#123; // props_len：需要收集的参数个数；props_list：收集参数列表 let props_len = _sum.length, props_list = []; const _push = function () &#123; props_len = props_len - arguments.length; props_list = [...props_list, ...arguments]; if(props_len &lt;= 0)&#123; props_len = _sum.length; return _sum.apply(undefined, props_list); &#125;else&#123; return _push; &#125; &#125;; return _push;&#125;let sum = (a, b, c) =&gt; a + b + c;let currying = curryingPush(sum);console.log(currying(1, 2, 3)); // 6console.log(currying(1)(2, 3)); // 6console.log(currying(1)(2)(3)); // 6 其实也很简单，也是通过柯里化逐渐收集参数，只是结束条件修改了一些，然后在结束的时候把props_len 拉回最初状态，以便于下次操作。 上述柯里化主要依靠arguments属性来实现，如果使用Es6的箭头函数，切记箭头函数里面无法调用arguments。","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"},{"name":"柯里化","slug":"柯里化","permalink":"https://www.bipch.cn/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"}]},{"title":"JavaScript数字转中文","slug":"web/JavaScript/JavaScript数字转中文","date":"2019-07-26T08:54:51.000Z","updated":"2021-03-07T15:38:47.792Z","comments":true,"path":"js-number-charts/","link":"","permalink":"https://www.bipch.cn/js-number-charts/","excerpt":"JavaScrip 实现将阿拉伯数字转换为中文读法可以使用对需要处理的数据循环监测的方式处理，在开发过程中有可能遇到，这里简单记录下。","text":"JavaScrip 实现将阿拉伯数字转换为中文读法可以使用对需要处理的数据循环监测的方式处理，在开发过程中有可能遇到，这里简单记录下。 阿拉伯转中文中文数字的一些特点： 每个计数数字都跟着一个权位，权位有：十、百、千、万、亿。 以“万”为小节，对应一个节权位，万以下没有节权位。 每个小节内部以“十百千”为权位独立计数。 “十百千”不能连续出现，而“万”和“亿”作为节权位时可以和其他权位连用，如：“二十亿”。 中文判断是否需要添加零： 以10000为小节，小节的结尾即使是0，也不使用零。 小节内两个非0数字之间要使用“零”。 当小节的“千”位是0时（即：1~999），只要不是首小节，都要补“零”。 算法的一些说明： 对“零”的第三个规则，把检测放在循环的最前面并默认为false，可以自然的丢弃最高小节的加零判断。 单个数字转换用数组实现，var chnNumChar = [“零”,”一”,”二”,”三”,”四”,”五”,”六”,”七”,”八”,”九”]。 节权位同样用数组实现，var chnUnitSection = [“”,”万”,”亿”,”万亿”,”亿亿”]。 节内权位同样用数组实现，var chnUnitChar = [“”,”十”,”百”,”千”]。 小数部分转换如下： 12345678910111213function numToChn(num)&#123; var index = num.toString().indexOf(&quot;.&quot;); if(index != -1)&#123; var str = num.toString().slice(index); var a = &quot;点&quot;; for(var i=1;i&lt;str.length;i++)&#123; a += chnNumChar[parseInt(str[i])]; &#125; return a ; &#125;else&#123; return &#x27;&#x27;; &#125;&#125; 节权位转换如下： 123456789101112131415161718192021function sectionToChinese(section)&#123; //str:用来存储转换后的中文，chnstr:最终结果，zero:是否需要补零，count:单位 var str = &#x27;&#x27;, chnstr = &#x27;&#x27;,zero= false,count=0; while(section &gt; 0)&#123; var v = section % 10; // 对数字取余10，得到的数即为个位数 if(v === 0)&#123; // 如果数字为零，则对字符串进行补零 if(zero)&#123; zero = false; // 如果遇到连续多次取余都是0，那么只需补一个零即可 chnstr = chnNumChar[v] + chnstr; &#125; &#125;else&#123; zero = true; // 第一次取余之后，如果再次取余为零，则需要补零 str = chnNumChar[v]; str += chnUnitChar[count]; chnstr = str + chnstr; &#125; count++; section = Math.floor(section/10); &#125; return chnstr;&#125; 转换的主函数如下： 123456789101112131415161718192021222324252627282930313233function TransformToChinese(num)&#123; // 小数部分 var a = numToChn(num); //舍入 num = Math.floor(num); //用来计算单位 var unitPos = 0; //strIns:权位转换的结果，chnStr:最终结果 var strIns = &#x27;&#x27;, chnStr = &#x27;&#x27;; //是否需要补零 var needZero = false; if(num === 0)&#123; return chnNumChar[0]; &#125; while(num &gt; 0)&#123; //取于得到最后一个节权位 var section = num % 10000; if(needZero)&#123; chnStr = chnNumChar[0] + chnStr; &#125; strIns = sectionToChinese(section); //用来设置节权位单位，如果节权位全是0则不需要添加单位比如100000(十万) strIns += (section !== 0) ? chnUnitSection[unitPos] : chnUnitSection[0]; //拼接最终结果 chnStr = strIns + chnStr; //用来判断是否需要进行补零 needZero = (section &lt; 1000) &amp;&amp; (section &gt; 0); //删除这个节权位 num = Math.floor(num / 10000); unitPos++; &#125; return chnStr+a;&#125; 中文转阿拉伯算法的一些说明： 将中文权位转换成10的位数。 对每个权位依次转换成位数并求和。 零可以直接忽略即可。 中文转阿拉伯需要下面变量： 123456789101112131415161718192021//定义数字转换变量var chnNumChar = &#123; 零:0, 一:1, 二:2, 三:3, 四:4, 五:5, 六:6, 七:7, 八:8, 九:9&#125;;//中文权位转换成10的位数及节权标志var chnNameValue = &#123; 十:&#123;value:10, secUnit:false&#125;, 百:&#123;value:100, secUnit:false&#125;, 千:&#123;value:1000, secUnit:false&#125;, 万:&#123;value:10000, secUnit:true&#125;, 亿:&#123;value:100000000, secUnit:true&#125;&#125; 转换的方法如下： 1234567891011121314151617181920212223242526272829function ChineseToNumber(chnStr)&#123; var rtn = 0; var section = 0; var number = 0; var secUnit = false; var str = chnStr.split(&#x27;&#x27;); for(var i = 0; i &lt; str.length; i++)&#123; var num = chnNumChar[str[i]]; if(typeof num !== &#x27;undefined&#x27;)&#123; number = num; if(i === str.length - 1)&#123; section += number; &#125; &#125;else&#123; var unit = chnNameValue[str[i]].value; secUnit = chnNameValue[str[i]].secUnit; if(secUnit)&#123; section = (section + number) * unit; rtn += section; section = 0; &#125;else&#123; section += (number * unit); &#125; number = 0; &#125; &#125; return rtn + section;&#125;","categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"}]},{"title":"Welcome To My Blog","slug":"其它/reduction","date":"2019-07-20T06:20:30.000Z","updated":"2021-03-02T17:57:03.591Z","comments":true,"path":"hello-page/","link":"","permalink":"https://www.bipch.cn/hello-page/","excerpt":"欢迎来到我的博客，会一直更新一些个人日常和有趣的问题，Have a good time! 于 2019/07/20，终于借助 Hexo 框架将个人界面搭建完毕。 于 2020/04/10，将博客主题修改为Next，并添加自定义样式。","text":"欢迎来到我的博客，会一直更新一些个人日常和有趣的问题，Have a good time! 于 2019/07/20，终于借助 Hexo 框架将个人界面搭建完毕。 于 2020/04/10，将博客主题修改为Next，并添加自定义样式。","categories":[{"name":"其它","slug":"其它","permalink":"https://www.bipch.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[]}],"categories":[{"name":"web","slug":"web","permalink":"https://www.bipch.cn/categories/web/"},{"name":"Linux","slug":"Linux","permalink":"https://www.bipch.cn/categories/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.bipch.cn/categories/Nginx/"},{"name":"Node","slug":"Node","permalink":"https://www.bipch.cn/categories/Node/"},{"name":"数据库","slug":"数据库","permalink":"https://www.bipch.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"漏洞攻击","slug":"漏洞攻击","permalink":"https://www.bipch.cn/categories/%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"},{"name":"其它","slug":"其它","permalink":"https://www.bipch.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"项目部署","slug":"项目部署","permalink":"https://www.bipch.cn/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.bipch.cn/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.bipch.cn/tags/Nginx/"},{"name":"Koa2","slug":"Koa2","permalink":"https://www.bipch.cn/tags/Koa2/"},{"name":"pm2","slug":"pm2","permalink":"https://www.bipch.cn/tags/pm2/"},{"name":"React","slug":"React","permalink":"https://www.bipch.cn/tags/React/"},{"name":"导航守卫","slug":"导航守卫","permalink":"https://www.bipch.cn/tags/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"},{"name":"服务端渲染","slug":"服务端渲染","permalink":"https://www.bipch.cn/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"},{"name":"https","slug":"https","permalink":"https://www.bipch.cn/tags/https/"},{"name":"Linux","slug":"Linux","permalink":"https://www.bipch.cn/tags/Linux/"},{"name":"Redux","slug":"Redux","permalink":"https://www.bipch.cn/tags/Redux/"},{"name":"error-first","slug":"error-first","permalink":"https://www.bipch.cn/tags/error-first/"},{"name":"Vue","slug":"Vue","permalink":"https://www.bipch.cn/tags/Vue/"},{"name":"ES6","slug":"ES6","permalink":"https://www.bipch.cn/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://www.bipch.cn/tags/%E5%BC%82%E6%AD%A5/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.bipch.cn/tags/MongoDB/"},{"name":"跨域脚本攻击","slug":"跨域脚本攻击","permalink":"https://www.bipch.cn/tags/%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.bipch.cn/tags/JavaScript/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://www.bipch.cn/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"},{"name":"代理","slug":"代理","permalink":"https://www.bipch.cn/tags/%E4%BB%A3%E7%90%86/"},{"name":"脚手架","slug":"脚手架","permalink":"https://www.bipch.cn/tags/%E8%84%9A%E6%89%8B%E6%9E%B6/"},{"name":"Mobx","slug":"Mobx","permalink":"https://www.bipch.cn/tags/Mobx/"},{"name":"hooks","slug":"hooks","permalink":"https://www.bipch.cn/tags/hooks/"},{"name":"Array","slug":"Array","permalink":"https://www.bipch.cn/tags/Array/"},{"name":"webpack","slug":"webpack","permalink":"https://www.bipch.cn/tags/webpack/"},{"name":"柯里化","slug":"柯里化","permalink":"https://www.bipch.cn/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"}]}