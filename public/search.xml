<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome To My Blog</title>
    <url>/hello-page/</url>
    <content><![CDATA[<p>欢迎来到我的博客，会一直更新一些个人日常和有趣的问题，Have a good time!</p>
<p>于 2019/07/20，终于借助 Hexo 框架将个人界面搭建完毕。</p>
<p>于 2020/04/10，将博客主题修改为Next，并添加自定义样式。</p>
<a id="more"></a>

]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>Linux top</title>
    <url>/linux-top/</url>
    <content><![CDATA[<p>电脑运行时，如果需要查询正在运行的程序和内存占用情况，以及找出那个程序导致我们电脑卡顿，这些都是<code>top</code>命令可以胜任的工作，它能有效的监听电脑进程的运行情况，并提供<code>PID</code>字段可以让用户处理占用 cpu 消耗较大的应用。</p>
<a id="more"></a>

<p>首先我的服务器系统为<strong>Centos7.8</strong>，如果不一样那么打印出的信息可能会有些差别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; top</span><br></pre></td></tr></table></figure>
<p>执行完毕后，界面打印出下面信息：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">top - 00:59:04 up 21:49, <span class="number"> 2 </span>users,  load average: 0.09, 0.25, 0.34</span><br><span class="line">Tasks:<span class="number"> 102 </span>total,  <span class="number"> 1 </span>running,<span class="number"> 101 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s):  7.4 us,  4.4 sy,  0.0 ni, 88.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : <span class="number"> 1014696 </span>total,  <span class="number"> 131908 </span>free,  <span class="number"> 366040 </span>used,  <span class="number"> 516748 </span>buff/cache</span><br><span class="line">KiB Swap: <span class="number"> 1049596 </span>total,  <span class="number"> 777980 </span>free,  <span class="number"> 271616 </span>used.  <span class="number"> 499336 </span>avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND </span><br></pre></td></tr></table></figure>
<p>可能第一次看着比较乱，但是这些信息将电脑的cpu、内存等资源的使用情况都提供出来了。</p>
<h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><p>首先其输出分作两部分，<strong>上部分</strong>(1 - 5行)为一些统计的信息，其余则是<strong>下部分</strong>包含所有服务信息的一个表格(由于太多没有列出来，只是列出一个表头)。</p>
<p>而我们解析只需要从这两部分入手。</p>
<h3 id="上部分"><a href="#上部分" class="headerlink" title="上部分"></a>上部分</h3><p><strong>第一行：</strong>主要用于显示当前事件、服务器登陆数、系统负载情况。</p>
<ul>
<li><code>top</code>：监测时的系统时间(会一直刷新)。</li>
<li><code>users</code>：系统登陆数。</li>
<li><code>load average</code>：三个值，分别为过去1分钟、5分钟、15分钟的系统负载。</li>
</ul>
<p><strong>第二行：</strong>主要用于显示系统中各个类型进程的个数。</p>
<ul>
<li><code>total</code>：系统总进程数。</li>
<li><code>running</code>：系统运行进程数。</li>
<li><code>sleeping</code>：系统等待的进程数。</li>
<li><code>stopped</code>：系统停止的进程数。</li>
<li><code>zombie</code>：系统被复原的进程数。</li>
</ul>
<p><strong>第三行：</strong>该行主要显示按类型划分 cpu 使用情况。</p>
<ul>
<li><code>us</code>：用户进程占比。</li>
<li><code>sy</code>：系统进程占比。</li>
<li><code>ni</code>：nice 用户进程占比，也就是改变过优先级类型的进程占比。</li>
<li><code>id</code>：cpu 空闲时间占比，该值越小说明 cpu 越忙。</li>
<li><code>wa</code>：等待异步操作完成的时间占比。</li>
<li><code>hi</code>：硬中断占用 cpu 的百分比。</li>
<li><code>si</code>：软中断占用 cpu 的百分比。</li>
<li><code>st</code>：”虚拟机管理程序从该虚拟机窃取的时间占比”。</li>
</ul>
<p>可以使用 <strong>t</strong>(toggle) 切换折叠 <strong>Task</strong>(第二行) 和 <strong>%Cpu(s)</strong>(第三行) 的展开和折叠。</p>
<p><strong>第四行与第五行：</strong>主要提供了内存、交换分区的信息。</p>
<ul>
<li><code>total</code>：总内存容量。</li>
<li><code>free</code>：空闲内存。</li>
<li><code>used</code>：已用内存。</li>
</ul>
<h3 id="下部分"><a href="#下部分" class="headerlink" title="下部分"></a>下部分</h3><p>系统中正在运行的进程，默认按照 cpu 使用频率降序排序，我们输入<code>M</code>进行按照内存排序，输入<code>P</code>按照 cpu 使用频率排序。当然如果 cpu 使用频率较高的话，表示程序消耗了许多的资源，也就是造成电脑卡顿的最终祸首。<br>其提供了下面关于服务的信息：</p>
<ul>
<li><code>PID</code>：进程的唯一标识符，可以借助 ID 关闭指定的服务。</li>
<li><code>USER</code>：运行进程的用户。</li>
<li><code>PR</code>：优先级。</li>
<li><code>NI</code>：Nice 值，表示进程的优先级。</li>
<li><code>VIRT</code>：虚拟内存的大小。</li>
<li><code>RES</code>：常驻内存的大小。</li>
<li><code>SHR</code>：共享内存的大小。</li>
<li><code>S</code>：进程的运行状态，<strong>I</strong> 代表空闲、<strong>R</strong> 代表运行、<strong>S</strong> 代表休眠、<strong>Z</strong>表示僵尸进程、<strong>T</strong> 或 <strong>t</strong> 代表停止等。</li>
<li><code>%CPU</code>：自上次屏幕更新 cpu 的使用率。</li>
<li><code>%MEM</code>：自上次屏幕更新，<strong>RES</strong>常用内存使用率。</li>
<li><code>TIME+</code>：自从程序启动后总的 CPU 使用时间。</li>
<li><code>COMMAND</code>：启动命令。</li>
</ul>
<h2 id="cpu使用率较高"><a href="#cpu使用率较高" class="headerlink" title="cpu使用率较高"></a>cpu使用率较高</h2><p>当 cpu 空闲时间较高时，服务器可以正常的工作，当 cpu 空闲较低时，我们的服务器会变得非常的卡，甚至会影像到我们部署到服务器上的各个服务。<br>例如我服务器为阿里云最基础的配置，如果同时在服务器下载多个文件，那么便会出现：</p>
<p><img src="https://img.bipch.cn/2021/02/03/fadf5610c2839.png" alt="cpu 空闲较小"></p>
<p>这种情况，可以看到<code>id</code>已经为0，此时服务器会非常的卡，甚至我们部署在服务器上的服务也都是无法进行访问的，此时需要在 top 命令行中输入<code>k</code>，此时程序会给出提示：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">PID <span class="keyword">to</span> <span class="keyword">signal</span>/kill [<span class="keyword">default</span> pid = <span class="number">30</span>] </span><br></pre></td></tr></table></figure>
<p>其默认关闭排行第一的服务，也可以自己输入指定程序的<code>PID</code>字段，回车便可以关闭指定的程序，关闭成功后，服务器恢复正常：</p>
<p><img src="https://img.bipch.cn/2021/02/03/aa81b31b64157.png" alt="cpu 恢复"></p>
<p>我们可以借助 top 命令查询当前系统的运行状态，其也为我们提供了很多配置帮助我们更好的进行工作，查找指定指定配置我们可以看其为我们提供的<a href="https://man7.org/linux/man-pages/man1/top.1.html">手册</a>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pm2 + Nginx 部署 Koa2</title>
    <url>/linux-pm2-nginx-Koa2/</url>
    <content><![CDATA[<p>因为自己需要空闲的时候总结一些个人项目等，之前通过 hexo 搭建的博客，但是接触了 koa2 决定使其搭建一个后台接口服务，为前端界面提供相应数据。</p>
<p>本篇主要讲解客户端一键将 koa2 项目部署到服务器，服务器端使用 pm2 管理 koa2 服务及 Nginx 反向代理服务到另一个接口。</p>
<p>首先网站大致为：koa2 默认占用本地<code>6060</code>端口，然后通过 nginx 反向代理到<code>80</code>端口，同时 nginx 将<code>80</code>端口转发到<code>443</code>强制使用 https 协议。</p>
<a id="more"></a>

<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>本人服务器系统为<code>CentOS7.0</code>，系统不同执行的命令也会有些许差别。部署之前要安装必备的软件：<code>Node</code>、<code>npm</code>、<code>pm2</code>、<code>Nginx</code>。安装的方法这里就不多说了，其方式有太多。</p>
<p><strong>下面的配置都是为了服务器安全，如果不需要可以不用配置。后面用户直接设置为 root 即可</strong>。</p>
<h3 id="创建新用户-可选"><a href="#创建新用户-可选" class="headerlink" title="创建新用户(可选)"></a>创建新用户(可选)</h3><p>为了服务器的安全起见，不推荐用 root 用户管理所有权限，只有需要 root 权限时，在使用<code>su</code>切换为 root。<br>创建一个新用户：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">useradd bpc</span></span><br></pre></td></tr></table></figure>
<p>对新用户初始化密码：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd bpc</span></span><br></pre></td></tr></table></figure>
<p>将该用户添加到<code>wheel</code>组中，设置为管理员用户：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">usermod -aG wheel bpc</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭-root-用户访问-ssh-可选"><a href="#关闭-root-用户访问-ssh-可选" class="headerlink" title="关闭 root 用户访问 ssh(可选)"></a>关闭 root 用户访问 ssh(可选)</h3><p>为了服务器的安全，我们也需要关闭 root 的 ssh 访问权限。<br>打开配置文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>找到下面配置，并将 yes 修改为 no：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">PermitRootLogin</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>
<p>保存文件后，重启sshd服务：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">service sshd restart</span></span><br></pre></td></tr></table></figure>
<p>这样 root 用户便不能直接登陆了，我们退出服务，使用新用户登陆，当权限不足时使用<code>su</code>切换到指定用户即可。</p>
<h3 id="文件读写权限-可选"><a href="#文件读写权限-可选" class="headerlink" title="文件读写权限(可选)"></a>文件读写权限(可选)</h3><p>因为我们自定义了用户进行管理，其并不会向 root 一样有着所有文件的读写权限，我们需要对指定路径设置新用户的访问权限。<br>比如我在服务器中将最终代码放置在 <strong>/var/api/blog</strong> 路径下，那么我们通过下面方式分配权限：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chown -R bpc <span class="regexp">/var/</span>api</span><br><span class="line">chmod -R <span class="number">755</span> <span class="regexp">/var/</span>api</span><br></pre></td></tr></table></figure>
<p>这样通过<code>chown</code>命令分配指定用户权限，通过<code>chmod</code>分配给文件夹详细权限(755表示拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限)。</p>
<h2 id="Github-仓库"><a href="#Github-仓库" class="headerlink" title="Github 仓库"></a>Github 仓库</h2><p>客户和服务器端同步代码需要建立一个 github 的私人仓库，我的命名为 react_blog_api。</p>
<h3 id="设置密钥"><a href="#设置密钥" class="headerlink" title="设置密钥"></a>设置密钥</h3><p>由于需要使用 ssh 读写私人仓库内容，所以需要配置私人仓库中的 <strong>Deploy keys</strong>。这就需要我们在客户端和服务器端生成<code>id_rsa.pub</code>(默认名称)文件，并查询其内容：</p>
<p>首先我们查看是否已经生成该文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_rsa.pub  <span class="comment"># cat 命令查看文件</span></span><br></pre></td></tr></table></figure>
<p>当然如果<code>cat</code>命令没有查找文件，那么可以使用下面命令生成：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;你的个人邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>复制成功后，将内容粘贴到私人仓库中的 <strong>Deploy keys</strong> ：</p>
<p><img src="https://img.bipch.cn/2021/02/06/c05da0bf0d3e6.png" alt=""></p>
<p>并将 Allow write access 勾选上添加即可。</p>
<h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>私人仓库配置完成后，我们便有权限操作私人仓库了，我们将客户端代码传入到仓库中：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> init</span><br><span class="line"><span class="symbol">git</span> remote <span class="keyword">add</span> origin https:<span class="comment">//github.com/bpc99/blog_api.git</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">add</span> .</span><br><span class="line"><span class="symbol">git</span> commit -m <span class="string">&quot;项目初始化&quot;</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push</span> -u origin master</span><br></pre></td></tr></table></figure>
<p>这样便将客户端代码提交至 Github 私人仓库。</p>
<h2 id="pm2-配置"><a href="#pm2-配置" class="headerlink" title="pm2 配置"></a>pm2 配置</h2><p>使用 pm2 可以使 node 程序永远保持活动状态，无需停机便可以重新加载它们，并简化常见的任务管理。并且其还为我们提供了 deploy 配置，可以让我们在本地一键将项目部署到服务端。</p>
<h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p>关于 pm2 的基本操作和配置这里就不介绍了，具体可以查看其<a href="https://github.com/Unitech/pm2">官方文档</a>，当 koa2 本地运行无误时，我们需要配置 pm2 中的<code>deploy</code>属性，其默认的模板文件为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [...],</span><br><span class="line">  deploy : &#123;</span><br><span class="line">    production : &#123;</span><br><span class="line">      user : <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      host : <span class="string">&quot;212.83.163.1&quot;</span>,</span><br><span class="line">      ref  : <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">      repo : <span class="string">&quot;git@github.com:repo.git&quot;</span>,</span><br><span class="line">      path : <span class="string">&quot;/var/www/production&quot;</span>,</span><br><span class="line">      <span class="string">&quot;post-deploy&quot;</span> : <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些基础的配置，其各个属性也都很简单：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;production&quot;: &#123;</span><br><span class="line">  &quot;user&quot;: &quot;登录远程服务器的用户名(例如 root)&quot;,</span><br><span class="line">  &quot;host&quot;: &quot;IP&quot;,</span><br><span class="line">  &quot;ref&quot;: &quot;远端名称及分支名&quot;,</span><br><span class="line">  &quot;repo&quot;: &quot;git仓库地址&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;远程服务器部署目录，需要填写user具备写入权限的目录&quot;,</span><br><span class="line">  &quot;post-deploy&quot; : &quot;部署后需要执行的命令&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们根据自己服务器的信息填入即可，最后贴出本人的配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [...],</span><br><span class="line">  production: &#123;</span><br><span class="line">    user: <span class="string">&quot;bpc&quot;</span>,</span><br><span class="line">    host: <span class="string">&quot;47.110.125.228&quot;</span>,</span><br><span class="line">    ref: <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">    repo: <span class="string">&quot;git@github.com:bpc99/blog_api.git&quot;</span>,</span><br><span class="line">    path: <span class="string">&quot;/var/api/blog&quot;</span>,</span><br><span class="line">    <span class="string">&quot;post-deploy&quot;</span>: <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便完成了 pm2 的基本配置，贴出<code>ecosystem.config.js</code>所有配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;</span><br><span class="line">    name: <span class="string">&#x27;api&#x27;</span>,</span><br><span class="line">    script: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    watch: <span class="literal">true</span>,</span><br><span class="line">    ignore_watch: [ <span class="string">&quot;node_modules&quot;</span> ]</span><br><span class="line">  &#125;],</span><br><span class="line">  deploy: &#123;</span><br><span class="line">    production: &#123;</span><br><span class="line">      user: <span class="string">&quot;bpc&quot;</span>,</span><br><span class="line">      host: <span class="string">&quot;47.110.125.228&quot;</span>,</span><br><span class="line">      ref: <span class="string">&quot;origin/master&quot;</span>,</span><br><span class="line">      repo: <span class="string">&quot;git@github.com:bpc99/blog_api.git&quot;</span>,</span><br><span class="line">      path: <span class="string">&quot;/var/api/blog&quot;</span>,</span><br><span class="line">      <span class="string">&quot;post-deploy&quot;</span>: <span class="string">&quot;npm install &amp;&amp; pm2 startOrRestart ecosystem.config.js --env production&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后我们在根目录下，以<code>ecosystem.config.js</code>为配置文件，启动 pm2：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">pm2 deploy ecosystem.<span class="built_in">config</span>.js production <span class="built_in">setup</span></span><br></pre></td></tr></table></figure>
<p>此时会出现一个错误：</p>
<blockquote>
<p>Host key verification failed.<br>fatal: Could not read from remote repository.</p>
</blockquote>
<p>主要是因为在远程服务器中，并未将 <a href="https://github.com">github.com</a> 加入known_hosts，在服务器端通过如下命令设置：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">ssh-keyscan -t rsa github.com &gt;&gt; ~<span class="regexp">/.ssh/</span>known_hosts</span><br></pre></td></tr></table></figure>
<p>如果成功，会在<strong>/home/用户名/.ssh</strong>目录下生成<code>known_hosts</code>文件。然后客户端重新执行部署的指令：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">pm2 deploy ecosystem.<span class="built_in">config</span>.js production <span class="built_in">setup</span></span><br></pre></td></tr></table></figure>
<p>如果传输成功 pm2 便将 GitHub 私人仓库中的文件，都传输到了我们服务器指定路径下，我们打开指定文件夹，发现其多了 3 个文件夹：</p>
<ul>
<li><code>current</code>：当前运行的文件夹。</li>
<li><code>source</code>：真正的项目源代码。</li>
<li><code>shared</code>：项目日志文件。</li>
</ul>
<h3 id="部署代码"><a href="#部署代码" class="headerlink" title="部署代码"></a>部署代码</h3><p>当一键传输配置完成，客户端项目代码可以一键传输到服务器上，这样我们便可以开始部署服务器上的项目了。</p>
<p>在开始部署之前，我们需要确保本地和 Github 私人仓库代码的同步，先将本地文件同步到 Github：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 和仓库代码同步</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta"># 代码添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m <span class="string">&quot;update ecosystem&quot;</span></span><br><span class="line"><span class="meta"># 传本地指定分支到远程仓库</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>这样提交完成后，在本地的根目录下执行命令，将代码向生产环境下部署：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pm2</span> <span class="selector-tag">deploy</span> <span class="selector-tag">ecosystem</span><span class="selector-class">.config</span><span class="selector-class">.js</span> <span class="selector-tag">production</span></span><br></pre></td></tr></table></figure>
<p>如果项目部署成功，配置文件中的<code>post-deploy</code>中的命令会自动执行(当然运行速度慢了可以将 npm 切换为 cnpm 或 yarn)，那么便可以看出 pm2 给出的提示：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">PM2</span>][<span class="symbol">WARN</span>] <span class="symbol">Applications</span> api not running, starting...</span><br><span class="line">[<span class="symbol">PM2</span>][<span class="symbol">WARN</span>] <span class="symbol">Environment</span> [production] is not defined in process file</span><br><span class="line">[<span class="symbol">PM2</span>] <span class="symbol">App</span> [api] launched (<span class="number">1</span> instances)</span><br><span class="line">┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐</span><br><span class="line">│ id  │ name   │ namespace   │ version │ mode    │ pid      │ uptime │ ?    │ status    │ cpu      │ mem      │ user     │ watching │</span><br><span class="line">├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤</span><br><span class="line">│ <span class="number">0</span>   │ api    │ default     │ <span class="number">1.0</span><span class="number">.0</span>   │ fork    │ <span class="number">9438</span>     │ <span class="number">0</span>s     │ <span class="number">0</span>    │ online    │ <span class="number">0</span><span class="comment">%       │ 9.1mb    │ bpc      │ disabled │</span></span><br><span class="line">└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘</span><br><span class="line">  ○ successfully deployed origin/master</span><br><span class="line">--&gt; <span class="symbol">Success</span></span><br></pre></td></tr></table></figure>

<p>这样便表示代码部署成功，我们可以在服务器上所有端口使用清空：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">netstat -antp</span></span><br></pre></td></tr></table></figure>
<p>可以查看端口开发情况，例如本人的6060端口：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tcp</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">127.0.0.1:6060</span>    <span class="number">0.0.0.0</span>:*    LISTEN    <span class="number">2657</span>/node /var/www/</span><br></pre></td></tr></table></figure>
<p><code>注意</code>：此时端口为<strong>127.0.0.1</strong>表明局域网可以访问，公网是不能访问到的，我们还需要 nginx 进行代理。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>上面基本运行完成，但是只有局域网可以访问，我们需要将其使用 nginx 代理至公网上，至于 nginx 下载和配置便不多提了，我们可以新建一个配置文件，最终贴出我的配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> api.bipch.cn;</span><br><span class="line">    <span class="attribute">access_log</span>  /www/wwwlogs/api.bipch.cn.log;</span><br><span class="line">    <span class="attribute">error_log</span>  /www/wwwlogs/api.bipch.cn.<span class="literal">error</span>.log;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:6060;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其原理也很简单，其拦截了<strong>80</strong>端口，并代理到本地的<strong>6060</strong>，并配置了相应的域名，日志，端口等信息，配置完成后，使用<code>./nginx -s reload</code>重启服务。</p>
<p>最后如果配置正确，并且相应端口的安全组已经打开，那么我们便可以正常访问相应的API了。</p>
<h3 id="配置-https"><a href="#配置-https" class="headerlink" title="配置 https"></a>配置 https</h3><p>https 配置肯定需要相应的证书的，由于本人服务器为阿里云，免费证书申请可以看<a href="/nginx-https">这篇</a>，申请成功后，修改我们的配置文件：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> api.bipch.cn;</span><br><span class="line">    <span class="attribute">access_log</span>  /www/wwwlogs/api.bipch.cn.log;</span><br><span class="line">    <span class="attribute">error_log</span>  /www/wwwlogs/api.bipch.cn.<span class="literal">error</span>.log;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># HTTP_TO_HTTPS_START</span></span><br><span class="line">    <span class="attribute">if</span> ($server_port !<span class="regexp">~ 443)</span>&#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(/.*)$</span> https://$host<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># HTTP_TO_HTTPS_END</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment"># HTTP_CONFIG_START</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>    /www/server/panel/vhost/cert/api.bipch.cn/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>    /www/server/panel/vhost/cert/api.bipch.cn/privkey.pem;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">    <span class="comment"># HTTP_CONFIG_END</span></span><br><span class="line">	</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:6060;</span><br><span class="line">        <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样接口便强制使用 https 协议，其重点在于<code>ssl_certificate</code>和<code>ssl_certificate_key</code>分别指向两个证书的路径。当所有属性配置完成后，重启指定的 nginx 便完成了反向代理。<br>最后 pm2 便在本地<code>6060</code>运行，nginx 将<code>80</code>端口代理到<code>6060</code>端口，并且将<code>80</code>端口转发到<code>443</code>端口，使用 https 协议，这样便结合了 pm2 + nginx 完成了 node 项目的部署。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Koa2</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongoose聚合查询</title>
    <url>/Mongoose-aggregate/</url>
    <content><![CDATA[<p>在 MongoDB 中，聚合(<code>aggregate</code>)主要可以用于多个表之间的联合查询，并且可以进行求和、求平均值、最大与最小值等，在项目中使用也是非常的方便，下面主要是一些常用的操作，更多详细的可以看其<a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/">官方文档</a>。</p>
<a id="more"></a>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>日常开发中经常这些场景，比如文章都有类别字段，而一个类别可以对应多个文章，我们如果需要统计每个类别下的所有文章便可以通过<code>aggregate</code>进行查询，或者我们需要统计每个时间段发布的文章做个归档，也可以使用其来完成。</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>常规的定义为：<code>db.collection.aggregate(pipeline, options)</code><br>主要接收两个参数，其中 <strong>pipeline</strong> 表示数据联立等操作，而 <strong>options</strong> 则为数据库的配置，这里就不多说该属性了。而 <strong>pipeline</strong> 常用的属性有：</p>
<ol>
<li><code>$project</code>：用于指定返回的字段，字段可以是文档中的，也可以添加新的字段，或者排除某个字段。</li>
<li><code>$match</code>：用于过滤文档，可以只返回服务我们条件的。</li>
<li><code>$limit</code>：用于限制最后查询出的数据，可以配合下面的进行数据分页。</li>
<li><code>$skip</code>：用于跳过指定条数的数据，可以用于实现分页。</li>
<li><code>$unwind</code>：拆分数据，将一条数据拆分为多条。</li>
<li><code>$group</code>：对文档中的数据进行分组，可用于分组或者统计。</li>
<li><code>$sort</code>：根据某些字段进行数据的排序。</li>
<li><code>$geoNear</code>：距指定点最近到最远的顺序输出文档。</li>
<li><code>$lookup</code>：用于将数据进行汇总。</li>
</ol>
<h2 id="lookup-数据填充"><a href="#lookup-数据填充" class="headerlink" title="$lookup(数据填充)"></a>$lookup(数据填充)</h2><p>当一个文章类型对应多个文章，而每个文章仅仅对应一个类型，大致为(一对多)，我们要再文章集合中填充类型的信息，便需要该查询方式了。<br>其基本格式为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   $lookup:</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">from</span>: <span class="xml"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">to</span> <span class="attr">join</span>&gt;</span>,</span></span><br><span class="line">       localField: &lt;field from the input documents&gt;,</span><br><span class="line">       foreignField: &lt;field from the documents of the &quot;from&quot; collection&gt;,</span><br><span class="line">       as: &lt;output array field&gt;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们有下面的 <strong>post</strong> 集合数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">2</span> &#125;,</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">8</span>  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>同样还需要一个 <strong>type</strong> 集合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;name&quot;</span> : <span class="string">&quot;web&#125;,</span></span><br><span class="line"><span class="string">   &#123; &quot;</span>_id<span class="string">&quot; : 8, &quot;</span>name<span class="string">&quot; : &quot;</span>数据库<span class="string">&quot; &#125;</span></span><br><span class="line"><span class="string">])</span></span><br></pre></td></tr></table></figure>
<p>我们如果需要将指定的 <strong>type</strong> 信息填充到 <strong>post</strong> 中便可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.post.aggregate([</span><br><span class="line">   &#123;</span><br><span class="line">     $lookup:</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">from</span>: <span class="string">&quot;type&quot;</span>,</span><br><span class="line">         localField: <span class="string">&quot;type&quot;</span>,</span><br><span class="line">         foreignField: <span class="string">&quot;_id&quot;</span>,</span><br><span class="line">         <span class="keyword">as</span>: <span class="string">&quot;typeInfo&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>这样便通过<code>$lookup</code>完成了字段填充，<strong>from</strong> 表示需要联接的集合，<strong>localField</strong> 表示需要和集合进行联立的字段，<strong>foreignField</strong> 表示集合中用于和 localField 对应的字段，<strong>as</strong> 表示别名。其结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">		<span class="attr">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;type&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="attr">&quot;typeInfo&quot;</span>: [</span><br><span class="line">			&#123; <span class="attr">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;web&quot;</span>&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		<span class="attr">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">		<span class="attr">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;type&quot;</span> : <span class="number">8</span>,</span><br><span class="line">		<span class="attr">&quot;typeInfo&quot;</span>: [</span><br><span class="line">			&#123; <span class="attr">&quot;_id&quot;</span> : <span class="number">8</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;数据库&quot;</span> &#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然我们不可能只遇到一对多，有时甚至需要多对多进行填充，这么我们可以先借助<code>$unwind</code>展开数组，然后再填充数据。</p>
</blockquote>
<h2 id="group-分组"><a href="#group-分组" class="headerlink" title="$group(分组)"></a>$group(分组)</h2><p>当文章有添加日期，我们需要根据添加日期的年份对文章进行分组，这样便可以统计每年新增的文章。<br>默认的格式为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $group:</span><br><span class="line">    &#123;</span><br><span class="line">      _id: &lt;expression&gt;, <span class="comment">// Group By Expression</span></span><br><span class="line">      &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>需要先创建一个 <strong>post</strong> 集合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">2</span>, <span class="attr">createdAt</span>: <span class="string">&quot;2021-03-03 03-08:50&quot;</span>&#125;,</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>, <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>, <span class="string">&quot;type&quot;</span> : <span class="number">8</span>, <span class="attr">createdAt</span>: <span class="string">&quot;2020-12-03 09-05:40&quot;</span>  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>我们可以很轻松的对数据分组，分组之前可以先通过<code>$project</code>筛选出需要的字段，<code>$sort:</code>对选中的数据排序整理数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.post.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    $project: &#123;</span><br><span class="line">      _id: <span class="number">1</span>,</span><br><span class="line">      title: <span class="number">1</span>,</span><br><span class="line">      createdAt: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $sort: &#123;</span><br><span class="line">      createdAt: -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">      _id: &#123;</span><br><span class="line">        $dateToString: &#123; <span class="attr">format</span>: <span class="string">&quot;%Y&quot;</span>, <span class="attr">date</span>: <span class="string">&quot;$createdAt&quot;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      posts: &#123; <span class="attr">$push</span>: <span class="string">&quot;$$ROOT&quot;</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    $sort: &#123;</span><br><span class="line">      _id: -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><code>$group</code>中 <strong>_id</strong> 表示用于分组的字段，其内部的<code>$dateToString</code>表示格式化数据，因为我们需要按照年份进行分组，所以要提取出日期中的年份。posts 为数据名称<code>$push</code>表示对每个分组添加进数据，<code>$$ROOT</code>表示分组出数据的所有字段(可以和 $project 结合使用)。</p>
<p>最后返回数据格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> <span class="string">&quot;2021&quot;</span></span><br><span class="line">    &#x27;posts&#x27;: [</span><br><span class="line">      &#123;&quot;_id&quot; : 1, &quot;title&quot; : &quot;React&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 2, createdAt: &quot;2021-03-03 03-08:50&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> <span class="string">&quot;2020&quot;</span></span><br><span class="line">    &#x27;posts&#x27;: [</span><br><span class="line">      &#123; &quot;_id&quot; : 2, &quot;title&quot; : &quot;mongodb&quot;, &quot;content&quot; : &quot;*****&quot;, &quot;type&quot; : 8, createdAt: &quot;2020-12-03 09-05:40&quot;  &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unwind-数组统计"><a href="#unwind-数组统计" class="headerlink" title="$unwind(数组统计)"></a>$unwind(数组统计)</h2><p>可以用于展开数组的字段，例如我们需要统计数组中每个字段出现的次数。<br>需要先创建一个 <strong>post</strong> 集合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.post.insert([</span><br><span class="line">	&#123;</span><br><span class="line">	   <span class="string">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">	   <span class="string">&quot;title&quot;</span> : <span class="string">&quot;React&quot;</span>,</span><br><span class="line">	   <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line">	   <span class="string">&quot;type&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	   tags: [<span class="string">&quot;web&quot;</span>]</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">	   <span class="string">&quot;_id&quot;</span> : <span class="number">2</span>,</span><br><span class="line">	   <span class="string">&quot;title&quot;</span> : <span class="string">&quot;mongodb&quot;</span>,</span><br><span class="line">	   <span class="string">&quot;content&quot;</span> : <span class="string">&quot;*****&quot;</span>,</span><br><span class="line">	   <span class="string">&quot;type&quot;</span> : <span class="number">8</span>,</span><br><span class="line">	   tags: [<span class="string">&quot;web&quot;</span>, <span class="string">&quot;数据库&quot;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>我们需要统计数组中每个 <strong>tag</strong> 出现的次数，那么我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.post.aggregate([&#123;</span><br><span class="line">	$project: &#123;</span><br><span class="line">		tags: <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">	$unwind: <span class="string">&quot;$tags&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">	$group: &#123;</span><br><span class="line">		_id: <span class="string">&quot;$tags&quot;</span>,</span><br><span class="line">		sum: &#123;</span><br><span class="line">			$sum: <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
<p>这样先通过<code>$project</code>筛选出需要的字段，然后通过<code>$unwind</code>展开指定字段，最后使用<code>$group</code>进行累加的操作。最后计算的结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;<span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;web&quot;</span>, <span class="attr">&quot;sum&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">	&#123;<span class="attr">&quot;_id&quot;</span>: <span class="string">&quot;数据库&quot;</span>, <span class="attr">&quot;sum&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Next.js 介绍</title>
    <url>/react-next/</url>
    <content><![CDATA[<p>Next.js 是一个轻量级的 React 服务端渲染(SSR)框架，其主要目的便是为了让 React 轻松的完成服务端的渲染，从而提升首屏打开的速度、并且更利于SEO。当然服务端渲染不是只有好处也有着许多的局限。</p>
<a id="more"></a>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>服务器端渲染的检查，是完全由服务器告诉客户端渲染为什么，服务器生成 html 字符串，传递给客户端，客户端经过渲染展示给用户。</p>
<p>其优势在于：</p>
<ol>
<li>利于SEO：不论是 React 项目还是 Vue 等项目，界面信息都是通过客户端 JS 动态生成的，需要服务端返回相应的数据才能正确显示，但是浏览器爬虫并不会等界面完全加载之后才会抓取。而服务端渲染则是完全由服务端生成最终展示的代码，更便于爬虫抓取整个网页的信息。</li>
<li>利于首屏渲染：因为服务端渲染完全由服务端返回客户端 HTML 字符串，客户端不需要解析 js 等文件，这样首屏的速度高于普通的方式。</li>
</ol>
<p>当然其也不是全是优点，缺点也非常多：</p>
<ol>
<li>服务器压力大：本来属于客户端的公主，现在统一交给 Node 服务端去做，如果出现高并发会对服务器造成不小负担。</li>
<li>开发条件受限：由于解析文件交给了服务端，所以一些代码的用法和以前有所区别。</li>
</ol>
<p>所以项目是选用普通方式渲染还是服务端渲染都不是一概而论的，只能根据现实条件决定，而服务端渲染中较为突出的框架便为 <a href="https://github.com/vercel/next.js">Next.js</a> 了。</p>
<h2 id="手动创建项目"><a href="#手动创建项目" class="headerlink" title="手动创建项目"></a>手动创建项目</h2><p>手动创建项目配置更灵活，项目初始化完成后，首先其是基于 React 的，所以要先安装 React 相关的依赖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom next</span><br></pre></td></tr></table></figure>
<p>然后修改<code>package.json</code>中的命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">  &quot;build&quot;: &quot; next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再根目录新建<code>pages</code>文件夹，新建<code>home.jsx</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;Hello Next.js&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home;</span><br></pre></td></tr></table></figure>
<p>然后执行<code>yarn dev</code>运行项目，运行成功后，直接输入：<strong><a href="http://localhost:3000/home">http://localhost:3000/home</a></strong> 即可访问界面，不需再需要路由相关的封装，<code>page</code>下的所有文件都会自动创建路由。</p>
<h2 id="create-next-app"><a href="#create-next-app" class="headerlink" title="create-next-app"></a>create-next-app</h2><p>除了上面手动搭建项目，还可以使用脚手架快速搭建项目，因为其能更好的帮助我们组织代码，并添加了一些项目默认配置。<br>执行命令安装脚手架：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn <span class="built_in">global</span> add create-next-app</span><br></pre></td></tr></table></figure>
<p>安装完成后，执行下面的命令创建项目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">create-next-app project-name</span><br></pre></td></tr></table></figure>
<p>完成后执行<code>yarn dev</code>启动，启动完成后可以看到默认界面。</p>
<h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>项目创建完成后，默认有些项目的配置：</p>
<ul>
<li><strong>components</strong>：也其它的项目基本一样，也是用于存放组件的地方。</li>
<li><strong>pages</strong>：所有的前端界面，该目录下的所有界面都会自动生成相应的路由。</li>
<li><strong>pages/api</strong>：项目中所有网络请求</li>
<li><strong>public</strong>：项目静态文件，可以用于存放不需要打包的文件，里面的文件打包时都会复制到另一个目录，不会经过打包处理。</li>
<li><strong>styles</strong>：为项目提供初始化或界面的样式。</li>
<li><strong>.gitignore</strong>：再向 Git 提交代码时，忽略一些文件。</li>
</ul>
<p>很轻便的一种前端结构，并没有太复杂的配置。</p>
<h2 id="界面跳转"><a href="#界面跳转" class="headerlink" title="界面跳转"></a>界面跳转</h2><p>在原本的 React 中，跳转界面主要用 react-router-dom 等框架实现，但是 Next.js 并不需要在安装 react-router-dom 插件，我们跳转界面需要在 Next.js 中引入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样便可以实现界面跳转了，但是 <code>&lt;Link /&gt;</code> 组件，只能接收一个组件，例如下面写法是错误的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">      &lt;a&gt;首页&lt;/a&gt;</span><br><span class="line">      &lt;a&gt;分类&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样是不行的，但是我们可以添加父元素便可以了。<br>当然除了组件跳转，我们也可以通过 JS 代码进行跳转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;button onClick=&#123;<span class="function">()=&gt;</span>&#123;Router.push(<span class="string">&#x27;/home&#x27;</span>)&#125;&#125;&gt;home&lt;/button&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>也是可以执行一段逻辑之后再进行跳转。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>当列表数据，进入详情界面，一般都需要通过路径将关键信息传递过去，然后进行数据查询，所以项目中路径传参的形式还是很常见的，但是<strong>由于 Next 路径都是根据文件名自动生成的，所以暂时还只支持 query 形式的传递</strong>。<br>我们通常的情况下可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/details?id=&quot;</span> + id&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当然 href 也可接收一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;(</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;Link href=&#123;&#123;<span class="attr">pathname</span>:<span class="string">&#x27;/details&#x27;</span>,<span class="attr">query</span>:&#123;<span class="attr">id</span>: id&#125;&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>详情<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;/Link&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当然通过函数式编程，使用 Router 也可以通过这种方式跳转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDetails</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">   Router.push(&#123;</span><br><span class="line">     pathname:<span class="string">&#x27;/details&#x27;</span>,</span><br><span class="line">     query: data</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="getInitialProps"><a href="#getInitialProps" class="headerlink" title="getInitialProps"></a>getInitialProps</h2><p>Next.js 为每个组件都提供了<code>getInitialProps</code>的静态方法，我们可以在该方法中获取路径传入的数据、发送网络请求等。<br>例如通过 url 传输的数据可以通过下面方式接收并使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Detailed = <span class="function">(<span class="params">&#123;id&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">Detailed.getInitialProps = <span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id = context.query.id;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样通过参数可以直接获取到传输的数据，并且使用 return 可以将数据返回给组件，组件中通过 props 直接获取到数据即可完成参数的传递，并且我们还可以在该方法里面发送网络请求获取数据，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Detailed.getInitialProps = <span class="function">(<span class="params">context</span>) =&gt;</span> &#123;</span><br><span class="line">  fetch(&#123;<span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只有执行到 return 才会渲染界面，否则界面不会进行渲染，我们可以适当的为其添加 loading 界面。</p>
<h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><p>Next.js 为用户封装了 六 个路由相关的钩子，当触发一定的条件后，钩子中的逻辑代码便会被执行，虽然还是不如 vue-router 中的导航守卫灵活和使用，但是比较有剩余无。</p>
<p>钩子分别为下面的六个：</p>
<h3 id="routeChangeStart"><a href="#routeChangeStart" class="headerlink" title="routeChangeStart"></a>routeChangeStart</h3><p>当路由发生变化时便可以监听到，使用需要对 Router 中的 events 使用 on 命令绑定钩子函数，比如我们可以这样去监听：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Router.events.on(<span class="string">&#x27;routeChangeStart&#x27;</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;routeChangeStart -&gt; 路由开始变化,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>路由一旦变化，便会立即执行绑定的钩子函数。</p>
<h3 id="routerChangeComplete"><a href="#routerChangeComplete" class="headerlink" title="routerChangeComplete"></a>routerChangeComplete</h3><p>路由变化结束之后，触发的事件为 routerChangeComplete，绑定方式和前面一样，但是其实路由改变完成后才触发的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Router.events.on(<span class="string">&#x27;routerChangeComplete&#x27;</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;routerChangeComplete -&gt; 路由变化完成,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="beforeHistoryChange"><a href="#beforeHistoryChange" class="headerlink" title="beforeHistoryChange"></a>beforeHistoryChange</h3><p>history 是 H5 新增的 API，而 Next.js 默认便是 history 类型的 url，即路径后面没有 # 号。而该钩子便是 history 改变之前触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Router.events.on(<span class="string">&#x27;beforeHistoryChange&#x27;</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeHistoryChange -&gt; history改变之前,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="routeChangeError"><a href="#routeChangeError" class="headerlink" title="routeChangeError"></a>routeChangeError</h3><p>顾名思义，当路由出现错误的时候执行的钩子函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Router.events.on(<span class="string">&#x27;routeChangeError&#x27;</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;routeChangeError -&gt; 路由错误,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="hashChangeStart"><a href="#hashChangeStart" class="headerlink" title="hashChangeStart"></a>hashChangeStart</h3><p>hashChangeStart 是针对 hash 改变之前触发的钩子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Router.events.on(<span class="string">&#x27;hashChangeStart&#x27;</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hashChangeStart -&gt; hash改变之前,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="hashChangeComplete"><a href="#hashChangeComplete" class="headerlink" title="hashChangeComplete"></a>hashChangeComplete</h3><p>hashChangeComplete 也是针对 hash 的特定钩子，表示 hash 方式的路由改变之后触发的钩子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> Router.events.on(<span class="string">&#x27;hashChangeComplete&#x27;</span>, <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hashChangeComplete -&gt; hash改变之后,参数为:&#x27;</span>,...args)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="模块懒加载"><a href="#模块懒加载" class="headerlink" title="模块懒加载"></a>模块懒加载</h2><p>这一块内容便属于内容的优化，如果需要优化项目的运行和渲染速度，可以先从这方面入手。<br>Nxt.js 提供了 <code>LazyLoading</code>主要目的便是优化项目的加载，其主要提供了模块和组件的按需加载，它们在使用时会有些不同。</p>
<h3 id="懒加载模块"><a href="#懒加载模块" class="headerlink" title="懒加载模块"></a>懒加载模块</h3><p>日常开发过程中经常在项目中添加一些其它模块，例如<code>Moment.js</code>、<code>Lodash.js</code>等，这些都是常用的模块，可以提高项目的开发速率，比如这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash‘</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Home</span></span><br><span class="line"><span class="string">  const [list, setList] = useState([]);</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  const uniqList = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    return _.uniq(list);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;&gt;</span></span><br><span class="line"><span class="string">      &#123;list.map(item =&gt; (...))&#125;</span></span><br><span class="line"><span class="string">    &lt;/&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure>
<p>这样虽然很方便，但是这样也会导致如果首页没有引入相关插件，但是 webpack 依然会将其打包进 js 中，这样便造成了不必要的加载，造成资源的浪费。而如果我们需要只有使用某些模块才去加载，那么我们就可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uniqList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _ = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> _.uniq(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样引入只有调用相应的方法，才会去加载该模块。</p>
<h3 id="懒加载组件"><a href="#懒加载组件" class="headerlink" title="懒加载组件"></a>懒加载组件</h3><p>Next.js 也提供了组件懒加载的方法，使用其包装组件后，可以只有在 jsx 代码中使用了该组件，否则不会去加载该组件，可以对加载速度进行一定的优化。<br>比如我们有这样一个组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;components&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Component;</span><br></pre></td></tr></table></figure>
<p>我们使用的时候只需封装一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">&#x27;next/dynamic&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Component = dynamic(<span class="keyword">import</span>(<span class="string">&#x27;../components/index&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这样只有使用 <code>&lt;Component /&gt;</code>组件，里面代码才会被只需，不过这一点项目中并不会太常用，因为<code>React.lazy</code>可能会是更好的选择。</p>
<h2 id="自定义Head"><a href="#自定义Head" class="headerlink" title="自定义Head"></a>自定义Head</h2><p>由于 Next.js 最大的特点还是服务端渲染，用户选用它目的便是利于SEO优化。为了更便于搜索引擎的检索，其还为我们提供 <code>&lt;Head /&gt;</code> 组件，我们可以使用其轻松设置界面的 Head：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Head <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Head&gt;</span><br><span class="line">        &lt;title&gt;www.bipch.cn&lt;/title&gt;</span><br><span class="line">      &lt;/Head&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样网站的 Head 便设置完成了。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>项目线上部署的时候是需要经过打包之后，部署打包之后的代码，为了安全不能够部署源代码，Next.js 打包也为我们提供了相关的命令：</p>
<ul>
<li>打包：next build</li>
<li>运行：next start</li>
</ul>
<p>首先执行<code>next build</code>命令对项目进行打包，打包完成后，可以运行<code>next start</code>运行项目，查看打包是否有误。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>脚手架</tag>
        <tag>服务端渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置https</title>
    <url>/nginx-https/</url>
    <content><![CDATA[<p>项目部署的时候，默认遵守为 http 协议，也是应用最为广泛的一种网络协议，而 https 可以称之为安全版的 http，也就是 http + ssl，所以 https 安全的基础便是 ssl。而如果 http 请求需要添加 ssl 证书。</p>
<a id="more"></a>

<h2 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h2><p>申请证书的方式有许多，包括阿里云、腾讯云、华为云等都能申请到SSL相关免费的证书。<br>例如申请阿里云免费SSL证书，首先进入<strong>安全（云盾）—&gt; SSL证书</strong>界面：</p>
<p><img src="https://img.bipch.cn/2021/02/03/829bb4078a9b4.png" alt="SSL证书"></p>
<p>选择购买证书，然后进入到证书资源包，依次进行选择：</p>
<p><img src="https://img.bipch.cn/2021/02/03/36be0cd0cd86b.png" alt="证书资源包"></p>
<p>选择之后，20个资源包其费用为0，直接购买付款便可以，购买完成后，进入我们的SSL列表，便可以看到证书资源包数量以及变为20，点击左侧证书资源包，进行证书的申请：</p>
<p><img src="https://img.bipch.cn/2021/02/03/29c28a7e670e5.png" alt="证书的申请"></p>
<p>因为我已经使用过两个，默认是空列表，我们点击头部按钮的证书申请，按照自己的信息，填入域名、个人信息、所在地等完成后，会进行审核，一般不到一分钟便能完成审核，完成后根据服务器类型下载相应的证书(例如Nginx)，得到其压缩包，解压后得到：<code>******.key</code>、<code>******.pem</code>两个文件，这两个便是我们所要的证书文件。</p>
<h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p>上面得到SSL证书文件之后，使用起来也是很方便，在 Linux 中安装并配置完成 Nginx 配置后，就可以配置指定的端口为 https 协议：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment"># HTTP_TO_HTTPS_START</span></span><br><span class="line">    if (<span class="variable">$server_port</span> !~ <span class="number">443</span>)&#123;</span><br><span class="line">        rewrite ^(/.*)$ https://<span class="variable">$host</span><span class="variable">$1</span> permanent<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># HTTP_TO_HTTPS_END</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># HTTP_CONFIG_START</span></span><br><span class="line">	ssl_certificate    <span class="comment"># *****.pem 文件路径;</span></span><br><span class="line">    ssl_certificate_key     <span class="comment"># *****.key 文件路径;</span></span><br><span class="line">    ssl_protocols TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span><span class="comment">;</span></span><br><span class="line">    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+<span class="number">3</span>DES:RSA+<span class="number">3</span>DES:!MD5<span class="comment">;</span></span><br><span class="line">    ssl_prefer_server_ciphers <span class="literal">on</span><span class="comment">;</span></span><br><span class="line">    ssl_session_cache shared:SSL:<span class="number">10</span>m<span class="comment">;</span></span><br><span class="line">    ssl_session_timeout <span class="number">10</span>m<span class="comment">;</span></span><br><span class="line">	<span class="comment"># HTTP_CONFIG_END</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样也可以完成了SSL证书的配置，并强制使用 https 协议，注意便是<code>ssl_certificate</code>和<code>ssl_certificate_key</code>两个路径属性的配置，执行<code>nginx -s reload</code>重启 nginx 即可生效配置。生效后会代理 443 端口，然后进行请求转发。</p>
<h2 id="宝塔配置Https"><a href="#宝塔配置Https" class="headerlink" title="宝塔配置Https"></a>宝塔配置Https</h2><p>我们可以借助宝塔的 nginx 模块，很容易的对项目添加 https 协议，使用宝塔添加完成项目后，进入配置选择SSH，然后选择<code>其它证书</code>，将 .key 文件内容复制到<strong>密钥(KEY)</strong>，另一个内容复制到<strong>证书(PEM格式)</strong>中：</p>
<p><img src="https://img.bipch.cn/2021/02/03/3de2d5793b07d.png" alt="其它证书"></p>
<p>输入后直接保存，即可自动完成项目的配置，并且还可以配置强制项目使用 https 协议，如果不是，也会定向到 https 协议中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的方法便能免费申请到阿里云的SSL证书资源包，但是其只能有20个，如果域名过多那便需要进行收费了。不过申请SSL证书的方法也要很多，并不是只有通过阿里云才能实现，这里就先抛砖引玉了。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo一键部署</title>
    <url>/hexo-aliyun/</url>
    <content><![CDATA[<p>使用 Hexo 搭建完成博客，平常会更新一些文章，但是其部署却十分的麻烦，由于 Hexo 是将 Mackdown 语法打包为 HTML 界面，每个文章对应着一个界面，这样部署起来很不方便，基本每次修改文章，都要重新登陆服务器覆盖，既然那么多重复步骤，那么 Hexo 可不可以一行命令帮我们将博客部署到服务器上呢？这是肯定的，Hexo 也给出了<a href="https://hexo.io/zh-cn/docs/one-command-deployment">相应的配置</a>。</p>
<a id="more"></a>

<h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>git 为不可或缺的工具，并且大部分服务器都内置了 git，虽然版本有一些老，但是不影响使用，执行<code>git --version</code>查询是否安装，如果没有执行：<code>yum install git</code>安装。</p>
<h3 id="创建用户-可选"><a href="#创建用户-可选" class="headerlink" title="创建用户(可选)"></a>创建用户(可选)</h3><p>除了 root 用户以外，为了安全起见，要可以创建一个管理 blog 的用户 hexo：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useradd hexo</span><br></pre></td></tr></table></figure>
<p>修改用户的权限：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">740</span> /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>搜索<code>root    ALL=(ALL)     ALL</code>(可能由于缩减的原因搜索不到，建议搜索 ALL=(ALL)，Linux vim搜索执行为先按下<strong>Esc</strong>进入命令模式，然后收入<strong>/content</strong>回车搜索)，找到后在下面添加这样一段话：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo ALL=(ALL) 	ALL</span><br></pre></td></tr></table></figure>
<p><img src="https://img.bipch.cn/2021/02/03/73359bbec9dd5.png" alt=""></p>
<p>然后输入<code>:wq</code>保存完成权限分配，权限分配后，需要设置下用户密码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">passwd hexo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建用户时可能会出现<code>adduser：警告：此主目录已经存在。</code>的错误，这是因为用户已经存在，我们可以使用 <strong>userdel -rf grid</strong> 命令删除指定的用户。</p>
</blockquote>
<h3 id="创建-Git-配置"><a href="#创建-Git-配置" class="headerlink" title="创建 Git 配置"></a>创建 Git 配置</h3><p>用户创建完成后，需要创建一个 Git 配置仓库，里面主要存放该 git 的配置，执行下面命令创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mkdir /<span class="keyword">var</span>/repo/</span><br></pre></td></tr></table></figure>
<p>创建完成后，需要对该目录和其子目录分配 hexo 用户的访问权限。执行下面命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chown -R hexo /<span class="keyword">var</span>/repo/</span><br><span class="line">chmod -R <span class="number">755</span> /<span class="keyword">var</span>/repo/</span><br></pre></td></tr></table></figure>
<p>这样仓库创建完成，我们还需要使用 git 命令初始化空仓库：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd /<span class="keyword">var</span>/repo/</span><br><span class="line">git init --bare hexo_static.git</span><br></pre></td></tr></table></figure>
<p>这样便初始化完成，并且 hexo 用户具有访问其子目录的权限。</p>
<h3 id="文件仓库"><a href="#文件仓库" class="headerlink" title="文件仓库"></a>文件仓库</h3><p>git 配置文件处理完成后，我们还需要一个地址用于存放客户端上传的文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mkdir -p /<span class="keyword">var</span>/www/blog</span><br></pre></td></tr></table></figure>
<p>同样该文件也需要 git 访问权限：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chown -R hexo /<span class="keyword">var</span>/www/blog</span><br><span class="line">chmod -R <span class="number">755</span> /<span class="keyword">var</span>/www/blog</span><br></pre></td></tr></table></figure>
<p>之后我们还需安装一些依赖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">yum install gcc-c++</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
<p>但是这样依赖服务器也有一些内置安装的。然后便须安装 Nginx 进行界面托管，Linux 下载 Nginx 方法实在太多了，也就不细说了。安装完成后编辑指定的配置，例如我的配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen <span class="number">80</span>;  <span class="comment">// 端口</span></span><br><span class="line">  server_name www.bipch.cn;  <span class="comment">// ip 或者 域名</span></span><br><span class="line">  index index.html index.htm index.php;  <span class="comment">// 默认首页文件</span></span><br><span class="line">  root  /<span class="keyword">var</span>/www/blog;  <span class="comment">// 项目根目录</span></span><br><span class="line">  location /&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个很简的配置，完成后执行<code>nginx -s reload</code>重启，然后可以再<code>/var/www/blog</code>中新增一个 HTML 类型的文件，输入路径是否可以访问，如果可以便是 Nginx 配置成功，否则表示配置有问题，或者服务器安全组没有开放默认的 80 端口。</p>
<h3 id="配置-Git-钩子"><a href="#配置-Git-钩子" class="headerlink" title="配置 Git 钩子"></a>配置 Git 钩子</h3><p>git 仓库和文件仓库都配置完成了，我们还需告诉 git 配置让其将客户端上传的文件传入到指定仓库，也就是上面的 <strong>/var/www/blog</strong>。<br>新建 git 钩子文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vim /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<p>添加后，再文件中输入下面的代码(注意文件路径)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=<span class="regexp">/var/</span>www/blog --git-dir=<span class="regexp">/var/</span>repo/hexo_static.git checkout -f</span><br></pre></td></tr></table></figure>
<p>保存完成后，将该文件变为可执行文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chmod +x /<span class="keyword">var</span>/repo/hexo_static.git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<p>配置完成后，服务器端配置结束，下面配置客户端 Hexo 即可。</p>
<h2 id="Hexo-配置"><a href="#Hexo-配置" class="headerlink" title="Hexo 配置"></a>Hexo 配置</h2><p>Hexo 配置基本都是再根目录下的<code>_config.yml</code>文件，首先我们先配置项目地址：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">url: &quot;http://www.bipch.cn/&quot;</span><br></pre></td></tr></table></figure>
<p>然后，我们还需要配置 deploy 属性：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: hexo@47.110.125.228:/var/repo/hexo_static.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>配置其提交的信息，然后还需要安装一个 Hexo 包，负责将打包后的内容发送到指定的服务器上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>这样 Hexo 配置完成，我们再 package.json 中添加一行命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;hexo clean &amp;&amp; hexo g -d &amp;&amp; hexo deploy&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样基本我们运行<code>yarn build</code>，然后输入密码等信息，就可以直接一键将我们博客通过 Git 上传到服务器了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面通过 git 将本地文件上传至服务器只是众多方式之一，除此之外还有很多的方法都能达成相同的目的，最后附带上<a href="http://www.bipch.cn/">个人的博客</a>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB安装和常用方法</title>
    <url>/linux-software/</url>
    <content><![CDATA[<p>一种非关系型的数据库，由于其高性能、易部署、易使用，并且可以通过 Mongoose 和 Node.js 完美结合起来使用，可以很方便的为 web 应用提供一种高效的存储方案，详情可以去<a href="https://www.mongodb.com/">官网</a>查看。</p>
<a id="more"></a>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>我的服务器操作系统为 centos，请根据操作系统进行安装。首先我们要去复制压缩包的下载的链接：</p>
<p><img src="https://img.bipch.cn/2021/02/03/36e0894477c7d.png" alt="MongoDB DownLoad"></p>
<p>按照自己的系统拷贝相应的链接，这里贴出我的链接：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https</span>://fastdl.mongodb.org/linux/mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span>.tgz</span><br></pre></td></tr></table></figure>
<p>拷贝完成后需要放置到服务器，一般我会放置在 <strong>/usr/local/</strong> 路径下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local</span><br><span class="line">wget https:<span class="regexp">//</span>fastdl.mongodb.org<span class="regexp">/linux/m</span>ongodb-linux-x86_64-amazon-<span class="number">4.4</span>.<span class="number">3</span>.tgz</span><br></pre></td></tr></table></figure>
<p>等待文件下载完成后，我们需要对其解压：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -zxvf mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span>.tgz</span><br><span class="line"><span class="attribute">mv</span> mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span> mongodb-linux</span><br><span class="line"><span class="attribute">rm</span> mongodb-linux-x<span class="number">86</span>_<span class="number">64</span>-amazon-<span class="number">4</span>.<span class="number">4</span>.<span class="number">3</span>.tgz</span><br></pre></td></tr></table></figure>
<p>这样通过<code>tar</code>命令进行解压，通过<code>mv</code>命令进行重命名，然后通过<code>rm</code>将压缩包删除，因为解压之后，压缩包已经失去了价值。<br>这样基本项目已经下载完成，我们还需要手动创建日志文件目录、数据库文件目录：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> mongodb-linux</span><br><span class="line"><span class="keyword">mkdir</span> <span class="keyword">db</span> logs</span><br></pre></td></tr></table></figure>
<p><strong>mongodb-linux</strong> 根目录下新建了两个文件夹<code>db</code>、<code>logs</code>分别存放数据库和日志。<br>这样配置基本完成，我们只需告诉 Mongodb 文件位置即可，在<code>bin</code>目录下新建文件<code>mongodb.conf</code>文件：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> bin</span><br><span class="line"><span class="keyword">vi</span> mongodb.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p>打开 vim 编辑文件，输入下面内容：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">dbpath=<span class="regexp">/usr/</span>local<span class="regexp">/mongodb-linux/</span>db</span><br><span class="line">logpath=<span class="regexp">/usr/</span>local<span class="regexp">/mongodb-linux/</span>logs/mongodb.log</span><br><span class="line">port=<span class="number">27017</span></span><br><span class="line">fork=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>一些基础配置：</p>
<ul>
<li><code>dbpath</code>：数据库地址。</li>
<li><code>logpath</code>：日志地址。</li>
<li><code>port</code>：端口。</li>
<li><code>fork</code>：前台还是后台运行，true 表示后台运行，否则表示前台。</li>
</ul>
<p>完成后，通过<code>:wt</code>命令退出 vim，这样基本配置完成，我们在 <strong>bin</strong> 目录下运行：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">./<span class="selector-tag">mongod</span> <span class="selector-tag">-f</span> <span class="selector-tag">mongodb</span><span class="selector-class">.conf</span></span><br></pre></td></tr></table></figure>
<p>然后执行<code>./mongo</code>即可链接上 Mongodb，然后可以通过下面方式查看版本号：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">db</span>.<span class="keyword">version</span>()</span><br></pre></td></tr></table></figure>
<p>当然如果嫌每次执行都需进入<strong>bin</strong>目录，我们可以为其配置环境变量，修改<code>/etc/profile</code>配置：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>
<p>然后只需在最后添加下面两行代码：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装路径</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">MONGODB_HOME</span>=/usr/local/mongodb-linux</span><br><span class="line"><span class="comment"># bin 目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$MONGODB_HOME/bin</span><br></pre></td></tr></table></figure>
<p>完成后，使用<code>source /etc/profile</code>命令重启即可。</p>
<h2 id="数据库常用命令"><a href="#数据库常用命令" class="headerlink" title="数据库常用命令"></a>数据库常用命令</h2><p>上面已经将 Monsedb 安装完成，下面总结下其常用的命令方便以后的使用。</p>
<h3 id="数据库列表"><a href="#数据库列表" class="headerlink" title="数据库列表"></a>数据库列表</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">show</span> dbs</span><br><span class="line"><span class="keyword">admin</span>   <span class="number">0.000</span>GB</span><br><span class="line">config  <span class="number">0.000</span>GB</span><br><span class="line"><span class="keyword">local</span>   <span class="number">0.000</span>GB</span><br></pre></td></tr></table></figure>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">use</span> react_blog</span><br><span class="line">switched <span class="keyword">to</span> db react_blog</span><br></pre></td></tr></table></figure>
<p><code>use</code>命令创建时，如果数据库不存在会进行创建后进入，如果已经存在回切换到指定数据库，所以切换到执行数据库也是该命令。</p>
<blockquote>
<p>新增的数据库使用 <code>show dbs</code> 是无法查询出的，我们只有新增数据之后才可以查询出。</p>
</blockquote>
<h3 id="当前数据库"><a href="#当前数据库" class="headerlink" title="当前数据库"></a>当前数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">react_blog</span><br></pre></td></tr></table></figure>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">&gt; db.dropDatabase()  <span class="comment"># 删除数据库</span></span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt; db  <span class="comment"># 查询当前数据库</span></span><br><span class="line">react_blog</span><br><span class="line">&gt; <span class="keyword">show </span>dbs  <span class="comment"># 查询数据库列表</span></span><br><span class="line">admin   <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line"><span class="built_in">config</span>  <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">local   <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">&gt; db.createCollection(<span class="string">&quot;user&quot;</span>)  <span class="comment"># 相当于创建一个数据库</span></span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : <span class="number">1</span> &#125;</span><br><span class="line">&gt; <span class="keyword">show </span>dbs  <span class="comment"># 在查询数据库列表</span></span><br><span class="line">admin       <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line"><span class="built_in">config</span>      <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">local       <span class="number">0</span>.<span class="number">000</span>GB</span><br><span class="line">react_blog  <span class="number">0</span>.<span class="number">000</span>GB</span><br></pre></td></tr></table></figure>
<p>可以看出虽然执行<code>dropDatabase</code>删除了该数据库，但是其当前数据库并没有改变，尽管其已经被删除，使用<code>dbs</code>查询发现已经从列表中删除，但是如果我们此时新建 Collection(可以立即为数据库中的数据表)，该操作是执行成功的，并且数据库又能查询出来。所以可以很简单的得出结论：<strong><code>dropDatabase</code> 只是清空当前数据库的所有 Collection</strong>。</p>
<h3 id="查询所有集合"><a href="#查询所有集合" class="headerlink" title="查询所有集合"></a>查询所有集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show collections</span><br><span class="line">user</span><br></pre></td></tr></table></figure>

<h2 id="collection-常用命令"><a href="#collection-常用命令" class="headerlink" title="collection 常用命令"></a>collection 常用命令</h2><p>集合就相当于 Mysql 数据库中的数据表。</p>
<h3 id="创建-collection"><a href="#创建-collection" class="headerlink" title="创建 collection"></a>创建 collection</h3><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&gt; db.createCollection(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">&#123; <span class="string">&quot;ok&quot;</span> : 1 &#125;</span><br></pre></td></tr></table></figure>
<p>该操作相当于在 Mysql 中的数据库新增一个数据表。</p>
<blockquote>
<p>当一个数据库中包含一个集合时(哪怕只是一个空集合)，便能够使用<code>dbs</code>查询出来了。</p>
</blockquote>
<h3 id="删除-collection"><a href="#删除-collection" class="headerlink" title="删除 collection"></a>删除 collection</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.user.drop()</span><br><span class="line">true</span><br><span class="line">&gt; show collections</span><br></pre></td></tr></table></figure>
<h3 id="重命名-collection"><a href="#重命名-collection" class="headerlink" title="重命名 collection"></a>重命名 collection</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; show collections</span><br><span class="line">user</span><br><span class="line">&gt; db.user.renameCollection(&quot;users&quot;)</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt; show collections</span><br><span class="line">users</span><br></pre></td></tr></table></figure>
<h2 id="关闭-MongoDB"><a href="#关闭-MongoDB" class="headerlink" title="关闭 MongoDB"></a>关闭 MongoDB</h2><p>MongoDB 启动成功后需要以正确的方式进行关闭：<br>可以使用<code>Crtl + C</code>命令直接关闭，注意此时只是退出了 MongoDB，如果退出后在连接是可以正常连接的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ^C</span><br><span class="line">bye</span><br><span class="line">&gt; .&#x2F;mongo</span><br></pre></td></tr></table></figure>
<p>这样做是完全没有问题的，如果要彻底关闭 MongoDB，排除强行关闭端口的情况下，还能使用<code>shutdownServer</code>，注意：<strong>使用该方法时<code>必须</code>在 admin 下</strong>，不然会给出下面的提示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">shutdown command <span class="keyword">only</span> works <span class="keyword">with</span> the <span class="keyword">admin</span> <span class="keyword">database</span>; try <span class="string">&#x27;use admin&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这样去关闭：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">&gt; db</span><br><span class="line">admin</span><br><span class="line">&gt; db.shutdownServer()</span><br><span class="line">server should be down...</span><br><span class="line">&gt; <span class="keyword">exit</span></span><br><span class="line">bye</span><br></pre></td></tr></table></figure>
<p>因为<code>shutdownServer</code>不会关闭当前的服务，所以我们还要加上<code>exit</code>来退出。这样即使后面再使用<code>./mongo</code>也是无法连接的。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Error-first</title>
    <url>/error-first/</url>
    <content><![CDATA[<p>在 Node 这么火的今天，其成功离不开内部高效的事件循环以及异步I/O，整个 Node 的设计从上到下都遵循着异步的概念。而 Node 处理异步指定的标准便是<code>error-first</code>也被称之为<code>错误优先</code>。</p>
<a id="more"></a>

<h2 id="error-first"><a href="#error-first" class="headerlink" title="error-first"></a>error-first</h2><p>因为 Node 中存在大量的异步，而处理异步最多的还是传入callback，对于异步任务，必须要指定任务完成后需要执行的回调函数，才能准确的接收到异步任务的执行结果。而随着callback回调越来越多，其传参也越来越多样化，Node 觉得必需对callback指定一个标准，这个标准便是<code>error-first</code>：</p>
<ol>
<li>callback函数的第一个参数为 error 对象保留。如果发生异常，异常信息会被放在第一个 err 参数返回。</li>
<li>callback函数的第二个参数保留给成功的响应数据。如果没发生异常，err参数会传递 null，第二个参数为成功后的返回数据。</li>
</ol>
<p>具体代码，可以看 Node fs 提供的回调方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&#x27;/foo.txt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Error Handling Still Needed!</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们在使用一些 Node 异步的时候也需要注意其规范，这样才能正常接收数据和处理错误。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>error-first</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2</title>
    <url>/node-koa2/</url>
    <content><![CDATA[<p>一个非常流行的基于 Node 平台的 web 开发框架，优点便是非常小，但是扩展性却极其强。非常的干净利落。和另外一个比较的开发框架 Express 作用是相同的。</p>
<a id="more"></a>

<h2 id="koa2-和-express-的区别"><a href="#koa2-和-express-的区别" class="headerlink" title="koa2 和 express 的区别"></a>koa2 和 express 的区别</h2><p>虽然 koa2 和 express 作用是相同的，并且都是原班人马打造的，但是两者使用的区别还是很大的。</p>
<ol>
<li><code>集成度</code>：koa2 是一个非常轻量级的开发框架，里面并没有继承太多的插件，例如实现 Router 还需要安装<code>koa-router</code>、加载文件需要<code>koa-static</code>，而 express 内置了大量的插件，包括router、文件等插件都进行了内置。</li>
<li><code>社区活跃度</code>：由于 express 是一款比较成熟的框架，其上手难度是比较小的，并且其社区活跃度远高于 koa2，截至本篇文章，在 npm 上对比其插件的数量如下：<br> <img src="https://img.bipch.cn/2021/02/03/9c0ccb441a373.png" alt="express"><br> <img src="https://img.bipch.cn/2021/02/03/4f5e28876c850.png" alt="koa"><br> 可以看出差别还是很大的。</li>
<li><code>中间件</code>：express 的中间件是一款典型的线性模型，也就是自上而下依次去执行，而 koa 中间件是洋葱模型。</li>
</ol>
<h2 id="洋葱模型"><a href="#洋葱模型" class="headerlink" title="洋葱模型"></a>洋葱模型</h2><p>关于 koa 中间件有一个很形象的图片：</p>
<p><img src="https://img.bipch.cn/2021/02/03/9a9139039a0d4.png" alt="koa"></p>
<p>可以看出其开始的时候，是依次开始执行，执行到<code>next</code>便会执行下一个中间件，而结束的时候是像<strong>栈</strong>操作一样，先进入的是最后去执行的。<br>例如我们可以方便的添加日志，记录每个接口的请求信息与时间：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一层 - 开始&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> ----------- <span class="subst">$&#123;ctx.url&#125;</span> ----------- <span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第一层 - 结束&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二层 - 开始&#x27;</span>)</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第二层 - 结束&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>这样便通过第一个中间件打印日志信息，当执行到<code>next</code>方法时，会执行下一个中间件直到结束碰到<code>ctx.body</code>，然后进行出栈操作。所以上面代码执行后打印出下面信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">第一层 - 开始</span><br><span class="line">第二层 - 开始</span><br><span class="line">第二层 - 结束</span><br><span class="line">打印第一次执行的结果： GET -------- / ------ 6ms</span><br><span class="line">第一层 - 结束</span><br></pre></td></tr></table></figure>

<h2 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h2><p>由于 koa 并未内置是一款小型轻量级的开发框架，并未内置过多的插件，所以一些功能需要借助一些插件来完成，例如路由的实现可以依靠<code>koa-router</code>。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 方式比较方便，并且动态路由传递方式也很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)();</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// logs</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> url <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// post router</span></span><br><span class="line">router.get(<span class="string">&#x27;/:name&#x27;</span>, <span class="function">(<span class="params">&#123;params&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello &#x27;</span> + params.name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router middleware</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>这样可以直接 get 方式请求 <a href="http://localhost:3000/koa2">http://localhost:3000/koa2</a> 最后可以返回正确的数据。</p>
<h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3><p>上面的形式只能处理简单的路径传参，但是参数复杂或者通过别的形式传参，就需要通过<code>koa-bodyparser</code>中间件处理传递过来的数据了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add koa-bodyparser middleware</span></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line"><span class="comment">// logs</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Process <span class="subst">$&#123;ctx.request.method&#125;</span> url <span class="subst">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// post params</span></span><br><span class="line">router.post(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> params = ctx.request.body;</span><br><span class="line">    ctx.response.body = <span class="string">`&lt;h1&gt;post，<span class="subst">$&#123;params.name&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get params</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> params = ctx.request.query;</span><br><span class="line">    ctx.response.body = <span class="string">`&lt;h1&gt;get，<span class="subst">$&#123;params.name&#125;</span>&lt;/h1&gt;`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add router middleware</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;app started at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>Insomnia</code>可以测试我们的接口：</p>
<p><img src="https://img.bipch.cn/2021/02/08/c48f8de1480bf.png" alt="koa-bodyparser"></p>
<p>可以看出接口返回了正确的数据。</p>
<h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><p>项目中会有些接口是需要一定的权限或者登陆后才能进行访问的，有些接口一些字段是不能重复的，但是如果将代码都重新写一遍会消耗大量的时间，同时也不利于维护，而解决方式便可以使用中间件去解决。<br>例如：一些接口需要登陆之后才能继续访问，否则返回前端<code>401</code>，那我们只需判断前端是否传入 token 和其正确性即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> checkUserMiddleware = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.request.headers[<span class="string">&quot;authorization&quot;</span>]) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> Authentication is also required</span></span><br><span class="line">        <span class="keyword">await</span> next()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 登陆失败，禁止继续执行，所以不需要执行 next()</span></span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        status: <span class="number">401</span>,</span><br><span class="line">        msg: <span class="string">&#x27;token 失效&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> checkUserMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">router.post(<span class="string">&#x27;/info&#x27;</span>, checkUserMiddleware, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样没有接口需要登陆拦截，添加上述中间件即可。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>API 开发完成后，可以直接再服务器通过 Node 运行项目完成部署，但是由于 Node 即不容易管理，并且相关 doc 窗口关闭服务便会停止，所以我们需要一个 Node 的服务管理工具，这里推荐 <a href="https://pm2.keymetrics.io/">pm2</a>。<br>启动命令很简单：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">pm2 <span class="literal">start</span> 启动文件</span><br></pre></td></tr></table></figure>
<p>也可以通过下面方式查看所有托管的服务：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">p<span class="name">m2</span> list</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>pm2 init</code>生成默认的配置文件 <strong>ecosystem.config.js</strong>，也可以配置启动命令，例如贴出我的简单配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps: [&#123;</span><br><span class="line">	<span class="comment">// 启动名称</span></span><br><span class="line">    name: <span class="string">&#x27;api&#x27;</span>,</span><br><span class="line">	<span class="comment">// 启动文件</span></span><br><span class="line">    script: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">	<span class="comment">// 监听改变</span></span><br><span class="line">    watch: <span class="literal">true</span>,</span><br><span class="line">	<span class="comment">// 忽略监听</span></span><br><span class="line">    ignore_watch: [ <span class="string">&quot;node_modules&quot;</span> ]</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="comment">// 部署配置</span></span><br><span class="line">  deploy: &#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样一个简单的 pm2 配置便完成了，然后使用下面命令启动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pm2</span> <span class="selector-tag">start</span> <span class="selector-tag">ecosystem</span><span class="selector-class">.config</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure>
<p>即可完成服务托管。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Koa2</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue $set</title>
    <url>/vue-set/</url>
    <content><![CDATA[<p>在 Vue 中其核心便是<code>数据劫持-数据订阅</code>，数据劫持主要劫持 data 对象的所有 property，并使用 <code>Object.defineProperty</code> 把所有 property 添加  getter/setter 方法。但是由于 Object.defineProperty 不能劫持整个对象，只能劫持对象的一个个属性，并且不能监听数组、对象属性等，所以在 Vue 中数组或者对象属性改变是监听不到的，而<code>$set</code>便是为了解决这些问题。</p>
<a id="more"></a>
<h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h2><p>Object.defineProperty 方法主要用于劫持 JavaScript 对象，当我们访问相应对象时，会执行相应的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;123&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;......&#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;......&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.name = <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.name);</span><br></pre></td></tr></table></figure>
<p>通过上述代码便监听了 object1 的 name 属性，一旦修改或读取便会调用相应的 getter/setter 方法，一旦数据有修改 defineProperty 便会监听到，执行一系列逻辑。</p>
<h2 id="defineProperty-监听对象"><a href="#defineProperty-监听对象" class="headerlink" title="defineProperty 监听对象"></a>defineProperty 监听对象</h2><p>在 Vue 官网却有着下面的一句话：<strong>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</strong><br>造成该问题的原因便是因为 defineProperty 不能监听整个对象，只能遍历对象的各个属性，例如我们有下面的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> object1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;123&#x27;</span>, </span><br><span class="line">  age : <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>监听这种数据，只能递归调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归，确保每个属性都被监听</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).map(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(data, key, data[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听指定数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 确保子元素监听</span></span><br><span class="line">  Observer(val);</span><br><span class="line">  <span class="comment">// 开启监听</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 不可删除</span></span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我捕获到了数据变化: &#x27;</span>, val, <span class="string">&#x27; --&gt; &#x27;</span>, newVal);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听的数据</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;123&#x27;</span>, </span><br><span class="line">  age : <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line">Observer(obj);</span><br></pre></td></tr></table></figure>
<p>这样递归才能实现对象的监听，但是这样也造成了：<strong>数组</strong> 和 <strong>对象</strong> 新增属性都是无法触发 setter 的(除了数组的 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code> 因为它们都修改原数据)。<br>而 Vue 并不会去解决这个问题，因为这是 defineProperty 方法的特性，刻意解决只会造成性能的浪费，而为了解决这个问题，便提出了 <code>$set</code> 方法。</p>
<h2 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h2><p>因为 Vue 提倡使用<code>$set</code> 进行数组等数据的修改，其主要接收 3 个参数：</p>
<ol>
<li><code>target</code>：需要添加属性的对象，也就是我们要在那个对象上面添加属性。</li>
<li><code>key</code>：新增属性的 key，也就是我们新增属性的索引。</li>
<li><code>val</code>：新增属性的值，我们要添加进的值。</li>
</ol>
<p>我们打开其源码，位于：<strong>src/core/observer/index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target: <span class="built_in">Array</span> &lt; any &gt; | <span class="built_in">Object</span>, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主要用于判断是不是基本数据类型</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    (isUndef(target) || isPrimitive(target))</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: any)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组的处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">        <span class="comment">// 利用  splice 实现数组替换</span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象，并且该属性原来已存在于对象中，则直接更新</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// vue给响应式对象(比如 data 里定义的对象)都加了一个 __ob__ 属性，</span></span><br><span class="line">  <span class="comment">// 如果一个对象有这个 __ob__ 属性，那么就说明这个对象是响应式对象，我们修改对象已有属性的时候就会触发页面渲染。</span></span><br><span class="line">  <span class="comment">// 非 data 里定义的就不是响应式对象。</span></span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不是响应式对象</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是响应式对象，进行依赖收集</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  <span class="comment">// 触发更新视图</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下上面的流程大致如下：</p>
<ol>
<li>首先判断数据是否为<strong>对象</strong>类型，如果是普通类型的属性，则会抛出异常。</li>
<li>判断是否为<strong>数组</strong>，并且 key 值是否为有效的，如果成功则选择数组长度和 key 值获取最大的数值，作为数组新的 length 值，并且使用 splice 方法进行替换。</li>
<li>判断数据值是否为响应的 _ob_：</li>
</ol>
<ul>
<li>如果是 Vue实例，直接不行，抛出错误。</li>
<li>如果不是响应数据，就是普通的修改数据对象操作。</li>
<li>如果是响应数据，那就通过 Object.defineProperty 进行数据的劫持。</li>
</ul>
<ol start="4">
<li>通知 DOM 进行数据更新。</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/es6-promise/</url>
    <content><![CDATA[<p>Promise 是异步编程的一种解决方案，由 ES6 将其写进了语言标准，统一了用法，并原生提供了Promise 对象。Promise 要用于解决前端代码中异步操作的处理，可以将异步操作队列化，使其按照指定的顺序执行，可以很好的解决代码中出现<code>回调地狱</code>的问题。</p>
<a id="more"></a>

<h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>主要前端代码需要处理多个函数，并且下一个函数的参数为前一个参数的返回值，这样便会造成回调地狱的问题。虽然看着定义有点绕，但是看下面代码就能看出回调地狱的问题了:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">startRequest1(url, <span class="function">(<span class="params">err1, res1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err1) <span class="keyword">return</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(err1.errorMsg);</span><br><span class="line">  startRequest2(res1, <span class="function">(<span class="params">err2, res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err2) <span class="keyword">return</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(err2.errorMsg);</span><br><span class="line">      startRequest3(res2, <span class="function">(<span class="params">err3, res3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err3) <span class="keyword">return</span> <span class="keyword">throw</span> <span class="built_in">Error</span>(err3.errorMsg);</span><br><span class="line">        ....</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样嵌套下去，每一次都需要处理错误，然后处理下一个请求，一旦有一个请求错误，异常也很难处理，并且代码可读性非常的低、也极难维护。</p>
<h2 id="特点和缺点"><a href="#特点和缺点" class="headerlink" title="特点和缺点"></a>特点和缺点</h2><p>Promise可以链式的处理项目中的异步操作，并提供了一系列的API，可以设置成功、失败等时候的函数调用，这样使得控制异步操作更容易。<br>Promise主要有2个特点：</p>
<ol>
<li><strong>对象状态不受外界影响</strong>。Promise主要有3中状态 <code>Pending</code>(进行中)、<code>Fulfilled</code>(已执行)、<code>Rejected</code>(已拒绝)。只有处理异步操作的结果，可以决定是哪一种状态，任何操作都无法改变这个状态。</li>
<li><strong>状态修改后，就不会发送改变，任何时候都可以得到这个结果</strong>。Promise的状态修改只有两种情况：<ol>
<li>从Pending状态变为Resolved状态。</li>
<li>从Pending状态变为Rejected状态。</li>
</ol>
</li>
</ol>
<p>只有这两种情况，一旦修改状态便被锁定了，不会在发送变化了。</p>
<p>Promise也不是都是优点，虽然解决了<code>回调地狱</code>的问题，但是也是有一些缺点的:</p>
<ol>
<li>Promise一旦创建便无法取消，只能一路走下去。</li>
<li>如果不设置处理函数，无论成功、还是失败都不会返回到外部，换句话说Promise内的错误是无法在外面用 <strong>try{…}catch(){…}</strong> 捕捉的，只能在错误执行函数中执行错误。</li>
<li>状态无法预测，无法得知异步操作具体执行到那一步了。<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2>一般 Promise 代码为下面的格式：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(...)&#123;</span><br><span class="line">  	<span class="comment">// 成功</span></span><br><span class="line">  	resolve(data);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  	<span class="comment">// 失败</span></span><br><span class="line">  	reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 请求成功</span></span><br><span class="line">	...</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 处理错误</span></span><br><span class="line">	...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
使用 Promise 对象创建一个 p，执行里面逻辑，然后注册 then 中的成功和失败事件。<h3 id="new-Promise"><a href="#new-Promise" class="headerlink" title="new Promise"></a>new Promise</h3></li>
</ol>
<ul>
<li>构造函数接收一个函数作为参数。</li>
<li>创建 Promise 时，会自动执行。</li>
<li>参数函数主要有 resolve 和 reject 两个参数。</li>
<li>在Promise执行过程中调用 resolve 函数状态将变为 fulfilled，调用 reject 时状态变成 rejected，它们可以接收参数，相应的参数都会传递给下一个方法中。</li>
</ul>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>then 主要有两个参数，分别对应两种状态，接收的数据为上一个方法传递的数据：</p>
<ul>
<li>当Promise的状态为 fulfilled 时，会执行第一个函数参数。</li>
<li>当Promise的状态为 rejected 时，会执行第二个函数参数。<h2 id="解决回调地狱"><a href="#解决回调地狱" class="headerlink" title="解决回调地狱"></a>解决回调地狱</h2>上面介绍了一些地狱回调的问题，下面开始用 Promise 解决该问题：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">startRequest1()</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest2(res))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest3(res))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest4(res))</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> startRequest5(res))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
对比下上面地狱回调代码，代码通过Promise会变得非常的简明。    <h2 id="异步并发"><a href="#异步并发" class="headerlink" title="异步并发"></a>异步并发</h2>如果多个并发的执行，只有获取全部完成后，才会返回结果。用普通的方式来编写那便是下面的代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tasks = [getData1, getData2, getData3, getData4, getData5];</span><br><span class="line"><span class="keyword">let</span> datas = [];</span><br><span class="line"></span><br><span class="line">tasks.map(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  res(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  	datas.push(data);</span><br><span class="line">  	<span class="keyword">if</span> (datas.length === tasks.length) &#123;</span><br><span class="line">      <span class="comment">// 已经全部请求完了，此时可以调用回调</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
上面通过编辑成功后通过回调传入，一旦执行完成便会进入if。很麻烦啊，Promise 提供更方便的 API：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  getData1,</span><br><span class="line">  getData2,</span><br><span class="line">  getData3,</span><br><span class="line">  getData4,</span><br><span class="line">  getData5</span><br><span class="line">]).then(<span class="function"><span class="params">datas</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 已拿到全部的data，可以处理了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
对比很明显，Promise可以将我们的请求更清晰明了。</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><code>then</code>: 上面介绍了then用法，主要用于链式进行调用。</li>
<li><code>catch</code>: 主要用于捕获Promise里面的异常，应为Promise内的异常无法用 try 进行捕获。</li>
<li><code>finally</code>: 无论Promise对象最终是成功还是失败都会去执行其中方法。</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Promise除了提供一些实例方法，还提供了一些静态的方法：</p>
<ul>
<li><code>all</code>: 主要处理并发请求。</li>
<li><code>race</code>: 和上面all相似，但是all是都成功才会调用回调，而race(赛跑)也是并发，但是一旦有一个请求完成，便会立即停止(不管结果本身是成功状态还是失败状态)。</li>
<li><code>resolve</code>: 返回一个状态为fulfilled的Promise对象，它的参数会传递给下面的回调函数中去。</li>
<li><code>reject</code>: 和上面的基本同理，只是Ppromise的状态不同。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到通过Promise创建实例，然后通过链式调用 .then.then.then 开始编码，这便是Promise的使用形式，可以看到它基本模式是：</p>
<ul>
<li>可以将异步转换为Promise。</li>
<li>对象主要有3中状态(Pending(进行中)、Fulfilled(已执行)、Rejected(已拒绝))。</li>
<li>通过 .then 进行调用。</li>
<li>完成后触发相应的回调。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>react导航守卫</title>
    <url>/react-router/</url>
    <content><![CDATA[<p>导航守卫在日常开发中经常会被使用到，比如一个界面需要登陆之后或需要某种权限才能进行访问，这样我们可以很简单的使用导航守卫实现。</p>
<a id="more"></a>
<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>vue 的导航守卫主要分为 3 种，分别为：<code>全局导航守卫</code>、<code>路由导航守卫</code>、<code>组件导航守卫</code>，而最为常用的便是全局导航守卫中的<code>beforeEach</code>，每次界面的跳转都会经过里面的逻辑，只有通过才会进行跳转。<br>例如一些组件需要登陆才能进行访问，否则进入登陆或者401界面，那么用 vue-router 可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: baseRouter</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Landing logic</span></span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每次界面的跳转都会执行里面的逻辑，只有调用<code>next()</code>才能跳转，否则我们可以为其跳转到其它界面。<br>那么 react-router 为什么不提供相应的 api 呢？其实是因为设计理念的区别，React 会选择让用户自己封装相应的功能，路由守卫功能在很久前也被人提出了<a href="https://github.com/ReactTraining/react-router/issues/4962">react-router路由拦截官方说明</a>，而作者更希望保证插件的灵活性，让用户自己封装相应代码的功能。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>项目中为了方便，我们要添加路由配置文件，然后根据配置文件生成路由.。<br>我们先定义路由数据类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> routersProps&#123;</span><br><span class="line">	<span class="comment">// 路径</span></span><br><span class="line">    path: <span class="built_in">string</span>,</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    <span class="comment">// 是否需要登陆</span></span><br><span class="line">    auth?: <span class="built_in">boolean</span>,</span><br><span class="line">    <span class="comment">// 是否严格验证</span></span><br><span class="line">    exact?: <span class="built_in">boolean</span>,</span><br><span class="line">    <span class="comment">// 组件</span></span><br><span class="line">    component: React.FC&lt;<span class="built_in">any</span>&gt;,</span><br><span class="line">    <span class="comment">// 子路由</span></span><br><span class="line">    children?: <span class="built_in">Array</span>&lt;routersProps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样定义了一些路由的数据类型，然后我们的路由数组可以这么定义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routers: <span class="built_in">Array</span>&lt;routersProps&gt; = [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">        component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../layouts/UserLayout&#x27;</span>)),</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                exact: <span class="literal">true</span>,</span><br><span class="line">                name: <span class="string">&#x27;userLogin&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;/user/login&#x27;</span>,</span><br><span class="line">                component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/login/index&#x27;</span>)),</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">        auth: <span class="literal">true</span>,</span><br><span class="line">        component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../layouts/BasicLayout&#x27;</span>)),</span><br><span class="line">        children: [</span><br><span class="line">            &#123;</span><br><span class="line">                exact: <span class="literal">true</span>,</span><br><span class="line">                name: <span class="string">&#x27;Article&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;/article&#x27;</span>,</span><br><span class="line">                component: React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/article/index&#x27;</span>)),</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样简单的定义了一些路由数组，其组件使用了<code>React.lazy</code>主要为了让组件使用的时候再去加载。</p>
<h2 id="遍历路由"><a href="#遍历路由" class="headerlink" title="遍历路由"></a>遍历路由</h2><p>既然组件已经定义完成了，下面我们需要根据配置文件遍历出组件，我们可以这样去封装组件的遍历：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface RenderRoutesProps&#123;</span><br><span class="line">    routes: <span class="built_in">Array</span>&lt;routersProps&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RenderRoutesMap: React.FC&lt;RenderRoutesProps&gt; = <span class="function">(<span class="params">&#123; routes &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                routes.map(<span class="function">(<span class="params">route, index</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (</span><br><span class="line">                        &lt;Route key=&#123;index&#125; path=&#123;route.path&#125; render=&#123;<span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">                            &lt;RouterGuard router=&#123;route&#125; routerProps=&#123;props&#125; /&gt;</span><br><span class="line">                        )&#125; /&gt;</span><br><span class="line">                    )</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RenderRoutesMap;</span><br></pre></td></tr></table></figure>
<p>这样组件<code>RenderRoutesMap</code>接收一个路由数组，但是我们并没有着急使用<code>Route</code>渲染，而是引入了另一个组件<code>RouterGuard</code>，并传入了 route(当前路由信息)、props(react-router) 作为参数。</p>
<h2 id="HOC封装"><a href="#HOC封装" class="headerlink" title="HOC封装"></a>HOC封装</h2><p>组件逻辑的判断因为需要被大量的组件使用，所以为了代码更好的复用这里使用 HOC，封装组件真正的展示：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> RouterGuardProps &#123;</span><br><span class="line">    router: routersProps,</span><br><span class="line">    routerProps: RouteComponentProps,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RouterGuard: React.FC&lt;RouterGuardProps&gt; = <span class="function">(<span class="params">&#123;router, routerProps&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, path, exact, auth, children = []&#125; = router;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Route name=&#123;name&#125; path=&#123;path&#125; key=&#123;path&#125; exact=&#123;exact&#125; render=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading....<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line">                &lt;router.component &#123;...routerProps&#125;&gt;</span><br><span class="line">                    &lt;RenderRoutesMap routes=&#123;children&#125; /&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">router.component</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">        &#125;&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RouterGuard;</span><br></pre></td></tr></table></figure>
<p>首先对组件进行渲染，因为使用了<code>React.lazy</code>包装组件，所以使用的时候要加上<code>React.Suspense</code>，然后对组件内容进行递归调用，遍历组件的 children 子元素，因为可能设计到多层嵌套，这里直接把 children 传递给<code>RenderRoutesMap</code>组件，让其循环遍历即可。</p>
<h3 id="添加逻辑处理"><a href="#添加逻辑处理" class="headerlink" title="添加逻辑处理"></a>添加逻辑处理</h3><p>上面我们基本路由已经遍历处理完成，我们可以直接在<code>RouterGuard</code>封装逻辑代码，因为我们所有路由都经过了它的封装，所以进入新的界面<code>RouterGuard</code>里面的逻辑都会执行，我们可以这样去封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RouterGuard: React.FC&lt;RouterGuardProps&gt; = <span class="function">(<span class="params">&#123;router, routerProps&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, path, exact, auth, children = []&#125; = router;</span><br><span class="line">    <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!!auth &amp;&amp; !<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>))&#123;</span><br><span class="line">            notification.error(&#123;</span><br><span class="line">                message: <span class="string">&#x27;令牌无效&#x27;</span>,</span><br><span class="line">                description:</span><br><span class="line">                <span class="string">&#x27;token 过期或失效，请重新登陆&#x27;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            routerProps.history.replace(<span class="string">&#x27;/user/login&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            setLoading(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        loading?<span class="xml"><span class="tag">&lt;<span class="name">PageLoading</span> /&gt;</span></span>:<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">...</span>/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RouterGuard;</span><br></pre></td></tr></table></figure>
<p>这样我们添加 loading 属性，当界面还在加载或验证逻辑的时候会显示 loading 界面，处理完成才展示 router，如果不符合逻辑使用<code>history.replace</code>进行重定向。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>上面代码已经基本封装完成，我们在使用路由时通过下面代码引用即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">  &lt;RenderRoutesMap routes=&#123;routes&#125; /&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure>
<p>将路由数组传入即可完成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面代码可以满足基本的导航守卫的封装，但是代码还是有很多需要改进的地方，这里就先抛砖引玉了。如果需要实现较为好用的权限路由可以使用 <a href="https://umijs.org/">umi路由</a>，其内置了许多权限和路由相关的封装。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>导航守卫</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS</title>
    <url>/XSS/</url>
    <content><![CDATA[<p><strong>XSS</strong> 是 <strong>跨域脚本攻击</strong> 的简称，表示有人不怀好心在 Web 界面中插入恶意的 Script 代码，用户浏览界面的时候，恶意嵌入的 Web 里面的恶意 Script 就会被执行，从而达到恶意攻击用户的目的。</p>
<a id="more"></a>

<h2 id="XSS攻击方式"><a href="#XSS攻击方式" class="headerlink" title="XSS攻击方式"></a>XSS攻击方式</h2><p>恶意插入 JavaScript 代码，主要在一些简单的留言板、富文本展示等界面，如果有用户在代码中恶意添加下面一行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(“hey!you are attacked”)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么后面解析到这一句话的时候，Script 代码便会被执行到，界面便会出现弹框，这便是简单的 XSS 攻击方式。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其原理就是在我们渲染 <strong>html</strong> 代码时，传入可执行的 <strong>JavaScript</strong> 代码，例如通过数据库保存为可执行代码，或者路径传参为可执行代码。<br>例如我们可以在一些文本框中输入下面内容：<br><img src="https://upload-images.jianshu.io/upload_images/7455247-39bd5204a1c40823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp" alt=""><br>这样的一段代码一旦保存到数据库中，这个 JavaScript 代码便会立即执行。也就是界面会出现下面的情况：<br><img src="https://upload-images.jianshu.io/upload_images/7455247-7df7eea8d898458c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1038/format/webp" alt=""><br>这便是 XSS 攻击的简单原理，简单来说便是将可执行的恶意 JavaScript 代码插入到界面中，使其被执行，并且它不只可以引入一小段 JS 代码，甚至我们可以直接引入一段可执行的 JS 的脚本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;*******&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种情况下脚本中代码甚至都会去执行，而在脚本中我们可以随意执行，并且可以获取到项目的私密信息，可以说对项目的危害还是非常大的。</p>
<h2 id="XSS过滤"><a href="#XSS过滤" class="headerlink" title="XSS过滤"></a>XSS过滤</h2><p>既然 <strong>XSS漏洞</strong> 危害那么大，那么  <strong>XSS漏洞</strong> 很好利用吗？肯定不是的，因为我们有许多的方式可以过滤掉 <strong>XSS漏洞</strong> 的攻击。</p>
<h3 id="过滤不合法信息"><a href="#过滤不合法信息" class="headerlink" title="过滤不合法信息"></a>过滤不合法信息</h3><p>我们可以将输入或者传入的内容中不合法信息都进行过滤，从而保证项目中数据的安全性。<br>比如移除用户输入的 DOM 属性，例如过滤掉 <strong>onclick</strong>、<strong>onerror</strong>、<strong>onload</strong> 等相关的 DOM 事件，并且移除一些用户定义的节点，例如过滤掉 <strong>&lt;style&gt;</strong>、<strong>&lt;script&gt;</strong>、<strong>&lt;iframe&gt;</strong> 等节点。</p>
<blockquote>
<p>注意：不是所有的 JavaScript 都要在 &lt;script&gt; 中才能执行，放在 &lt;img onerror=”alert(0)” src=”wwww” /&gt; 也是可以正常执行的，所以一些 DOM 事件也有必要进行过滤。</p>
</blockquote>
<h3 id="对特殊字符串进行编码"><a href="#对特殊字符串进行编码" class="headerlink" title="对特殊字符串进行编码"></a>对特殊字符串进行编码</h3><p>我们不仅需要对于输入或者传入的数据进行过滤，在前端渲染或后台保存的时候，我们还需要对字符串进行 HTML Entity 的编码处理，因为有时为了攻击网站，还可以使用一些转移的字符如：<code>&quot;&lt;&quot;</code>可以替换为<code>&amp;lt;</code>、<code>&quot;&gt;&quot;</code>可以替换为<code>&amp;gt;</code>等字符转码可以绕过一些过滤。</p>
<blockquote>
<p>并且能绕过匹配的不仅有特殊字符串，如果项目中判断不完全甚至可以用大小写绕过，例如我们这样写：&lt;scRIpt&gt;********&lt;scRIpt/&gt; 是能正常运行的，因为 JavaScript 是不区分大小写的。</p>
</blockquote>
<h3 id="httpOnly"><a href="#httpOnly" class="headerlink" title="httpOnly"></a>httpOnly</h3><p>不将信息存储到 web Storage，而存储到 <strong>cookie</strong> 中，并且为 cookie 设置为无法被读写的，为其设置上<code>httpOnly</code>，这样之后使用 JS 便不能读写 cookie 数据。</p>
<h3 id="限制长度"><a href="#限制长度" class="headerlink" title="限制长度"></a>限制长度</h3><p>因为需要添加一些可执行的 JS 代码，会是很长的一段代码，所以我们可以限制一些代码的长度，避免出现过长的代码，也可以进行简单的长度限制。</p>
<h2 id="XSS绕开过滤"><a href="#XSS绕开过滤" class="headerlink" title="XSS绕开过滤"></a>XSS绕开过滤</h2><p>道高一尺魔高一丈，项目中有很多避免 XSS 漏洞的方式，但 XSS 的攻击方式也是多种多样。</p>
<h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>上面已经介绍过，因为 JavaScript 是一种弱文本语言，并其不区分大小写，所以我们可以利用这点进行攻击，例如添加下面代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scrIPt</span>&gt;</span><span class="javascript">alert(<span class="string">&quot;hello world&quot;</span>)</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果项目判断不谨慎，很容易被该方式偷鸡。</p>
<h3 id="利用过滤语句进行攻击"><a href="#利用过滤语句进行攻击" class="headerlink" title="利用过滤语句进行攻击"></a>利用过滤语句进行攻击</h3><p>一种技巧，因为大部分项目都对 &lt;script&gt; 标签进行了过滤，那么我们便可以利用这一点对齐进行攻击。例如这样做：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;scRi<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">pt&gt;alert(<span class="string">&quot;hello world&quot;</span>)&lt;/scRi</span><span class="tag">&lt;/<span class="name">script</span>&gt;<span class="name">pt</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然这样代码看起来什么也不是，但是经过其过滤掉 &lt;script&gt; 标签后，会出现下面代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scRipt</span>&gt;</span><span class="javascript">alert(<span class="string">&quot;hello world&quot;</span>)</span><span class="tag">&lt;/<span class="name">scRipt</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>正好利用其过滤形成一条可执行语句，也是一种小技巧。</p>
<h3 id="并不是只有-script-标签才能插入可执行代码"><a href="#并不是只有-script-标签才能插入可执行代码" class="headerlink" title="并不是只有 script 标签才能插入可执行代码"></a>并不是只有 script 标签才能插入可执行代码</h3><p>我们并不是只有插入 &lt;script&gt;  才能执行 JS 的代码，我们可以使用 DOM标签 绑定事件，事件中可执行 JS 代码。例如我们这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;w.123&#x27;</span> <span class="attr">onerror</span>=<span class="string">&#x27;alert(&quot;hey!&quot;)&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果输入大意，也是可能对其项目造成危害的。</p>
<h3 id="使用转义字符"><a href="#使用转义字符" class="headerlink" title="使用转义字符"></a>使用转义字符</h3><p>因为项目都是对指定字符串进行匹配，但是 JS 中有一些特别的转义字符，大部分都是通过 “&quot; 字符进行转义，而攻击者可以使用转义输入，但是转义之后便是可执行的代码，便能达到攻击项目的目的。<br>例如这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>(\u0061\u006c\u0065\u0072\u0074(<span class="number">1</span>))</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样转移之后便是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样也可以绕过一些字符的过滤。</p>
<h2 id="XSS攻击分类"><a href="#XSS攻击分类" class="headerlink" title="XSS攻击分类"></a>XSS攻击分类</h2><p>实际项目中的漏洞是不会这么直观的，我们需要不断的换各种方式去尝试，甚至可以使用多种方式合并起来绕过项目的过滤，以达到我们的目的，而攻击的方式更是多种多样，并且XSS 的攻击大致上可以分为两类：</p>
<ul>
<li>一类是<code>反射型XSS</code>，又称为 <strong>非持久型XSS</strong>。</li>
<li>一类是<code>存储型XSS</code>，也称之为 <strong>持久型XSS</strong>。</li>
</ul>
<h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p><strong>反射型XSS</strong> 一般表示从 <strong>URL</strong> 中传入恶意攻击的代码，而界面不错任何处理便渲染到项目中。<br>这也就是说攻击相对于访问者是 <strong>一次性</strong> 的，也就是通过 <strong>URL</strong> 将恶意代码传递到界面上，而项目不对数据进行任何处理，将脚本 <strong>“反射”</strong> 到浏览器进行渲染，此时恶意脚本便执行了。<br>也就是说如果此种形式进行 <strong>XSS攻击</strong>，只能访问特定链接才能实现恶意攻击。</p>
<h3 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h3><p><strong>储存型XSS</strong> 与上面最大的不同是，它是通过将恶意代码保存到数据库中，界面读取到数据库中的恶意代码，直接渲染上面也会造成 <strong>XSS攻击</strong>。<br>例如我们在数据库中保存了一行恶意代码，然后指定用户访问时，后台将恶意代码读取出并返回到前端浏览器执行。这就意味着该用户登陆的所有地方都会执行这段恶意代码，<strong>因此存储型XSS危害更大</strong>。<br>只需要登陆指定用户到指定 URL 便可进行攻击，不需要访问特定的 URL。</p>
]]></content>
      <categories>
        <category>漏洞攻击</category>
      </categories>
      <tags>
        <tag>跨域脚本攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收机制</title>
    <url>/javascript-garbage-collection/</url>
    <content><![CDATA[<p>在 JavaScript 中所有的内存管理是自动执行的，并且都是不可见的。我们创建的基本类型、对象、函数等，这些都是需要分配内存的，但是由于其是不可见的，所以我们要明白怎么进行空间的分配、不用的时候，会发生什么呢？JS 引擎如何清理它呢？</p>
<a id="more"></a>
<h2 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h2><p>JavaScript 中内存管理的重要概念便是<code>可达性</code>，其主要负责我们项目能够访问到的值，都能够保存到内存中。其主要有下面几个要点：</p>
<ul>
<li><strong>有一组基本的固有可达值，由于显而易见的原因无法删除，这些值称为<code>根</code></strong>。<br>  例如：<ul>
<li>本地函数的局部变量和参数。</li>
<li>当前嵌套调用链上的其它函数的变量和参数。</li>
<li>全局变量。</li>
<li>还有一些其它的，内部的。</li>
</ul>
</li>
<li><strong>如果引用可以从根访问任何其它值，则认为该值是可以访问的</strong>。<br>  例如：在代码中定义一个对象，并且在别的地方对该对象进行引用，则该对象视为具有<code>可达性</code>，它引用的值也是可以访问的，而 JS 引擎中有一个后台进程称为<strong>垃圾回收器</strong>，它监视所有代码中的对象，并删除那些<strong>不具有</strong>可达性的对象。<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2>虽然叙述起来可能很绕嘴，但是其含义还是很容易理解的，例如下面代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jack&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
代码定义了一个对象<code>&#123;name: &#39;jack&#39;&#125;</code>并定义 <strong>user</strong> 指针指向该对象，此时对象<code>&#123;name: &#39;jack&#39;&#125;</code>被访问不会被清除，但是我们添加下面代码：<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">  name: &#x27;jack&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="addition">+ user = null;</span></span><br></pre></td></tr></table></figure>
这样对象<code>&#123;name: &#39;jack&#39;&#125;</code>就被覆盖掉了，其不具备<code>可达性</code>，所以此时垃圾回收器便会将其视为垃圾进行回收，释放内存。<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2>JavaScript 的垃圾回收机制有很多种，下面简单列举几种：<h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3>一种很常见的垃圾回收算法，它主要定期执行下面的步骤：</li>
</ul>
<ol>
<li>垃圾回收器获取根并 <strong>”标记“</strong> 它们。</li>
<li>然后它访问并 <strong>“标记”</strong> 所有来自它们的引用。</li>
<li>然后它访问标记对象的引用。所有被访问对象都会被记住，以便以后不再访问同一对象两次。</li>
<li>以此类推，直到引用都标记完成(从根节点开始访问)。</li>
<li>除了标记对象外，所有对象都被删除。</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>执行机制</title>
    <url>/javascript-event-loop/</url>
    <content><![CDATA[<p>在 JavaScript 的代码中都是按照一定的顺序去执行的，其每一段的代码执行，都有一定的先后顺序，这种代码的执行顺序一般称之为其执行机制。</p>
<a id="more"></a>
<h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2><p>JavaScript 的执行机制主要在意下面几点：</p>
<ol>
<li><strong>JavaScript是一门单线程语言</strong>。</li>
<li><strong>Event Loop(事件循环)是JS的执行机制</strong>。</li>
</ol>
<h2 id="为什么-JS-代码是单线程？"><a href="#为什么-JS-代码是单线程？" class="headerlink" title="为什么 JS 代码是单线程？"></a>为什么 JS 代码是单线程？</h2><p><strong>其实也很好的理解，因为JS是用来在浏览器控制一些DOM的操作的一门脚本语言，如果JS是多线程，那么两个线程同时对一个DOM元素进行相互冲突的操作，那么浏览器将无法去执行。所以JS只能是单线程的</strong>。<br>既然它只能只能是单线程，但是 JS 需要处理许多的异步请求，例如：请求网络接口、读取一些文件，延迟执行等操作，都需要使用异步去处理，否则一个请求解析时间过长那么代码就会阻塞。</p>
<h3 id="单线程-实现-“多线程”"><a href="#单线程-实现-“多线程”" class="headerlink" title="单线程 实现 “多线程”"></a>单线程 实现 “多线程”</h3><p>在 JS 中所有的异步以及多线程都可以理解为一种”假象“，例如H5新增的 WebWorker 来说，子线程有诸多的限制，不能控制DOM、不能修改全局对象等，通常只能处理一些数据逻辑。<br>这些限制并没有违背我们之前的观点，所以说是”假象“。JS异步执行机制就是 <strong>事件循环</strong>(Event Loop)，理解他就理解了异步执行机制。</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>JS 代码在执行过程中会先执行同步操作异步操作排在事件队列里，这样的理解并没有什么错误，但是如果在深入理解会发现还有一些其它的概念，比如 event table 和 event queue，具体可以下面的流程：</p>
<ol>
<li>先判断任务是同步任务还是异步，同步进入主线程运行，异步进入 event table。</li>
<li>异步在 event table 中注册事件，满足触发条件后(触发条件可能是延迟或网络请求成功)，后被推入 event queue。</li>
<li>同步任务进入主线程一直执行，一直到主线程空闲时，才会到 event queue  查看是否有可执行的异常任务，如果有就推入主线程。</li>
</ol>
<p>JS主线程执行过程中会不断的检查主线程执行栈是否为空，一旦为空，就回去 event queue 检查是否有等待被调用的函数，直至执行完毕。绘制流程图如下所示：</p>
<p><img src="https://img.bipch.cn/2021/02/03/56e4181bd3a21.png" alt=""></p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>通过上面的描述，可能还不够直观，我们用 Ajax 异步操作，执行顺序如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&#x27;*****&#x27;</span>,</span><br><span class="line">  data: [],</span><br><span class="line">  success: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    consoel.log(<span class="string">&#x27;ajax成功&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>那么它的执行顺序为：</p>
<ul>
<li>ajax 进入  <strong>event table</strong>，并注册成功的回调函数 <strong>success</strong>。</li>
<li>主线执行完成，执行<code>console.log(&#39;代码执行结束&#39;)</code>代码。</li>
<li>ajax 事件完成，回调函数进入 <strong>event queue</strong>。</li>
<li>主线程从 <strong>event queue</strong> 读取回调函数 <strong>success</strong> 并执行。</li>
</ul>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>项目中经常出现 <code>setTimeout</code>或者<code>setinterval</code>并不是特别准时，例如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout延迟&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步占用大量的事件</span></span><br><span class="line">sleep(<span class="number">999999999</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们用上面流程解释该代码会很简单，虽然其只是 0s，但是其还是异步，只是将其挂起并不会去执行，只有同步<code>sleep</code>执行完成，才会真正的去执行<code>setTimeout</code>代码，所以说不管是<code>setTimeout</code>还是<code>setinterval</code>都不会那么准时，因为 JS 会需要处理所有同步代码才会去执行异步。</p>
<h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><p>代码中除了同步和异步任务，还可以对异步任务再细一步的划分，可以再划分为：</p>
<ul>
<li><strong>宏任务</strong>：包含<code>setTimeout</code>、<code>setIntval</code>异步方式。</li>
<li><strong>微任务</strong>：包含<code>Promsie</code>异步方式。</li>
</ul>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>既然异步可以进一步细分，那细分之后，顺序是怎么样的呢？<br>其实前面没什么变化，只是对异步进行了区分：不同异步进入对应的 <strong>event queue</strong>，比如 <code>setTimeout</code> 和 <code>setIntval</code> 会进入宏任务的 <strong>event queue</strong>，而 <code>Promsie</code> 进入微任务的 <strong>event queue</strong>，虽然都是异步任务，但是 <strong>宏任务的优先级高于微任务</strong>。</p>
<h2 id="Promise的事件循环"><a href="#Promise的事件循环" class="headerlink" title="Promise的事件循环"></a>Promise的事件循环</h2><p>Promise 在进行初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完成后，继续向下执行代码，在此之前，then 的回调不会执行，同步代码执行完毕后，才会在事件循环中检查是否有可用的 Promise 回调，如果有则执行，否则继续下一个事件循环。<br>可以总结为下面流程：</p>
<ol>
<li><strong>宏任务和微任务都是队列</strong>，主线程代码执行完毕后，会执行宏任务中的同步代码。</li>
<li>进入第一轮事件循环的时候，会 <strong>把全部的 js 脚本当成宏任务运行</strong>。</li>
<li>如果执行中遇到<code>setTimeout</code>之类的宏任务，那么会将其推入 <strong>[宏任务队列]</strong> 中，下一轮宏任务执行时调用。</li>
<li>如果遇到 <code>Promise.then()</code> 之类的微观任务，就会推入到 <strong>[当前宏任务的微观任务]</strong> 中，本轮宏观任务结束后，依次执行所有微观任务。</li>
<li>如果第一轮事件循环中执行完全部的同步以及微观任务队列任务，那么这一轮事件循环便结束了，开始进行下一轮。</li>
<li>依次循环往复。</li>
</ol>
<p>结合上面定义，我们看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function">() =&gt;</span> (<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 宏任务2</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">      resolve(<span class="number">6</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 微任务1</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏任务1</span></span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 微任务2</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>结合定义一步步上面代码：</p>
<ol>
<li>第一轮将所有代码作为宏观任务，进入主线程。</li>
<li>首先遇到 new Promise 名称为 first，执行里面同步函数。</li>
<li>遇到 new Promise 名称为 p，执行同步函数，遇到里面含有的 setTimeout 将其回调注册后分发给第二轮宏观任务 event queue，并将 p 的 then 函数发布到当前任务的微任务event queue。</li>
<li>对 first 注册 then 回调，并将回调添加到微任务 event queue。</li>
<li>宏任务执行完毕，开始执行微任务…。</li>
<li>得出结果为：<strong>3</strong>、<strong>7</strong>、<strong>4</strong>、<strong>1</strong>、<strong>2</strong>、<strong>5</strong>。</li>
</ol>
<p>结合上面叙述，我们得出下面的结论：<strong>宏任务是一个栈，按照先入先执行的原理，微任务也是按照先入先执行的原理。但是每个宏任务对应都有一个微任务栈，宏任务执行过程中会先执行同步代码在执行微任务栈</strong>。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>拷贝</title>
    <url>/javascript-copy/</url>
    <content><![CDATA[<p>了解拷贝之前，必须先搞清楚 <strong>=</strong>(赋值) 和 <strong>拷贝</strong> 的区别，它们是不会相同的。<strong>赋值</strong> 只能算是”引用”，其引用的任然是同一对象，不能算是真正的拷贝，因为<strong>拷贝</strong>是重新创建了新的对象，所以赋值和拷贝本质还是有区别的。</p>
<a id="more"></a>

<h2 id="赋值与拷贝"><a href="#赋值与拷贝" class="headerlink" title="赋值与拷贝"></a>赋值与拷贝</h2><p>JS 中的拷贝可以分为<code>浅拷贝</code>和<code>深拷贝</code>，它们的主要区别如下所示：</p>
<p><strong>深拷贝</strong>：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 会 影响原数组。</p>
<p><strong>浅拷贝</strong>：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 不会 影响原数组。</p>
<p>所以结合上面的叙述，我们可以绘制出下面的表格：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>和原数据是否指向同一对象</th>
<th>第一层数据为基本数据类型</th>
<th>原数据中包含子对象</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>是</td>
<td>改变会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>浅拷贝</td>
<td>否</td>
<td>改变 <strong>不</strong> 会使原数据一同改变</td>
<td>改变会使原数据一同改变</td>
</tr>
<tr>
<td>深拷贝</td>
<td>否</td>
<td>改变 <strong>不</strong> 会使原数据一同改变</td>
<td>改变 <strong>不会</strong> 会使原数据一同改变</td>
</tr>
</tbody></table>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>我们要区分 <code>浅拷贝</code> 和 <code>赋值</code> 的区别，我们通过下面的方式进行比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;language&#x27;</span>: [</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dst = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      dst[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</span><br><span class="line"></span><br><span class="line">obj2.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj3.age = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">obj2.language[<span class="number">1</span>] = [<span class="string">&quot;二&quot;</span>, <span class="string">&quot;三&quot;</span>];</span><br><span class="line">obj3.language[<span class="number">2</span>] = [<span class="string">&quot;四&quot;</span>, <span class="string">&quot;五&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br><span class="line"><span class="comment">//obj1 = &#123;</span></span><br><span class="line"><span class="comment">//    &#x27;name&#x27; : &#x27;lisi&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;age&#x27; :  &#x27;18&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">//obj2 = &#123;</span></span><br><span class="line"><span class="comment">//    &#x27;name&#x27; : &#x27;lisi&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;age&#x27; :  &#x27;18&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"><span class="comment">//obj3 = &#123;</span></span><br><span class="line"><span class="comment">//    &#x27;name&#x27; : &#x27;zhangsan&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;age&#x27; :  &#x27;20&#x27;,</span></span><br><span class="line"><span class="comment">//    &#x27;language&#x27; : [1,[&quot;二&quot;,&quot;三&quot;],[&quot;四&quot;,&quot;五&quot;]],</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure>
<p>先定义一个原始对象 obj1，然后使用 <strong>赋值</strong> 得到第二个对象 obj2，然后通过 <strong>浅拷贝</strong> 对象 obj1 得到 obj3 对象。也就是说：</p>
<ul>
<li><strong>obj1</strong>：原始数据。</li>
<li><strong>obj2</strong>：赋值操作得到。</li>
<li><strong>obj3</strong>：浅拷贝得到。</li>
</ul>
<p>最后得出：我们在改变 <strong>obj2</strong> 和 <strong>obj3</strong> 的 <code>name</code> 属性，最后可以看出改变 <strong>obj2</strong> 会使 <strong>obj1</strong> 进行修改，而 <strong>obj3</strong> 不会修改。这就说明了 <strong>赋值只是复用引用地址</strong>，但引用还是同一对象，而 <strong>拷贝则是新创建了一个对象</strong>。而我们修改 <strong>obj2</strong> 和 <strong>obj3</strong> 的 <code>language</code> 属性时，最后是都会发生改变的，这是因为 浅拷贝 只是复制一层的对象属性，并不包括对象中的引用数据。所以修改引用类型的数据，原始数据也会进行修改。</p>
<p>从上面的实例很容易就能区分出 <strong>复制</strong> 和 <strong>浅拷贝</strong> 的真正区别。我们千万不能将 <strong>复制</strong> 直接当成 <strong>浅拷贝</strong> 进行理解。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>因为前面讲了 <strong>浅拷贝</strong> 至于 <strong>深度拷贝</strong> 其实对对象的所有子对象都进行拷贝。那么怎么实现呢？<br>其实我们递归调用 <strong>浅拷贝</strong> 对象，把所有属于对象的属性类型都遍历赋给另一个对象即可。比如下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, newObj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          newObj[key] = (obj[key].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">          deepClone(obj[key], newObj[key]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newObj[key] = obj[key]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出和 <strong>浅拷贝</strong> 非常的相似，只是遍历的时候判断如果是 <strong>对象类型</strong> 的数据，就递归继续拷贝，这样就避免 <strong>浅拷贝</strong> 子对象的问题。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>redux-saga</title>
    <url>/react-redux-saga/</url>
    <content><![CDATA[<p><code>redux-saga</code> 是一个用于管理应用程序副作用的 redux 中间件，它的目标是让副作用集中处理，然后方便以后的维护和扩展。它和其他解决异步中间件不同，它像进程一样可以主应用程序启动，暂停和取消，也能访问完整的 redux state、dispatch、redux action。</p>
<a id="more"></a>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>redux-saga 通过监听 action，只需我们发送了指定的 action，便会进行拦截。转换为流程图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/bpc99/assets@master/redux/flow/redux-saga.jpg" alt="redux-saga流程图.JPG"></p>
<p>基本可以把 saga 分解为 Worker 和 Watcher：<code>Saga = Worker + Watcher</code>。</p>
<h2 id="简单的Hello-Word"><a href="#简单的Hello-Word" class="headerlink" title="简单的Hello Word"></a>简单的Hello Word</h2><p>虽然上面说的很难理解，但是通过下面代码可以很好的理解：</p>
<h3 id="创建-Store-添加中间件"><a href="#创建-Store-添加中间件" class="headerlink" title="创建 Store 添加中间件"></a>创建 Store 添加中间件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入saga中间件</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span>;</span><br><span class="line"><span class="comment">// 创建saga</span></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line"><span class="comment">// 项目添加 saga 中间件</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducer,</span><br><span class="line">    composeWithDevTools(</span><br><span class="line">        applyMiddleware(sagaMiddleware)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="创建监听"><a href="#创建监听" class="headerlink" title="创建监听"></a>创建监听</h3><p>redux-saga 主要工作方式便是监听指定的 action，这一步还是比较重要：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery, put, delay &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="comment">// 创建新的任务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建监听函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watchIncrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听 INCREMENT_ASYNC ，派发到 incrementAsync 任务</span></span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>, incrementAsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动监听"><a href="#启动监听" class="headerlink" title="启动监听"></a>启动监听</h3><p>简单创建完成后，需要在根目录启动 redux-saga 的监听：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收集到所有的监听</span></span><br><span class="line"><span class="keyword">import</span> &#123; all, fork &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> userSagas <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> all([</span><br><span class="line">        ...Object.values(userSagas)</span><br><span class="line">    ].map(fork));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根目录启动监听</span></span><br><span class="line">sagaMiddleware.run(rootSaga);</span><br></pre></td></tr></table></figure>

<h2 id="es6-Generator"><a href="#es6-Generator" class="headerlink" title="es6 Generator"></a>es6 Generator</h2><p>主要解决异步执行造成的 <code>地狱回调</code> 问题，可以暂时让函数的执行流挂起。</p>
<p>在线验证工具：<a href="https://jsbin.com/?js,console">jsbin</a></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>简单的一个示例了解下 Generator 执行过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;start&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello word&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Gen = Generator();</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br></pre></td></tr></table></figure>
<p>其打印结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;start&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;hello word&quot;</span>&#125;</span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="string">&quot;end&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当我们创建函数时不会立即执行，当我们调用 <code>next</code> 方法时，函数会开始执行，一直到<code>yield</code> 暂停执行，挂起函数，直到下次调用 <code>next</code> 方法。函数运行返回值为一个json，done 表示是否结束，value 是返回值。</p>
<h3 id="传递参数和接收参数"><a href="#传递参数和接收参数" class="headerlink" title="传递参数和接收参数"></a>传递参数和接收参数</h3><p>当我们代码为下面样子时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="keyword">yield</span> <span class="string">&#x27;start&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="keyword">let</span> age = <span class="keyword">yield</span> <span class="string">&#x27;hello word&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Gen = Generator();</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next());</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next(<span class="string">&#x27;blog&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Gen.next(<span class="number">23</span>));</span><br></pre></td></tr></table></figure>
<p>其打印结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;start&quot;</span>&#125;</span><br><span class="line"><span class="string">&quot;blog&quot;</span></span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">&quot;hello word&quot;</span>&#125;</span><br><span class="line"><span class="number">23</span></span><br><span class="line">&#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="string">&quot;end&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>next</code> 方法参数传递给 <strong>上一个</strong> <code>yield</code> 中，达到赋值的效果。</p>
<h3 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h3><p>那么我们为什么要使用 Generator，其实主要便是为了解决项目中异步代码很容易造成<code>地狱回调</code>，而我们使用 Generator 可以很好的处理异步：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> posts = <span class="keyword">yield</span> fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;posts&#x27;</span>, posts[<span class="number">0</span>].title);</span><br><span class="line">    <span class="keyword">var</span> users = <span class="keyword">yield</span> fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;users&#x27;</span>, users[<span class="number">0</span>].name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> myGen = generator();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">yielded</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!yielded.done) &#123;</span><br><span class="line">            yielded.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> response.json();</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> handle(myGen.next(json));</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> handle(myGen.next());</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="takeEvery"><a href="#takeEvery" class="headerlink" title="takeEvery"></a>takeEvery</h3><p>很基础的一个方法，用来监测监听 action，每次发送 action 都会进行监听，拦截指定的 action 并分配新的任务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watchIncrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听拦截 INCREMENT_ASYNC action，派发新的任务</span></span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>, incrementAsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>用来发送新的 action 请求，内部是对 Redux 中 dispath 的一个封装，也是需要接收一个 action 参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; put &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>将程序延迟指定时间后执行，相当于一个延迟函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; put, delay &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样任务延迟 2 秒后会执行 put 发送一个 action。</p>
<h3 id="takeLatest"><a href="#takeLatest" class="headerlink" title="takeLatest"></a>takeLatest</h3><p>和上面的 <code>takeEvery</code> 基本相同，但是 <code>takeEvery</code> 如果这次异步还没有结束，此时若发送下一次请求，<code>takeEvery</code> 会累计放入执行队列中依次执行，而 <code>takeLatest</code> 不是，它会以取消前面的action，以最后一次发送的 action 为准：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeLatest &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">watchIncrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> takeLatest(<span class="string">&#x27;INCREMENT_ASYNC&#x27;</span>, incrementAsync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式和 <code>takeEvery</code> 基本相同。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>主要是为了帮我们的函数参数作为 call 的参数传入，返回值是一个 js对象。call 作用主要是为了方便我们测试代码，和规范我们项目代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; takeLatest, put, call &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 普通的函数</span></span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">yield</span> axios.get(<span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用call后</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">yield</span> call(axios.get, <span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><p>all 给我们提供了一种并发执行多个异步请求的操作。如果我们接口需要并发执行，则需要使用这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">yield</span> call(axios.get, <span class="string">&quot;https://jsonplaceholder.typicode.com/users&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> all([</span><br><span class="line">        fetchUser(),</span><br><span class="line">        fetchUser(),</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>非阻塞式调用：上面介绍了 call 的使用方式，但是相对于 generator 来说，<strong>call是阻塞式</strong> 的，只有上一个 promise 返回才会执行下一个。而 <strong>fork是非阻塞式</strong> 的，是并发执行所有任务，不用等到上一个任务的promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeLatest, put, call, fork &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> delay = <span class="function">(<span class="params">ms</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> fork(delay, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据结果可以看出程序并不会延迟 2 秒后发送 action，而是延迟和发送并发执行，当我们把fork变为call时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> call(delay, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>程序会等待2秒后会发送请求。</p>
<h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>用于取消 fork 还未结束的任务，防止 fork 任务等待时间过长引起其他一些不必要的错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">increment</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11111&#x27;</span>);</span><br><span class="line">        <span class="keyword">yield</span> delay(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;22222&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="keyword">yield</span> fork(increment);</span><br><span class="line">    <span class="keyword">yield</span> cancel(task);</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>当我们需要并发执行多个任务，并不一定需要等待所有操作完成，只需有一个操作完成即可继续执行下面的方法。这就是race方法的用处，它可以并发执行多个请求，只要有一个请求返回，race就正常返回请求，并且取消其余的请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a, b &#125; = <span class="keyword">yield</span> race(&#123;</span><br><span class="line">    a: call(axios.get, <span class="string">&#x27;https://jsonplaceholder.typicode.com/users&#x27;</span>),</span><br><span class="line">    b: call(axios.get, <span class="string">&#x27;https://jsonplaceholder.typicode.com/todos&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redux-saga 最为 redux 一个非常优秀的中间件，可以为 redux 解决很多问题，包括异步 action、分离逻辑等，在开发中还是很好用的。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流</title>
    <url>/antiShake-throttle/</url>
    <content><![CDATA[<p>防抖和节流在web开发中属于性能优化方面的知识，实际使用频率还是很高的，比如我们有一个高频率触发事件，每次触发都会执行一次事件绑定的函数。例如我们每次移动滚动条都要触发一个函数，那么我们每稍微移动下滚动条，便会调用很多次函数，如果函数逻辑复杂很有可能出现响应速度跟不上触发频率，出现延迟，假死、卡顿或崩溃的现象。而我们可以通过下面的几种方式优化代码。</p>
<a id="more"></a>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>实现方式：<strong>每次触发事件时设置一个延迟调用的方法，并且取消之前的延迟调用方法。</strong>这样如果短时间触发大量的同一事件，函数代码只会执行一次。<br>下面用代码实现上面逻辑，因为要一段时间之后执行某些逻辑，所以需要<code>setTineout</code>函数实现，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 防抖函数</span></span><br><span class="line"><span class="comment">* fn: 需要防抖函数</span></span><br><span class="line"><span class="comment">* delay: 防抖时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 计时器对象</span></span><br><span class="line">  <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每次执行都把 setTimeout 清除</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout); </span><br><span class="line">    <span class="comment">// 重写创建 setTimeout，主要重置 setTimeout</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防抖函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;防抖：&#x27;</span>, <span class="built_in">Math</span>.random());&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 开始防抖，500 防抖时间 </span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, debounce(handle, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>
<p>简单柯里化函数滚动条滚动之后等待 500ms 之后才能触发 handle 函数，连续执行是不会触发 handle 函数。<br>虽然实现了我们需求，它的缺点也非常的明显: 如果这个事件不断地触发，其会不断取消前面的函数，重新执行，这样函数是无法进行执行的。</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>实现方式：<strong>每次触发事件，如果当前有等待执行的延时函数，则直接 return。</strong><br>使用下面代码来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 标记，是否可以成功向下执行</span></span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 是否可以继续向下</span></span><br><span class="line">    <span class="keyword">if</span>(!canRun) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置结束，等待一段时间后，才能继续执行</span></span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 此时的值为 false </span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行节流函数</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      <span class="comment">// 执行之后，我们可以继续执行了</span></span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样封装即使事件一直执行，并不会第一时间进行触发函数，而是判断是否有函数执行，如果有则不会执行，执行前一个函数执行完成才继续触发下一个函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>防抖：</strong> 将多个操作合并为一次操作。原理就是一个计时器，在规定的 delay 时间后才能触发函数，但是如果在 delay 时间内再次触发，就会取消之前的计时器并重启设置。这样一来，只有zui’hou一次操作会被触发。</li>
<li><strong>节流：</strong> 使一段时间后触发一次函数，原理是通过判断是否有延迟函数执行，若有延迟函数执行则结束该函数。</li>
<li><strong>区别：</strong> 节流不管触发多频繁，都会保证在规定时间内一定会执行一次处理函数，而防抖只是在最后一次事件后才触发函数。如果在界面无限加载的情况下，我们需要用户滚动界面时，每隔一段时间发一次网络请求，而不是用户停下才去请求数据。这种需求就适合使用节流技术来实现。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Render-Props</title>
    <url>/react-redux-props/</url>
    <content><![CDATA[<p>render props 的作用和 hoc 的作用基本相似，根据官网的介绍其主要 <strong>用于使用一个值为函数的 prop 在 React 组件之间的代码共享</strong>，这样说似乎难以理解我们可以这样说：其核心为通过函数将 class 组件的 state 作为 props 传递给函数组件。</p>
<a id="more"></a>
<h2 id="为什么用-render-props"><a href="#为什么用-render-props" class="headerlink" title="为什么用 render props"></a>为什么用 render props</h2><p>学习技术之前一定要先明白它解决了什么样的问题，其实 render props 和 高阶组件hoc 作用一样，都是为了方便提取功能相似但逻辑有些不同的组件，可以对多个逻辑相同组件进行逻辑的提取，增加代码的灵活性。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>比如我们有这样一个需求：<strong>一个按钮有该权限时展示否则隐藏</strong>。<br>这种需求开发过程中还是很常见的，如果我们用普通的代码来写，便会出现下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isLogin</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">/**逻辑判断*/</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">this</span>.state.isLogin &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>这样即使能完成我们的需求，但是代码中存在大量的逻辑判断，代码也有很大的耦合性，并且代码非常不灵活会显得很笨重，比如需求改变为当没有权限我们要跳转界面，这样就大量组件代码又需要修改，扩展性很差。</p>
<h3 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h3><p>这种代码显然不符合我们的心意，我们需要第一次对代码封装，修改后代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictionComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isLogin</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">/**逻辑判断*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.isLogin?<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &lt;DictionComponent /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>将逻辑判断封装为一个组件，使用的时候，引入相应组件。这样虽然可以简单的封装了，但是依然不够灵活，例如需求改变为权限不足时显示一行提示文字，此时上述代码已经不满足需求，只能修改组件或在封装一个组件，这就显得代码不够灵活，这时我们便要通过 <code>render props</code> 进行封装。</p>
<h3 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h3><p>我们添加一个逻辑判断组件 <code>DictionProps</code> ，它能够动态的决定什么是需要渲染的，并能改变最终改变渲染的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictionProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isLogin</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/**逻辑判断*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state.isLogin?<span class="built_in">this</span>.props.success():<span class="built_in">this</span>.props.error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">        &lt;DictionProps success=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&#125; error=&#123;<span class="function">() =&gt;</span> <span class="string">&#x27;&#x27;</span>&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>这样我们可以完全交由 <code>DictionProps</code> 决定到底需不需要渲染，渲染的最终结果等信息，而不是写死来决定最终内容，这样需要什么组件按需传入即可，这样代码会显得非常灵活。<br>结合上面代码来说：<strong>render props 是一个用于判断最终渲染的内容的函数 prop。</strong></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>高阶组件</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/closure/</url>
    <content><![CDATA[<p>闭包在项目中还是经常会被使用的，或许使用过但是并没有特别在意到，我们可以用一句话来形容闭包为：<strong>可以访问其它函数作用域中变量的函数</strong>。</p>
<a id="more"></a>
<h2 id="闭包本质"><a href="#闭包本质" class="headerlink" title="闭包本质"></a>闭包本质</h2><p>闭包的本质源自两点，<code>作用域</code>和<code>私有性</code>：</p>
<ul>
<li><strong>作用域</strong>：就是我们定义变量的使用范围。内部函数可以访问函数外面的变量，代码执行的过程中通过<code>作用域链</code>，可以去访问外围的变量。</li>
<li><strong>私有性</strong>：我们可以将函数当作一个变量进行赋值，利用函数内部的 return 返回内部属性，这就相当于返回了一个函数的通道，我们可以使用这个通道访问函数内部定义的变量。但是这样造成一个问题，便是由于里面定义的值会被引用，所以垃圾回收器不会回收这些值，它们会一直保存下去，而且无法直接访问，必须通过对应函数进行访问，这也就是私有性。</li>
</ul>
<p>显然，闭包的形成很简单，在执行过程完毕后，一旦函数通过作用域链访问外部函数定义一些值，即形成闭包。实际上在 JavaScript 代码中闭包不要太常见。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>这个比较容易理解，作用域就是：我们定义的每个变量的使用范围。作用域又分为 全局作用域 和 局部作用域。两个使用范围不同，各有优缺点。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链就是在函数内部可以访问外部变量的机制，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样<strong>由多个执行上下文的变量对象构成的链表就叫做作用域链</strong>。</p>
<h2 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h2><p>每当程序的执行流进入到一个可执行的代码时，就进入到了一个<strong>执行环境中</strong>（EC），EC 定义变量和函数有权访问的数据。JS 中函数运行都会产生一个执行环境，并且 JS 引擎还会产生一个与当前 EC 相关联的<strong>变量对象</strong>(VO)，EC 中所有定义的变量和方法都包含在 VO 中。</p>
<p>JS引擎会以栈的方式来处理执行上下文，也就是我们通常所说的函数调用栈。栈底永远是全局上下文，栈顶则是当前正在执行的上下文。处于栈顶的执行上下文执行完毕后，会自动出栈。</p>
<p>比如下面的例子可以很好的反应 EC 的执行流程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">declare</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  update();</span><br><span class="line">&#125;</span><br><span class="line">declare();</span><br></pre></td></tr></table></figure>
<p>我们如果使用执行上下文的进栈出栈流程图如下：</p>
<p><img src="https://img.bipch.cn/2021/02/03/2ccaa5a6430c3.jpg" alt=""></p>
<p>可以看出代码总共经历下面几个步骤：</p>
<ol>
<li>首先第一步就是全局上下文入栈。</li>
<li>全局上下文入栈后，遇到的第一个可执行代码就是 declare() 函数的调用，此函数一旦调用，就会创建自己的执行上下文，此时 declare EC 入栈。</li>
<li>在新开辟的 declare EC 执行上下文中，执行内部的可执行代码，直到遇到 update() 函数调用时，又会创建一个新的执行上下文，此时 update EC 入栈。</li>
<li>当 update EC 中的可执行代码执行完毕之后，发现不再有其他执行上下文生成的情况，此上下文会自动从栈中弹出。</li>
<li>update EC 执行上下文弹出后，会继续执行 declare EC 执行上下文中的可执行代码，直到顺利执行完毕，且没有遇到其他执行上下文，则自动从栈中弹出。<br>最后执行栈中只剩下全局上下文，若浏览器不关闭，全局上下文会一直存在，直到浏览器窗口关闭，全局上下文才会最终出栈。</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React-HOC</title>
    <url>/react-hoc/</url>
    <content><![CDATA[<p><strong>HOC 是一种很好的设计模式，而不是针对某些技术的API</strong>，这种设计模式在很多 React 库中证明了其价值，并且通过它我们可以很好的复用 React 组件中代码逻辑。</p>
<a id="more"></a>
<h2 id="高阶组件是什么"><a href="#高阶组件是什么" class="headerlink" title="高阶组件是什么?"></a>高阶组件是什么?</h2><p>高阶组件简称HOC，它和高阶函数非常的相似，简单可以概况为：<strong>它是接受了一个组件，返回一个新的组件的纯函数</strong>。我们也可以将它理解为一个类工厂，它被传入了一个组件，然后返回一个经过加工的新组件。</p>
<h2 id="解决什么问题"><a href="#解决什么问题" class="headerlink" title="解决什么问题?"></a>解决什么问题?</h2><p>React 在开始时并不是使用 HOC 解决逻辑复用的问题，而是靠 Mixin 解决，虽然他非常的强大。但是它还具有非常大的隐患，让我们看下 Mixin 造成的问题：</p>
<ol>
<li><strong>破坏组件封装性</strong>: 如果我们组件中引用 Mixin 方法会为我们组件带来不可见的属性(props)和状态(state)。并且每个 Mixin 也可能相互依赖，相互耦合，非常不利于维护。</li>
<li><strong>命名冲突</strong>: 不同 Mixin 的属性方法和组件中的属性方法都可能相互覆盖相互冲突。</li>
<li><strong>雪球效应</strong>: 例如我们一个组件使用了一个 Mixin，但是 Mixin 会被多个组件引用，也就是说可能存在一个需要使 Mixin 添加更多属性或方法的组件，这样一直新增便会增加维护成本。</li>
</ol>
<p>综上所述 Mixin 具有很高的侵入性，这种代码都具有很高的隐患，所以为了解决上述问题，React 改用了 HOC。</p>
<h2 id="如何去实现？"><a href="#如何去实现？" class="headerlink" title="如何去实现？"></a>如何去实现？</h2><p>高阶组件主要有两个实现的方式，分别为 <strong>属性代理(Props Proxy)</strong>、<strong>反向继承(Inversion inherit)</strong>。但是我们无论使用那种方法都可以操作 WrappedComponent。下面主要看下如何去实现HOC。</p>
<h3 id="Props-Proxy"><a href="#Props-Proxy" class="headerlink" title="Props Proxy"></a>Props Proxy</h3><p>我们先使用一个最简单代码实现这个功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propsProxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">proopProxy</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;props proxy 模式 HOC&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span> &#125; <span class="attr">user</span> = <span class="string">&quot;props-prosy&quot;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码非常像<code>柯里化</code>的函数，这里主要是 HOC 接收了一个组件然后返回一个新的组件，并且新组件 render 也是返回了一个 WrappedComponent 的 React 元素。我们将传入的 props 收集出来，然后传入新的组件，这便是属性代理名称的由来。<br>那么我们到底使用<code>Props Proxy</code>可以做些什么?下面开始分析：</p>
<h4 id="操作-props"><a href="#操作-props" class="headerlink" title="操作 props"></a>操作 props</h4><p>我们可以修改、读取、删除、编辑传递给 WrappedComponent 组件的数据。但是我们需要小心它并没有为我们提供相关的命名空间，所以属性随时可能会发送覆盖。<br>例如我们可以在给 WrappedComponent 传递一些数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propsProxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">proopProxy</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;props proxy 模式 HOC&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span> &#125; <span class="attr">user</span> = <span class="string">&quot;props-prosy&quot;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以在 WrappedComponent 组件中使用 <code>this.props.user</code> 来获取传递的数据。</p>
<h4 id="通过-Refs-访问组件实例"><a href="#通过-Refs-访问组件实例" class="headerlink" title="通过 Refs 访问组件实例"></a>通过 Refs 访问组件实例</h4><p>使用属性代理还是可以很简单的获取 WrappedComponent 的实例引用(<code>ref</code>)，例如我们这样写:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propsProxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">proopProxy</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;props proxy 模式 HOC&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span> &#125; <span class="attr">ref</span> = <span class="string">&#123;ref</span> =&gt;</span> this.res = ref&#125; /&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样渲染完成后，我们便可以通过 proopProxy 很简单的获取到 WrappedComponent 组件的实例。</p>
<h4 id="提取-state"><a href="#提取-state" class="headerlink" title="提取 state"></a>提取 state</h4><p>属性代理情况下，我们可以将 WrappedComponent 组件的状态提取到包裹组件里，有一个常见的例子就是可以实现<strong>不受控组件</strong>到<strong>受控组件</strong>的转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 典型的不受控组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> &#123;<span class="attr">...this.props.name</span>&#125; /&gt;</span></span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HOC 工厂</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propsProxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">proopProxy</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props)</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        name: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.onNameChange = <span class="built_in">this</span>.onNameChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onNameChange</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        name: event.target.value</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">          value: <span class="built_in">this</span>.state.name,</span><br><span class="line">          onChange: <span class="built_in">this</span>.onNameChange</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span> &#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码我们可以通过 HOC 将不受控组件转换为了受控组件。其实也是通过 props 进行传输。</p>
<h4 id="添加元素包裹"><a href="#添加元素包裹" class="headerlink" title="添加元素包裹"></a>添加元素包裹</h4><p>我们使用 HOC 时还可以对 WrappedComponent 封装一些其它的 DOM 元素，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propsProxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">propsProxy</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt; <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span> &#125; /&gt;</span></span> &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inversion-inherit"><a href="#Inversion-inherit" class="headerlink" title="Inversion inherit"></a>Inversion inherit</h3><p>当然除了我们使用 <code>属性代理</code> 的方式来实现HOC，还可以使用另一项技术来实现。看下下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iInheritHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">iInherit</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>反向继承</code> 指的就是 <strong>HOC 返回的新组件去继承 WrappedComponent</strong>，因为继承关系是反着进行的，所以我们将其称为 <strong>反向继承</strong>。<br>它和属性代理不同的便是，它继承了 WrappedComponent，这就意味着它可以访问到<strong>state</strong>、<strong>props</strong>、<strong>组件生命周期</strong>、<strong>render</strong> 等方法。<br>但是虽然它能够访问 WrappedComponent 的生命周期等，但是这些尽量不要去修改，我们因该尽量保持 WrappedComponent 的完整性。</p>
<p>那么我们可以使用它来做些什么呢？下面进行分析：</p>
<h4 id="渲染劫持-Render-Highjacking"><a href="#渲染劫持-Render-Highjacking" class="headerlink" title="渲染劫持(Render Highjacking)"></a>渲染劫持(Render Highjacking)</h4><p>之所以称之为渲染劫持是因为由完全由 HOC 控制 WrappedComponent 渲染输出，进而完成控制渲染的结果。<br>例如我们可以根据参数判断渲染那部分组件，或者不进行渲染:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iInheritHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">iInherit</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.props.isRender) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至我们可以组件返回 render 的内容。例如我们 WrappedComponent 组件内容是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;input value=&#123;<span class="string">&#x27;Hello World&#x27;</span>&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> iInheritHOC(WrappedComponent)</span><br></pre></td></tr></table></figure>
<p>我们在 HOC 中控制 WrappedComponent 中 render 的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iInheritHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">iInherit</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elementsTree = <span class="built_in">super</span>.render();</span><br><span class="line">      <span class="keyword">let</span> newProps = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (elementsTree &amp;&amp; elementsTree.type === <span class="string">&#x27;input&#x27;</span>) &#123;</span><br><span class="line">        newProps = &#123;<span class="attr">value</span>: <span class="string">&#x27;may the force be with you&#x27;</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, elementsTree.props, newProps);</span><br><span class="line">      <span class="keyword">const</span> newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);</span><br><span class="line">      <span class="keyword">return</span> newElementsTree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们根据 WrappedComponent 克隆了一个新的组件，它的内容基本一样，但是我们将 value 的值修改为: may the force be with you。最后我们可以看下 <code>elementsTree</code> 与 <code>newElementsTree</code> 的区别：</p>
<p><img src="https://img.bipch.cn/2021/02/03/9b18e9faf35c3.png" alt="wrappedComponent.png"></p>
<p>在反向继承中，由于是继承我们可以修改 WrappedComponent 的 state、props、render、钩子函数等。<br>但是他有一个非常重要的问题就是：React元素(Element) 决定了 React 界面到底渲染为什么，而 React 元素有两种类型：<strong>字符串</strong> 和 <strong>函数</strong>。字符串类型的 React元素 代表DOM节点。函数 类型代表 React组件。而函数类型的 React组件 最终会被解析为一个完全由 字符串类型React元素树。这就意味着<strong>反向继承不能保证完整的子组件树被解析</strong>，也就是说我们不能操作 WrappedComponent 中的子组件了，这就是所谓的<strong>不能完全解析</strong>。<br>例如我们有下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 WrappedComponent 组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line">        &lt;MyComponent /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> propsProxyHoc(propsProsyHoc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MyComponent 组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;Hello World&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HOC封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propsProxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">propsProxy</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> elementsTree = <span class="built_in">super</span>.render();</span><br><span class="line">      <span class="built_in">console</span>.log(elementsTree)</span><br><span class="line">      <span class="keyword">return</span> elementsTree;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后得到下面的结果：</p>
<p><img src="https://img.bipch.cn/2021/02/03/c85fd0df5f38f.png" alt="wrappedComponent.png"></p>
<p>最后分析我们的组件返回的 element tree，最后发现 &lt;&gt; 组件下 <strong>div</strong> 被完全解析了，但是 <strong>MyComponent</strong> 是组件类型的，其子组件并没有完全被解析的。</p>
<h4 id="操作-state"><a href="#操作-state" class="headerlink" title="操作 state"></a>操作 state</h4><p>HOC 还可以进行读取、编辑、删除 WrappedComponent 实例的 state，但是我们最后不要去操作原组件的属性，不然很容易搞混，破坏掉一些逻辑。添加 WrappedComponent 实例的 state 时，也需要注意一些变量覆盖的问题，添加一些 state 命名空间，避免一些属性混在一起。<br>例如我们可以通过 <code>柯里化</code> 添加一些 state 初始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> propsProxyHoc = <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//?可以做一些改变 params 的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">propsProxy</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们赋初始值便可以这些写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> propsProxyHoc(&#123;<span class="attr">data</span>: <span class="string">&#x27;柯里化传参&#x27;</span>&#125;)(propsProsyHoc);</span><br></pre></td></tr></table></figure>
<p>这样 propsProsyHoc 组件中 state 便被 HOC 设置了一些初始值。</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>因为 HOC 是包裹 WrappedComponent 组件，返回新的组件这就使 WrappedComponent 失去了原先的名称，这样不利于开发或者进行调试。<br>我们通常可以在 WrappedComponent 名称前面添加一些前缀作为 HOC 返回的组件名称，例如 React-Redux：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HOC.displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br></pre></td></tr></table></figure>
<p>然后其 <code>getDisplayName</code> 的实现也很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName ||</span><br><span class="line">         WrappedComponent.name ||</span><br><span class="line">         ‘Component’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HOC-封装注意"><a href="#HOC-封装注意" class="headerlink" title="HOC 封装注意"></a>HOC 封装注意</h2><p>我们不管使用那种方式去实现 HOC 都有下面几条事项，需要去注意：</p>
<h3 id="修改原始组件"><a href="#修改原始组件" class="headerlink" title="修改原始组件"></a>修改原始组件</h3><p>例如这样去封装组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">InputComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//?通过修改prototype来修改组件</span></span><br><span class="line">  InputComponent.prototype.componentDidMount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;componentDidMount&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//?此处已经被修改了</span></span><br><span class="line">  <span class="keyword">return</span> InputComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//!组件调用</span></span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = logProps(InputComponent);</span><br></pre></td></tr></table></figure>
<p>通过这种直接去修改组件源代码的方式是不推荐的，应该尽量规避，我们可以使用 HOC 添加一些属性对 WrappedComponent 组件进行相应的扩展：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">propsProxyHoc</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">propsProxy</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;componentDidMount&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个-HOC-结合使用"><a href="#多个-HOC-结合使用" class="headerlink" title="多个 HOC 结合使用"></a>多个 HOC 结合使用</h3><p>HOC 是在 WrappedComponent 组件的基础上添加一层逻辑封装，返回一个加强的新组件。但是如果一个组件需要不同维度的增强，那么就需要多次 HOC 嵌套使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = withRouter(connect(commentSelector)(WrappedComponent));</span><br></pre></td></tr></table></figure>
<p>但是这样写代码可读性会非常低，维护成本也会增加。我们可以通过<code>compose</code>将上述代码改写为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> enhance = compose(</span><br><span class="line">  withRouter,</span><br><span class="line">  connect(commentSelector)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> EnhancedComponent = enhance(WrappedComponent)</span><br></pre></td></tr></table></figure>
<h2 id="HOC-使用注意"><a href="#HOC-使用注意" class="headerlink" title="HOC 使用注意"></a>HOC 使用注意</h2><p>在使用 HOC 时下面的几点需要注意不要出下面的问题：</p>
<h3 id="HOC-不能在-render-中使用"><a href="#HOC-不能在-render-中使用" class="headerlink" title="HOC 不能在 render 中使用"></a>HOC 不能在 render 中使用</h3><p>React的 <code>diff算法</code> 通过判断 component ID 来决定是否更新存在的子树或者删除的子树，并且重新加载一个新的。如果从 render 方法中返回返回组件(===)原来的渲染组件。但是 HOC 是一个函数，每次调用都会返回一个新的组件，所以 render 方法每次调用 diff处理。并将原有组件进行删除，重新加载一个新的组件。所以我们在 render 中不能使用 HOC。</p>
<h3 id="HOC-不包含-WrappedComponent-静态方法"><a href="#HOC-不包含-WrappedComponent-静态方法" class="headerlink" title="HOC 不包含 WrappedComponent 静态方法"></a>HOC 不包含 WrappedComponent 静态方法</h3><p>我们实现 HOC 时，通过对原始组件的加强得到并返回一个新的组件。这就造成了新组件中没有原始组件的任何静态的方法，所以如果想要在新组件中使用该静态方法的话，就需要一些特别的处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhance</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//?需要返回的组件</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  <span class="comment">//!定义静态方法</span></span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class="line">  <span class="keyword">return</span> Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式之后 HOC 返回的组件才能使用那些静态方法。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>高阶组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue插槽</title>
    <url>/vue-slot/</url>
    <content><![CDATA[<p>Vue项目开发过程中，经常遇到多个组件它们基础功能大致一样，但又存在足够的差异性，比如 Button、滚动条、表单提交 等等都需要 <strong>防抖</strong> 处理，或者多个组件，有一些共用的属性或方法，但又存在足够的差异，我们便可以使用 Vue 提供的 <strong>混入(mixin)</strong> 来进行封装。下面分析下 <a href="https://cn.vuejs.org/v2/guide/mixins.html">Mixins</a> 实现以及它的一些缺点。</p>
<a id="more"></a>
<h2 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h2><p>我们可以在子组件设置占位符，具体显示内容由父级决定。我们可以这样合成组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子组件: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>slot<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后得出下面的HTML界面:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子组件: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>slot<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样便通过父组件默认替换了子组件中的<code>&lt;slot&gt;</code>。</p>
<h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>如果我们需要在插槽中使用数据那么我们只可以使用本组组件的数据，例如我们子组件这个样子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子组件: <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>我是默认的slot<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;slotComponents&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> &#123;<span class="attr">num</span>: <span class="number">0</span>&#125;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而父组件我们这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    // 这样 name 是可以获取到本组件 name 的</span><br><span class="line">    <span class="tag">&lt;<span class="name">Child</span>&gt;</span>子组件数据：num: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">    // 这样 获取子组件数据是不行的，虽然它会替换子组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">Child</span>&gt;</span>子组件数据：num: &#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;list&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>&#125;&#125;,</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时Vue的一个规则，<strong>父级模块的所有内容都是在父级作用域中编译的；子模板中的所有内容都是在子作用域中编译的</strong>。<br>有的时候我们需要在父组件插槽内容中去访问子组件的数据，这时我们可以在子组件中把需要分享的数据，作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去。<br>例如子组件这样设置 <slot> 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 界面</span></span><br><span class="line">&lt;slot :num=<span class="string">&#x27;num&#x27;</span>&gt;我是默认的slot&lt;/slot&gt;</span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  reurn &#123;</span><br><span class="line">    num: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 就被称为<strong>插槽prop</strong>，然后我们可以在父级组件中使用带值的 <code>v-slot</code> 来定义我们提供的插槽prop的名称：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Child&gt;</span><br><span class="line">  &lt;template v-slot=<span class="string">&quot;childSource&quot;</span> &gt;子组件数据：num: &#123;&#123;childSource.num&#125;&#125;&lt;/template&gt;</span><br><span class="line">&lt;/Child&gt;</span><br></pre></td></tr></table></figure>
<p>这样我们将包含所有的插槽prop的对象命名为<code>childSource</code>，我们可以使用其获取所有子组件提供的数据。</p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>如果我们具有多个占位符，那这种情况怎么办呢? <code>&lt;slot&gt;</code>元素有一个特殊的attribute: <code>name</code>。这个属性可以用来定义额外的插槽:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个不带<code>name</code>的<code>&lt;slot&gt;</code>会带默认的名称”default”。<br>向具名插槽提供的内容时，我们可以在<code>&lt;template&gt;</code>元素上使用<code>v-slot</code>指令，并以参数的形式提供其名称：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样<code>&lt;template&gt;</code>元素中的所有内容都将会被传入相应的插槽。而没有被<code>&lt;template&gt;</code>包裹的内容都会被认为是默认插槽的内容，当然我们也可以使用<code>&lt;template v-slot:default&gt;</code>代表默认的分组。<br>因为它是一个指令，Vue的指令一般都有一个缩写的，在 2.6.0 新增了缩写<code>#</code>，例如以前遇到的<code>v-slot:header</code>都可以缩写为<code>#header</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们总结下相应的插槽使用总结：</p>
<ol>
<li>有名称的父级填充内容如果指定到子组件没有对应名称的插槽，那么改内容<code>不会</code>被替换到任何插槽中。</li>
<li>若子组件没有默认插槽，而父级如果插入默认的内容，那么这块默认的内容<code>不会</code>替换到任何一个插槽中。</li>
<li>如果子组件有多个默认插槽，而父组件指定了默认的插入内容，将 <code>会</code> <code>全部</code> 替换到子组件的每个默认插槽中。<br>这里就先总结到这里，如果有不足，后面会进行补充。</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>keep-alive</title>
    <url>/vue-keep-alive/</url>
    <content><![CDATA[<p>keep-alive 是一个由 Vue 提供的一个抽象组件，可以用来对指定的组件进行缓存，从而避免组件重写渲染影响使用体验、以及多次重复渲染降低程序性能。而 keep-alive 组件可以将组件缓存下来，避免造成上面的那些问题。</p>
<a id="more"></a>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在不使用 keep-alive 组件时，我们界面进行回退是会刷新界面的，会触发相应的生命周期函数，这时用户体验并不好(例如: 我们从列表跳转到详情界面，再从详情返回列表，这时列表默认会进行刷新)，但是如果我们引入 keep-alive 组件不但会减少项目的网络请求，还可以显著的提升用户的体验。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>keep-alive 具有 activated 和 deactivated 两个生命周期。</p>
<ul>
<li><strong>activated:</strong> 界面第一次进入，钩子触发的顺序为：<strong>create</strong> -&gt; <strong>mounted</strong> -&gt; <strong>activated</strong>。</li>
<li><strong>deactivated:</strong> 界面退出时触发 deactivated。</li>
</ul>
<blockquote>
<p>界面每次进入都会触发 activated，而如果只需要触发一次那就放在 mounted 钩子中。</p>
</blockquote>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>keep-alive 提供了一些组件属性：</p>
<ul>
<li><p><strong>include：</strong> 类型为 string 或 正则，只有组件名称匹配会进行缓存。</p>
</li>
<li><p><strong>exclude：</strong> 类型为 string 或 正则，匹配到的不会进行缓存。</p>
</li>
<li><p><strong>max：</strong> 最多可以缓存多少组件实例。</p>
</li>
<li><p>activated 和 deactivate 生命周期钩子。</p>
<h2 id="缓存界面"><a href="#缓存界面" class="headerlink" title="缓存界面"></a>缓存界面</h2><p>我们可以结合 router 缓存部分的项目界面。我们可以这样配置项目的路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">reoters: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      <span class="comment">// 缓存配置，开启</span></span><br><span class="line">      keepAlive: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样便配置了项目路由，我们要根据 keepAlive 字段，判断是否需要对路由进行缓存，修改 router-view 组件代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive v-<span class="keyword">if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-<span class="keyword">else</span>&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p>这样便根据项目路由配置，动态判断缓存是否缓存界面。</p>
<h2 id="beforeEach"><a href="#beforeEach" class="headerlink" title="beforeEach"></a>beforeEach</h2><p>它一般需要和 beforeEach 进行结合使用，删除一些无用的数据缓存。例如我们有 list 界面开启了前端缓存，那么可以看下这么问题：</p>
</li>
<li><p>当我们进入 list 界面，然后退出，此时再次进入 list 界面，此时因为界面缓存是不会进行刷新的，这明显不符合我们需求，我们要如果退出 list 再次进入，需要重新刷新界面。<br>分析下上面的功能:</p>
</li>
<li><p>入口进入 list 界面需要重新刷新。</p>
</li>
<li><p>详情界面进入 list 需要进行缓存不能刷新。</p>
</li>
</ul>
<p>为了处理上面的问题，我们需要借助 beforeEach 钩子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入口进入列表。不要缓存，进去要刷新界面</span></span><br><span class="line">to.meta.keepAlive = <span class="literal">false</span>;</span><br><span class="line">next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 详情回退列表，不要刷新</span></span><br><span class="line">to.meta.keepAlive = <span class="literal">true</span>;</span><br><span class="line">next();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy</title>
    <url>/es6-promise/</url>
    <content><![CDATA[<p>ES6中推出了 proxy 对象，主要用于在对象外搭建一层拦截，外界对目标对象的某些操作时，必须通过这次拦截。它主要用于<strong>改变某些操作的默认行为</strong>，也可以理解为<code>Object.defineproperty()</code>方法的升级版。</p>
<a id="more"></a>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>上面 Proxy 对象主要接收两个参数：</p>
<ol>
<li><code>target</code>: 参数表示所要拦截的对象。</li>
<li><code>handler</code>: 也是一个对象，用来定制拦截行为。</li>
</ol>
<p>我们可以通过下面的方式进行使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  name: <span class="string">&#x27;poetries&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> logHandler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 被读取`</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 被设置为 <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> targetWithLog = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, logHandler);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 进入 Proxy,输出: name 被读取 </span></span><br><span class="line">targetWithLog.name;</span><br><span class="line"><span class="comment">// 进入 Proxy,输出: name 被设置为 others</span></span><br><span class="line">targetWithLog.name = <span class="string">&#x27;others&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不会进入 Proxy,输出: others</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>targetWithLog</code>读取属性的值时，实际调用<code>logHandler.get</code>，在控制台输出信息，并且读取被代理的对象<code>target</code>的属性。</li>
<li><code>targetWithLog</code>设置属性的值时，实际调用<code>logHandler.set</code>，也会在控制台输出信息，并且设置代理对象<code>target</code>的属性值。</li>
</ul>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>Proxy 还提供了一系列的操作方法，用于配置相应的拦截。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>主要拦截函数的调用 <strong>call</strong> 和 <strong>apply</strong> 操作，<code>apply(target, object, args)</code>主要有3个参数，分别为：</p>
<ul>
<li><code>target</code>：目标对象(也就是代理封装的函数)。</li>
<li><code>object</code>：目标对象上的上下文对象(this);</li>
<li><code>args</code>：目标对象的参数数组(参数，是个数组，当然也可以不用，使用 arguments 也行)。</li>
</ul>
<p>例如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> twice = &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, ctx, args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am the proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> target = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;I am the target&#x27;</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, twice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码都会进入代理，值都为 I am the proxy</span></span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">proxy.call(<span class="literal">null</span>);</span><br><span class="line">proxy.apply(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>也可以计算一些数据，处理一些参数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, that, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calculate sum: <span class="subst">$&#123;argumentsList&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> target(argumentsList[<span class="number">0</span>], argumentsList[<span class="number">1</span>]) * <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, handler);</span><br><span class="line"><span class="comment">// 正常处理，输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 进入代理输出 Calculate sum: 1,2，并把结果 * 10返回</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy1(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>可以拦截读取的操作。对于不可配置(configurable)、不可写(writable)的属性，不能被代理，硬要通过 Proxy 代理会报错。<br>例如我们可以读取时，如果存在则返回，不存在则抛出异常：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&quot;Property \&quot;&quot;</span> + property + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常返回张三</span></span><br><span class="line">proxy.name</span><br><span class="line"><span class="comment">// 不存在,抛出异常</span></span><br><span class="line">proxy.age</span><br></pre></td></tr></table></figure>
<p>并且get方法是可以继承的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, propertyKey, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;GET &#x27;</span> + propertyKey);</span><br><span class="line">    <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"><span class="comment">// 输出GET foo</span></span><br><span class="line">obj.foo</span><br></pre></td></tr></table></figure>
<p>创建 Proxy 对象 proto，然后在通过<code>Object.create</code>根据 proto 创建一个新的对象 obj，通过obj访问是可以进入构造器的。<br>我们还可以读取通过get创建数组，让其读取负数索引(负数索引表示数据倒着数)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, propKey, receiver</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="built_in">Number</span>(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         propKey = <span class="built_in">String</span>(target.length + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(elements, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = createArray(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">arr[-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>通过 new Proxy 创建 了一个 Proxy，数据就是函数传输的，而 get 方法判断下标是否小于0，小于0则添加数组长度让其从右侧开始，否则直接反射。</p>
<blockquote>
<p>上面的 ownKeys 是 es6 提出的反射机制。</p>
</blockquote>
<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p>主要用于判断对象是否具有某个属性，和<code>in</code>操作非常的相似(也是用于判断对象是否包含某个key)。<br>如果原生对象不可配置、或者禁止扩展，是不能用 has 进行拦截的，不然会抛出异常。<br>我们可以使用 has 隐藏一些内部属性(一般都是”_”开始)，不被外面的 in 发现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理</span></span><br><span class="line"><span class="keyword">const</span> handler1 = &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">const</span> monster1 = &#123;</span><br><span class="line">   _secret: <span class="string">&#x27;easily scared&#x27;</span>,</span><br><span class="line">  eyeCount: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 封装代理</span></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(monster1, handler1);</span><br><span class="line"><span class="comment">// 代理开始查找，有改属性返回 true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;eyeCount&#x27;</span> <span class="keyword">in</span> proxy1);</span><br><span class="line"><span class="comment">// 代理开始查找，内部属性被隐藏，查找不到，返回 false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;_secret&#x27;</span> <span class="keyword">in</span> proxy1);</span><br><span class="line"><span class="comment">// 查找原生的，没有代理的，可以正常查找</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;_secret&#x27;</span> <span class="keyword">in</span> monster1);</span><br></pre></td></tr></table></figure>
<p>该方法主要用于隐藏一些内部字段和敏感字段。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>拦截对对象属性进行赋值的操作，返回布尔值。如果有的值不能进行赋值、不可写等都不能进行配置。<br>比如我们有一些字段需要特定的值，需要先验证在赋值，验证失败直接抛出异常：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">obj, prop, value</span>) </span>&#123;</span><br><span class="line">  	<span class="comment">// 开启 age 属性的验证</span></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">	  <span class="comment">// 不是数字</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 数据过大</span></span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功赋值</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 拿到 60</span></span><br><span class="line">person.age</span><br><span class="line"><span class="comment">// 无法赋值，抛出 The age is not an integer</span></span><br><span class="line">person.age = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">// 无法赋值，抛出 The age seems invalid</span></span><br><span class="line">person.age = <span class="number">110</span>;</span><br></pre></td></tr></table></figure>
<p>一旦数据更新便会进入代理，我们可以更新视图数据，而 Vue 中的观察 + 数据拦截，在 Vue  3.0 便是通过 Proxy 替代 Object.defineProperty 进行数据代理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了一些方法的简单使用，但是我们其实并不太需要这些的用法，因为有些 API 注定不会常用，只需有些印象，出现这种问题时，知道往那方面去学习。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>let 和 const</title>
    <url>/es6-let-const/</url>
    <content><![CDATA[<p>Es6 不仅添加一些常用的方法、对象，还对 JavaScript 的基本变量进行了扩展，在原先 var 的基础上又提出了 <strong>let</strong> 和 <strong>const</strong> 关键字。那么这两个关键字到底有什么作用，到底解决了什么问题呢？</p>
<a id="more"></a>

<h2 id="为什么要有它们"><a href="#为什么要有它们" class="headerlink" title="为什么要有它们"></a>为什么要有它们</h2><p>在 ES6 之前项目中是没有 <strong>let</strong> 和 <strong>const</strong> 关键字的，定义变量都是需要通过 <strong>var</strong> 来完成，但是由于 <strong>var</strong> 并没有作用域等概念，所以变量会比较混乱，并且如果变量定义过多也会出现一些意想不到的错误，比如下面的问题：</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>就是变量可以在声明前被使用，值为 undefined ，比如下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这明显不是我们想要的，如果变量未声明便去使用，要抛出<code>ReferenceError</code>异常。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>其实造成这个的原因便是上面的问题，例如我们有下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  a = <span class="number">456</span>;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码回抛出 <code>ReferenceError</code> 异常，是因为在块级区域声明 a，那么该区域便会和这个变量进行绑定(binding)，而你在定义变量上面进行赋值，由于此时还未能声明所以对为声明变量赋值回抛出一个异常。</p>
<h3 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h3><p>var 支持变量的重复声明，一个变量名，可以进行很多次的声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>var 中并没有什么作用域划分，常用的变量全靠覆盖，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常输出 10</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p>基于上面问题，ES6为了规范代码，提出了 let 和 const。</p>
<h2 id="块级作用域和函数声明"><a href="#块级作用域和函数声明" class="headerlink" title="块级作用域和函数声明"></a>块级作用域和函数声明</h2><p><strong>函数可以在块级作用域之中声明吗？</strong><br>ES5中规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面函数声明在ES5中都是非法的。<br>但是浏览器没有遵守该规定，为了兼容旧代码，还是支持在块级作用域之中声明函数，因此上面代码都能运行并不会报出错误。ES6则引入了块级作用域，明确允许在块级作用域中声明函数。ES6规定在块级作用域之中，函数声明语句类似于let，在块级之外不能使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>);&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>上述代码在浏览器中回报出错误<code>TypeError</code>，因为上述代码会被编辑为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">var</span> f; &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>因为 var 没有作用域的划分，所以 f() 会抛出错误。而在ES6则会编译为下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">var</span> _f; &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>可以正常打印出 <code>I am outside!</code>。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>用于定义一个常量，定义之后常量指向的内存地址不能发送改变，并且定义时一定要赋上初始值。注意是指向内存地址不能改变，不是数据不能改变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并没有改变指向，可以成功</span></span><br><span class="line">f.a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是数据被冻结，严格模式下会报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>常量 foo 指向一个冻结的对象，所以添加熟悉时不起作用。除了将对象本身冻结，也可以将对象彻底冻结：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">      constantize(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app</title>
    <url>/create-react-app/</url>
    <content><![CDATA[<p>由于 webpack 的兴起，不少技术使用 webpack 都能很方便的进行开发，但是由于其需要过多的配置，这样便浪费很多的开发时间，于是前端便出现了一系列的 webpack 相关的脚手架，目的便是更方便的进行相关开发，而 React 作为前端非常火的技术脚手架的数量更是非同一般，这里只是简单总结下使用 create-react-app 在开发过程中经常遇到的问题。</p>
<a id="more"></a>

<h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>CSS Modules 允许你在不同的文件中使用相同的 CSS classname，而无需担心命名冲突。<br>例如我们 css 样式为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况编写 className 为 red 即可，而使用 CSS Modules 便可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;.....css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p className=&#123;styles.red&#125;&gt;CSS Modules&lt;/p&gt;</span><br><span class="line">      &lt;p className=<span class="string">&quot;red&quot;</span>&gt;classname&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p>最后结果 styles.red 样式为红色，而 red 样式是空的。这便是 CSS Modules 它可以完美解决 css 样式覆盖的问题。而 create-react-app 默认便是支持 CSS Modules 的，但是只能是指定格式的文件名，例如如果文件名为：<code>index.css</code>，这样 CSS Modules 是不会生效的，只能为：<code>index.module.css</code>才能生效，根据官网的提示，命名规则必须为：<code>[name].module.css</code>否则都会无效的。</p>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>随着前后端的分离，开发过程中跨域的情况是无法避免的，前端的请求接口如果不是在后台设置相应白名单的情况下大部分都会面临着跨域的问题，而前端解决这种问题的方式也很简单，大部分都是通过 proxy 去完成，而 React 默认情况下只能在 <code>package.json</code> 中 proxy 属性添加配置，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;proxy&quot;</span>: <span class="string">&quot;http://localhost:6060&quot;</span>,</span><br></pre></td></tr></table></figure>
<p>但是大部分情况下，我们需要更灵活的配置，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">    target: <span class="string">&#x27;******&#x27;</span>,</span><br><span class="line">    ws: <span class="literal">true</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;/searchData&#x27;</span>: &#123;</span><br><span class="line">    target: <span class="string">&#x27;******&#x27;</span>,</span><br><span class="line">    ws: <span class="literal">true</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而它如果要实现这种情况只能借助一个插件<code>http-proxy-middleware</code>去完成。</p>
<h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>主要用于判断是否生成 source map，因为文件打包之后，和原本文件有着许多的差别，而为了方便调试找出错误，需要将打包之后的文件和源文件进行管理，此时一般需要 source map，虽然它很方便我们的代码调试，但是如果我们将打包放到生产环境下，会很容易保留我们项目的源码，例如下面情况：</p>
<p>而源码的暴露显然不符合我们的预期，所以我们要打包部署时关闭 devtool，防止源码暴露，但是 create-react-app 已经隐藏了 webpack 的配置，如需重新暴露，需要运行：<code>npm run eject</code>，但会暴露出全部配置，添加项目可阅读性，显然不是我们想要的，我们一般使用：<code>react-app-rewired</code> 或者 <code>craco</code> 去覆盖配置，但不论何种方法，我们需要覆盖 webpack devtool 配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">devtool: <span class="string">&#x27;inline-source-map&#x27;</span>, <span class="comment">// 调试代码用</span></span><br></pre></td></tr></table></figure>
<p>覆盖为这样的值，便解决了这个问题。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>dva</title>
    <url>/dva/</url>
    <content><![CDATA[<p>一款基于 <a href="https://github.com/reduxjs/redux">redux</a> 和 <a href="https://github.com/redux-saga/redux-saga">redux-saga</a> 基础上进行开发的数据流管理方案，并对其进内部行了封装，添加了一些代码约束。重点在于没有引入新的概念和语法，所以比较容易上手，只需明白其代码结果即可。</p>
<a id="more"></a>
<h2 id="dva-cli"><a href="#dva-cli" class="headerlink" title="dva-cli"></a>dva-cli</h2><p>首先通过npm安装 dva-cli 脚手架，帮助我们快速搭建项目：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install dva-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure>
<p>安装完成后使用<code>-v</code>查看安装版本：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">dva -v</span></span><br></pre></td></tr></table></figure>
<p>安装完成后，使用<code>new</code>命令生成项目：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">dva <span class="keyword">new</span> <span class="keyword">project</span></span><br></pre></td></tr></table></figure>
<p>可以看项目代码和结构，已经帮我们省略许多的代码。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>由于其内置并封装了 <a href="https://github.com/ReactTraining/react-router">react-router</a> 我们并不需要重新安装和配置依赖，只需根据其规则书写即可。<br>在 <code>/src/router.js</code> 添加下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/counter&quot;</span> exact component=&#123;CountPage&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>即可完成添加，但是项目的访问路径却是：/#/counter，这并不符合我们需求，需求是并不需要 #，我们需要把 # 去掉，那么问什么会出现这个符合呢？是因为 router 分为 <code>HashRouter</code> 和 <code>BrowserRouter</code>，那么这两个路由是有什么区别呢？</p>
<ul>
<li><code>HashRouter</code>：是最基础的路由，不需要浏览器 web server 支持。原理为 URL 的hash，“#”代表网页中的一个位置。其右面的字符，就是位置的标识符。单界面应用正是通过hash实现 “界面跳转” 。</li>
<li><code>BrowserRouter</code>：H5 新增了history API，IE9及以下不兼容，需要由 web server 支持。可以通过 js解析、修改界面地址，达到渲染的效果。</li>
</ul>
<p>而dva默认路由为 <strong>HashRouter</strong>，若想去掉 <strong>#</strong> 只需改为 <strong>BrowserRouter</strong>：</p>
<ol>
<li>安装history，因为 <strong>BrowserRouter</strong> 的核心为 <strong>history</strong>，所以一定要给项目添加 history：<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">yarn <span class="keyword">add</span><span class="bash"> <span class="built_in">history</span></span></span><br></pre></td></tr></table></figure></li>
<li>添加 history，安装完成后，要在根文件(<code>/src/index.js</code>)里面配置：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> createHistory <span class="keyword">from</span> <span class="string">&#x27;history/createBrowserHistory&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> app = dva(&#123;</span><br><span class="line">    history: createHistory(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这样路由就修改完成了，首页地址变为了：<a href="http://localhost:8000/">http://localhost:8000/</a>。</p>
<h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>dva 通过 Model 层将数据和逻辑连接在一起管理，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions。下面介绍下Model里面的 5 个重要属性：</p>
<ol>
<li><p><strong>namespace</strong><br>命名空间，为了防止 state 或者一些方法重复的属性，只能用字符串。</p>
</li>
<li><p><strong>state</strong><br>初始值，注意他的优先级低于创建dva时的 <code>opts.initialState</code> 属性。</p>
<blockquote>
<p>访问的时候前面要加上命名空间。</p>
</blockquote>
</li>
<li><p><strong>reducers</strong><br>主要用于处理同步操作，<strong>唯一</strong> 可以修改 state 的地方。和 redux 中 reducer 非常相似。一般格式为：<strong>(state, action) =&gt; newState</strong>。</p>
</li>
<li><p><strong>effects</strong><br>主要用于处理异步操作，他不能直接修改 state。他也是由 action 触发，也可以触发 action、和服务器交互、获取全局 state 等等。</p>
<blockquote>
<p>effects 和 reducers 属性里面的方法名不能相同，如果相同会两个都执行，然后陷入死循环。</p>
</blockquote>
</li>
<li><p><strong>subscriptions</strong><br>主要用于监听一个数据源，数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>MobX</title>
    <url>/react-introduce/</url>
    <content><![CDATA[<p>和 redux 很相似的一种数据流管理框架，但是 redux 基于函数式编程，采用单一根节点，过多的API，以及冗余的代码等问题，造成其比较难以真正的掌握，往往学习到底都是一些皮毛。而 Mobx 主要基于 <strong>观察者模式</strong>，并且具有多节点数据，相较于 redux 更加容易的掌握。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mobx 的核心概念也很简单，简单一个案例便能看清楚，根据官网的介绍 Mobx 主要有 3 个要点：observable、observer、action。分别用于表示：</p>
<ul>
<li><code>observable</code>：定义观察状态，将状态设置为可观察的。</li>
<li><code>observer</code>：将组件设置为可以响应状态的变化。</li>
<li><code>action</code>：严格模式下，修改数据的唯一途径。</li>
</ul>
<p>三个核心的概念，用户操作视图发送 <code>action</code>，导致 <code>observable</code> 的状态发生了改变，状态改变后通过 <code>observer</code> 影响到最终展示的组件，最终用户看到的界面更新。一种挺常见的单向数据流，通过 <strong>动作</strong> 修改 <strong>状态</strong>，而状态更新影响<strong>视图</strong>，官网给的图例如下所示：</p>
<p><img src="https://img.bipch.cn/2021/02/03/badd7c511c09e.png" alt="官网图例"></p>
<p>首先定义一个可观察的 Sotre 数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, action &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameStore</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;blog&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setName= <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将birds标为被观察状态，这样在birds有变动的时候，组件里才会更新</span></span><br><span class="line">decorate(NameStore, &#123;</span><br><span class="line">    birds: observable,</span><br><span class="line">    setName: action</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> NameStore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>然后在需要定义一个观测状态的组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;observer, inject&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span>&#123;NameStore&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> NameStore.setName(&#x27;action&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="xml">        &#123;NameStore.name&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> inject(<span class="string">&#x27;NameStore&#x27;</span>)(observer(App));</span><br></pre></td></tr></table></figure>
<p>这样一个观测组件便定义好了，下面只需在根组件注册 Store 数据即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> NameStore <span class="keyword">from</span> <span class="string">&#x27;./stores/NameStore&#x27;</span>;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;App NameStore=&#123;NameStore&#125; /&gt;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样一个基本的 Mobx 的 demo 便完成了，使用 Mobx 可以很方便的将项目的逻辑和视图层进行分离，视图层只需获取指定数据，发送相对于的 action 即可。并且由于 Mobx 是使用观察者模式，状态改变后会自动判断哪有组件需要重新渲染，不需要用户在使用 shouldComponentUpdate 判断是否渲染，对性能有进一步的提升。</p>
<h2 id="observable"><a href="#observable" class="headerlink" title="observable"></a>observable</h2><p>将数据设置为可观察数据，就是数据拦截，观察的数据一旦修改或者获取都会触发指定的拦截。<br>Observable 封装的数据类型可以有很多种，可以是基本类型、引用类型、普通对象、类、数组等，封装完成后 Mobx 会对数据进行微调，例如：</p>
<ul>
<li>如果类型是 <strong>Map</strong>，那么会返回一个全新的 Observable Map 对象。</li>
<li>如果类型是数组，那么会返回一个全新的 Observable Array 对象。</li>
</ul>
<p>…<br>虽然封装之后数据类型发生了改变，但是其相应的方法被没有改变，之前的方法还是能够正常的使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observableList =  mobx.observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(observableList[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(observableList.length);</span><br></pre></td></tr></table></figure>
<p>都是可以正常访问的。其绑定的原理和 Vue 的双向绑定是相似的，都可以通过 <code>Object.defineProperty</code> 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(object, key, &#123;</span><br><span class="line">  get : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        </span><br><span class="line">    <span class="comment">// 获取属性时进行拦截</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  set : <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;        </span><br><span class="line">    <span class="comment">// 设置属性的拦截</span></span><br><span class="line">    value = newValue</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样无论读取和设置都会调用相应的逻辑，一旦数据变化，便可以通知视图组件，进行相应的界面更新。</p>
<h2 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h2><p>接收一个组件作为函数的参数，返回一个对变化响应式组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observer, inject&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> inject(<span class="string">&#x27;NameStore&#x27;</span>)(observer(App));</span><br></pre></td></tr></table></figure>
<p>使用 <code>inject</code> 函数将指定数据，注入到组件数据中，通过 <code>observer</code> 将组件设置为可响应状态变化的组件，一般这两个方法需要进行配合的使用。</p>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>严格的模式下 Mobx 只能通过 action 来修改项目的 Store，不能让项目任何情况下都可以更新数据，这样项目就会难以维护。<br>项目中修改 Store 一定要在 action 中进行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">decorate(object, &#123;</span><br><span class="line">    setName: action</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>将方法设置为 action 类型，然后我们便可以在该方法里面更新数据了。action 可以很好的将我们的 Store 和逻辑代码分离，便于后面维护代码。</p>
<h2 id="对比-Redux"><a href="#对比-Redux" class="headerlink" title="对比 Redux"></a>对比 Redux</h2><p>Mobx 和 Redux 都是 React 中比较好的数据流管理工具，但是由于其核心不一样，所以两个框架还是有着很大区别的：</p>
<ol>
<li>单一数据源和多数据源，Redux 强调的便是单个 Store，而 Mobx 可以有多个 Store。</li>
<li>Reudx 只能通过手动处理数据，通过 shouldComponentUpdate 判断组件是否需要重新渲染，而 Mobx 通过 观察者模式 可以自动判断哪些组件需要重新渲染。</li>
<li>Redux 强调状态的不可变性，就算在 reducer 更新，但是只能返回新的 Store 覆盖，不能直接更新，而 Mobx 可以直接更新 Store。</li>
<li>由于 Mobx 很多逻辑代码都是封装好的，调试比较困难，也更加难以预测，而 Redux 以纯函数的形式可以让调试更简单。</li>
<li>虽然 Mobx 相对来说比较容易上手，因为其运用面向对象思维，引入一些抽象概念。而 Redux 通过函数式编程，同时借助一些中间件处理异步，所以上手难度略高于 Mobx。</li>
</ol>
<p>但是这只是一个简单的对比，具体选用还是要看团队的技术，如果简单的话可以使用 Mobx 可以，但是如果项目有着复杂的 Store 结构，Mobx 不是不可以，但是 Redux 会可以更方便的调试。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Mobx</tag>
      </tags>
  </entry>
  <entry>
    <title>react-hooks</title>
    <url>/react-hooks/</url>
    <content><![CDATA[<p>hooks 是 React 16.8 引入的新特性，它可以使我们在不编写 class 组件的情况下可以去使用 state、生命周期函数、 和其他 React 功能。并且 hooks 可以从各个组件中提取状态逻辑，以便于代码的复用，这样组件之间共享数据就变得很简单。</p>
<a id="more"></a>
<h2 id="为什么使用-hooks"><a href="#为什么使用-hooks" class="headerlink" title="为什么使用 hooks"></a>为什么使用 hooks</h2><p>项目组件起初很简单，但随着状态、逻辑、副作用的增多变为难以控制的混乱状态，每一个生命周期都包含着毫不相关逻辑代码的混合。比如我们的组件可能会在 <code>componentDidMount</code> 、<code>componentDidUpdate</code> 周期中获取处理数据，但是在同一个 <code>componentDidMount</code> 中还包含着其他的逻辑比如，注册事件的监听，最后需要在 <code>componentWillUnmount</code> 清除。这样我们毫不相连的代码就结合在了一起。这样就会导致一些逻辑的不一致。而 <strong>Hook 将组件中相互关联的部分拆分成更小的函数。</strong></p>
<h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><p>state hook 提供了在 function 组件中使用 state。并且可以抽取相同的 state 状态和逻辑是数据得到更好的复用。<br>下面举一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 赋值，初始值 0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;header className=<span class="string">&quot;App-header&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;num: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">state</span> =&gt;</span> state + <span class="number">1</span>)&#125;&gt;+&lt;/p&gt;</span><br><span class="line">        &lt;p onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">state</span> =&gt;</span> state - <span class="number">1</span>)&#125;&gt;-&lt;/p&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是调用了 <code>useState</code> 方法，<strong>那么 useState 到底做了什么呢？</strong> 它定义了一个变量<code>count</code>，这个名称可以是任意的，useState 返回值是个数组，我们可以使用任意名称接收。setCount 为修改数据需要调用的方法，它与 class 里的 <code>this.state</code> 提供的功能完全相同。但是函数中的变量退出后会消失，而 state 中的变量会在 React 中保留。</p>
<blockquote>
<p>useState 进行数据赋值是覆盖式更新，<strong>并不会合并数据</strong> 如果数据格式复杂注意不要覆盖一些变量。一些复杂的数据格式我们可以使用 es6 的扩展运算符帮助我们解决数据覆盖的问题，如 {…source, count: 1} 这样 count 就会覆盖 source 中的 count。</p>
</blockquote>
<h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><p>Effect Hook 可以让我们在函数组件中执行副作用操作，如果你熟悉 React class 的生命周期那么就可以将 Effect Hook 看作 <code>componentDidMount</code>， <code>componentDidUpdate</code>， <code>componentWillUnmount</code> 这三个函数的组合。我们可以在这个地方获取数据、设置订阅，手动的更改 DOM等操作，也可以在卸载一些订阅。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 赋值，初始值 0</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`you clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;header className=<span class="string">&quot;App-header&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;num: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">state</span> =&gt;</span> state + <span class="number">1</span>)&#125;&gt;+&lt;/p&gt;</span><br><span class="line">        &lt;p onClick=&#123;<span class="function">() =&gt;</span> setCount(<span class="function"><span class="params">state</span> =&gt;</span> state - <span class="number">1</span>)&#125;&gt;-&lt;/p&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就会监听 count 的变化，如果 <code>[count]</code> 中的任意数据有所变化，便会执行相应的 <code>useEffect</code> 中的代码。<br>主要有下面几点需要说明：</p>
<ol>
<li><code>useEffect(callback: () =&gt; void，deps: array[])</code> 方法接收两个参数，第二个为选填参数。表示 Effect 更新需要依赖那些属性。</li>
<li>由于一个组件可以有多个 Effect 所以我们有的 Effect 并不是有属性更新便会调用，而是具体指定 Effect 的依赖列表。</li>
<li>第一个参数界面加载完成后便会执行相当于 <code>componentDidMount</code> ，如果有依赖列表数据变化，便会在执行该函数，这时相当于 <code>componentDidUpdate</code>，如果该函数返回了一个函数，则返回的函数会在组件卸载时调用，这时相当于 <code>componentWillUnmount</code>。<h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure>
接收一个 <code>Context</code> 对象(使用 React 提供的 <strong>createContext</strong> 创建)，并会寻找距离当前组件最近的一个 <code>Provider</code> 的 value 值。<br>首先创建一个 context 对象：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UserContext = createContext(&#123;&#125;);</span><br></pre></td></tr></table></figure>
这样 context 对象就被创建好了，下面在调用其 Provider 组件设置初始值：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;UserContext&#125; <span class="keyword">from</span> <span class="string">&#x27;./UserContext&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> UserInfo <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="string">&#x27;blog&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;UserContext.Provider value=&#123; &#123; user, setUser &#125; &#125;&gt;</span><br><span class="line">      &lt;UserInfo /&gt;</span><br><span class="line">    &lt;/UserContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> User;</span><br></pre></td></tr></table></figure>
这样 context 组件已经创建完成了，下面写子组件并使用 useContext 获取到设置的初始值即可：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;UserContext&#125; <span class="keyword">from</span> <span class="string">&#x27;./UserContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; user, setUser &#125; = useContext(UserContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;user&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick = &#123;<span class="function">() =&gt;</span> setUser(<span class="string">&#x27;123123&#x27;</span>)&#125;&gt;</span><br><span class="line">        set name</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样我们就通过 context 完成了组件之间数据的传输。<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2>用于缓存组件中一些方法计算的结果，比如组件中的某一数据需要复杂计算而来，为了节约性能可以通过缓存计算结果并在下一个操作中重新使用缓存来加速查找费时的操作。而 useMemo 就是使用 <code>memoization</code> 来提升组件的性能，这里不过多介绍。这里我们需要传给它一个依赖列表，它的值会作为 key，如果 key 值不变函数只会执行第一次后面便会从缓存获取，只有 key 修改才会进行重新计算。<br>修改下上面组件代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> UserInfo <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123;</span><br><span class="line">    name: <span class="string">&#x27;blog&#x27;</span>,</span><br><span class="line">    other: <span class="number">1</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;UserInfo user=&#123;user&#125; setUser=&#123;setUser&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> User;</span><br></pre></td></tr></table></figure>
修改子组件代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;memo, useMemo&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> memo(</span><br><span class="line">  (&#123;user, setUser&#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name, other&#125; = user;</span><br><span class="line">    <span class="keyword">const</span> useOther = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 复杂的逻辑</span></span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;没有缓存&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> other;</span><br><span class="line">    &#125;, [other]);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;name: &#123;name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;other: &#123;useOther&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button onClick = &#123;<span class="function">() =&gt;</span> setUser(&#123;</span><br><span class="line">          ...user,</span><br><span class="line">          name: <span class="string">&#x27;123123&#x27;</span></span><br><span class="line">        &#125;)&#125;&gt;</span><br><span class="line">            set name</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;button onClick = &#123;<span class="function">() =&gt;</span> setUser(&#123;</span><br><span class="line">            ...user,</span><br><span class="line">            other: <span class="number">0</span></span><br><span class="line">        &#125;)&#125;&gt;</span><br><span class="line">            set other</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> User;</span><br></pre></td></tr></table></figure>
这样只有 useMemo 函数中依赖项中的数据变化，才会执行函数中的值，否则会在缓存中进行获取。这样就极大提升了程序的性能。<blockquote>
<p>注意 <code>useMemo</code> 函数会在渲染期间执行。不要在该函数内部执行与渲染无关的操作，如果需要添加一些副作用函数要在 <code>useEffect</code> 而不是 <code>useMemo</code>。</p>
</blockquote>
</li>
</ol>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>该函数的作用和上面的 <code>useMemo</code> 作用非常的相似，但是它返回的是一个缓存函数。比如我们和上面一样也做一个测试:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> Count = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> [val, setVal] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> callback = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;, [count]);</span><br><span class="line">    set.add(callback);</span><br><span class="line">    <span class="built_in">console</span>.log(set);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h4&gt;size: &#123;set.size&#125;&lt;/h4&gt;</span><br><span class="line">            &lt;h4&gt;count: &#123;count&#125;&lt;/h4&gt;</span><br><span class="line">            &lt;h4&gt;val: &#123;val&#125;&lt;/h4&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;input value=&#123;val&#125; onChange=&#123;<span class="function"><span class="params">event</span> =&gt;</span> setVal(event.target.value)&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br></pre></td></tr></table></figure>
<p>可以看到如果依赖项 count 不改变，set 集合大小就不会改变。打印出的 set 集合存放的各种缓存函数。其实 <code>useCallback(fn， deps)</code> 和 <code>useMemo(() =&gt; fn， deps)</code> 作用是相同的。<br>比如我们有一个父组件，包含一个子组件，子组件接收一个函数作为props。这样无论父组件那个数据修改了，子组件便会执行更新，但是有很多情况下更新是没有必要的，我们可以借助 <code>useCallback</code> 和 <code>memo</code> 一起避免不必要的更新。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ViewCount <span class="keyword">from</span> <span class="string">&#x27;./viewCount&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Count = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> [val, setVal] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> callback = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;, [count]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ViewCount callback=&#123;callback&#125; /&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;input value=&#123;val&#125; onChange=&#123;<span class="function"><span class="params">event</span> =&gt;</span> setVal(event.target.value)&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Count;</span><br></pre></td></tr></table></figure>
<p>编写子组件，需要结合 <code>memo</code> 避免重复渲染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> viewCount = memo(<span class="function">(<span class="params">&#123; callback &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="function">() =&gt;</span> callback());</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setCount(callback());</span><br><span class="line">    &#125;, [callback]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123; count &#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> viewCount;</span><br></pre></td></tr></table></figure>
<p>这样只有子组件数据改变才会重新进行渲染。</p>
<blockquote>
<p>无论是<code>useCallback</code>还是<code>useMemo</code>避免子组件重复渲染都需要<code>memo</code>的配合，不然不仅不会提示性能，还是对程序性能造成一些影像。</p>
</blockquote>
<h2 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h2><p>避免一些组件重复的渲染，比如下面会造成很大的资源浪费，简单修改下上面写的组件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;UserContext&#125; <span class="keyword">from</span> <span class="string">&#x27;./UserContext&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> UserInfo <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="string">&#x27;blog&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;UserContext.Provider value=&#123; &#123; user, setUser &#125; &#125;&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;user&#125; setUser=&#123;setUser&#125; /&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span>  setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">        +</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/UserContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> User;</span><br></pre></td></tr></table></figure>
<p>然后在子组件中添加一些渲染提示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;memo&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;user, setUser&#125;) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;assembly Rendering&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;user&#125;&lt;br /&gt;</span><br><span class="line">      &lt;button onClick = &#123;<span class="function">() =&gt;</span> setUser(<span class="string">&#x27;123123&#x27;</span>)&#125;&gt;</span><br><span class="line">        set name</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样父组件中的 count 发送变化 user 子组件就会重新渲染。按照正常逻辑来讲，count 和 user 组件没有关系，count 无论怎么变化都不该将 user 组件重新渲染，如果 user 组件逻辑很复杂会造成很大的性能的浪费。我们可以使用 <code>memo</code> 解决这个问题:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;memo&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> memo(</span><br><span class="line">    (&#123;user, setUser&#125;) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;assembly Rendering&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;user&#125;&lt;br /&gt;</span><br><span class="line">                &lt;button onClick = &#123;<span class="function">() =&gt;</span> setUser(<span class="string">&#x27;123123&#x27;</span>)&#125;&gt;</span><br><span class="line">                    set name</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们只需要使用 <code>memo</code> 包括函数，就会自动判断该组件依赖值是否改变，如果不改变便不会重新渲染。</p>
<blockquote>
<p>如果使用 class 组件该怎么解决重复渲染的问题呢? 熟悉 React 应该了解 <code>PureComponent</code> 和  <code>Component</code> 区别，主要靠钩子函数 <code>shouldComponentUpdate</code> 来进行比对，如果返回 true，则表示重复渲染，如果返回 false 则不会重新进行渲染。</p>
</blockquote>
<h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>
<p>该方法为 userState 的替代方案。总共接收三个参数:</p>
<ul>
<li><strong>reducer</strong>: 一个 reducer 函数，和以前的 redux 函数的 reducer 相同，主要根据发送过来的 Action 处理 state 数据。</li>
<li><strong>initialArg</strong>: 设置 useReducer state 的初始值。</li>
<li><strong>init</strong>: 惰性地创建初始 state。其是一个函数，该函数返回初始化后的状态。</li>
</ul>
<p>如果您 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。这些情况都可以使用 useReducer 来替代 useState。并且使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reduce&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Reducer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;add&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reduce&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Reducer;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 useReducer 来替代 <code>userState</code> 进行组件间的 state 管理。如果需要和子组件共享数据，可以将 <code>useReducer</code> 和 <code>useContext</code> 结合起来，这样所有子组件都可以共享这些数据了。</p>
<h3 id="immer"><a href="#immer" class="headerlink" title="immer"></a>immer</h3><p>既然我们已经开启了<code>useReducer</code>，那么结合<code>immer</code>可以使代码更整洁。由于 reducer 只能返回一个新的 state 并不能在老的 state 上进行修改，但数据格式复杂的时候，这种处理数据的方式会添加许多无用代码，而<code>immer</code>就是为了解决该问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">&#x27;immer&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> produce(state, <span class="function">(<span class="params">defaultState</span>) =&gt;</span> &#123;</span><br><span class="line">        defaultState.count = defaultState.count + <span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;reduce&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> produce(state, <span class="function">(<span class="params">defaultState</span>) =&gt;</span> &#123;</span><br><span class="line">        defaultState.count = defaultState.count - <span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Reducer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;add&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;reduce&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Reducer;</span><br></pre></td></tr></table></figure>
<p>这样只需我能用<code>produce</code>包裹就能之间操作 state。</p>
<h3 id="use-immer"><a href="#use-immer" class="headerlink" title="use-immer"></a>use-immer</h3><p>上面说了<code>immer</code> 那么有没有针对<code>hooks</code>设计的该插件呢？有。<a href="https://github.com/immerjs/use-immer">use-immer</a> 就是为 hooks 封装之后的一个插件。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"><span class="deletion">- import produce from &#x27;immer&#x27;;</span></span><br><span class="line"><span class="addition">+ import &#123; useImmerReducer &#125; from &#x27;use-immer&#x27;;</span></span><br><span class="line"></span><br><span class="line">const initialState = &#123;count: 0&#125;;</span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#x27;add&#x27;:</span><br><span class="line"><span class="deletion">-      return produce(state, (defaultState) =&gt; &#123;</span></span><br><span class="line"><span class="deletion">-        defaultState.count = defaultState.count + 1;</span></span><br><span class="line"><span class="deletion">-      &#125;);</span></span><br><span class="line"><span class="addition">+      state.count = state.count + 1;</span></span><br><span class="line"><span class="addition">+      return;</span></span><br><span class="line">    case &#x27;reduce&#x27;:</span><br><span class="line"><span class="deletion">-      return produce(state, (defaultState) =&gt; &#123;</span></span><br><span class="line"><span class="deletion">-        defaultState.count = defaultState.count - 1;</span></span><br><span class="line"><span class="deletion">-      &#125;);</span></span><br><span class="line"><span class="addition">+      state.count = state.count - 1;</span></span><br><span class="line"><span class="addition">+      return;</span></span><br><span class="line">    default:</span><br><span class="line">      return state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const Reducer = () =&gt; &#123;</span><br><span class="line"><span class="deletion">-   const [state, dispatch] = useImmerReducer(reducer, initialState);</span></span><br><span class="line"><span class="addition">+   const [state, dispatch] = useReducer(reducer, initialState);</span></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;add&#x27;&#125;)&#125;&gt;+&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;&lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reduce&#x27;&#125;)&#125;&gt;-&lt;/button&gt;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">export default Reducer;</span><br></pre></td></tr></table></figure>
<p>只需这样修改<code>useImmerReducer</code>创建的对象我们可以直接在 reducer 中修改 state。这样就和<code>userState</code>很相似，第一个都为 state，第二个为修改 state 的对象。</p>
<h2 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a>自定义Hook</h2><p>自定义 hooks 是代码逻辑复用的利器，比如以前组件逻辑复用只能用高阶组件实现，而自定义hooks可以在不添加组件的情况下实现同样的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCount</span>(<span class="params">defaultValue</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(defaultValue);</span><br><span class="line">  <span class="keyword">const</span> addCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> reduceCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCount(count - <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    count,</span><br><span class="line">    &#123;</span><br><span class="line">      addCount, reduceCount</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Reducer = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useCount(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;p&gt;count: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount.addCount()&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">          &lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount.reduceCount()&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Reducer;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常见操作</title>
    <url>/javascript-array-operation/</url>
    <content><![CDATA[<p>数组在 JavaScript 中很常见，下面简单叙述下数组中经常使用的一些方法，方便以后进行使用。</p>
<a id="more"></a>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="Lodash"><a href="#Lodash" class="headerlink" title="Lodash"></a>Lodash</h3><p><a href="https://www.lodashjs.com/">Lodash</a>是一款很常用的 JavaScript 工具库，里面封装了很多常见的方法，我们可以直接调用其<code>uniq</code>方法进行去重操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_.uniq([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>会返回去重之后的数组。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>ES6 也提出了一些数组相关的数据结果，Set 便是一种数组类型的结构，其特点是 Set 中的数据不会重复，如果重复添加会自动去重。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uniqList = <span class="keyword">new</span> <span class="built_in">Set</span>(list);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(uniqList));</span><br></pre></td></tr></table></figure>
<p>这样将数组直接传给 Set 即可，去重之后使用<code>Array.from</code>转换回数组即可。</p>
<h3 id="双重-for-循环-splice"><a href="#双重-for-循环-splice" class="headerlink" title="双重 for 循环 + splice"></a>双重 for 循环 + splice</h3><p>当然除了上面别的库提供的，我们也可以自己封装，这样会更灵活：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>, len = arr.length; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        arr.splice(j, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 一项数据被删除，长度和下标需要重新计算</span></span><br><span class="line">        j--;</span><br><span class="line">        len--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样也能实现去重。</p>
<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>最容易理解的一个方法，实现起来也很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr1 = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1.indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      arr1.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样利用新定义的数组，实现数据的去重。</p>
<h2 id="多维转一维数组"><a href="#多维转一维数组" class="headerlink" title="多维转一维数组"></a>多维转一维数组</h2><h3 id="Lodash-1"><a href="#Lodash-1" class="headerlink" title="Lodash"></a>Lodash</h3><p>可以直接调用其<code>flattenDepth</code>便可展开数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>,[<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="string">&quot;ad&quot;</span>, [<span class="string">&quot;cd&quot;</span>,[<span class="string">&#x27;12&#x27;</span>,<span class="number">32</span>,[<span class="string">&#x27;cc&#x27;</span>,<span class="number">13</span>]], <span class="number">5</span>], <span class="number">9</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开层数，Infinty 为全部展开</span></span><br><span class="line"><span class="built_in">console</span>.log(_.flattenDepth(list, <span class="literal">Infinity</span>));</span><br></pre></td></tr></table></figure>
<p>不仅可以展开数组，还定义了展开数组的层数。</p>
<h3 id="Flat"><a href="#Flat" class="headerlink" title="Flat"></a>Flat</h3><p>ES6 为数组提供的，用于展开数组的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>,[<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="string">&quot;ad&quot;</span>, [<span class="string">&quot;cd&quot;</span>,[<span class="string">&#x27;12&#x27;</span>,<span class="number">32</span>,[<span class="string">&#x27;cc&#x27;</span>,<span class="number">13</span>]], <span class="number">5</span>], <span class="number">9</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开层数，Infinty 为全部展开</span></span><br><span class="line"><span class="built_in">console</span>.log(list.flat(<span class="literal">Infinity</span>));</span><br></pre></td></tr></table></figure>
<p>使用起来也是非常的方便。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>除了上面库封装的，我们也可以自己封装更灵活的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">array, newArr = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果是数组，递归展开</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(array[i])) &#123;</span><br><span class="line">      fun(array[i], newArr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 最终数组</span></span><br><span class="line">      newArr.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun([<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">6</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;3&#x27;</span>]],<span class="string">&#x27;你好&#x27;</span>,&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;]]));</span><br></pre></td></tr></table></figure>
<p>这种方式递归也可以展开数组。</p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>ES6 中提供的数组的方法，主要用于方便数组累计的操作，用于展开数组我们可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(curr)) &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.concat(...fun(curr));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev.concat(curr);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>redux-action</title>
    <url>/react-redux-action/</url>
    <content><![CDATA[<p>虽然 react-redux 非常的强大，但是发送和处理 action，需要很多的冗余代码，如果项目过多冗余代码肯定会对打包和运行速度有所影响，这时我们便要对其代码进行简写和封装，为了避免重复的轮子，一般需要网上进行查找，而 redux-action 便可以很好的对 action 进行代码的简写。</p>
<a id="more"></a>
<h2 id="传统的Redux"><a href="#传统的Redux" class="headerlink" title="传统的Redux"></a>传统的Redux</h2><p>为了更方便其对 redux 的封装，我们将其和原本的代码进行比较。</p>
<h3 id="默认的-Redux-代码"><a href="#默认的-Redux-代码" class="headerlink" title="默认的 Redux 代码"></a>默认的 Redux 代码</h3><p>创建 actions：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addGame = <span class="function">(<span class="params">game</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: <span class="string">&#x27;ADD_GAME&#x27;</span>,</span><br><span class="line">        game</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建 reducer：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gameList = [];</span><br><span class="line"><span class="keyword">const</span> gameReducer = <span class="function">(<span class="params">state = gameList, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_GAME&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">           ...state,</span><br><span class="line">          action.game</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> gameReducer;</span><br></pre></td></tr></table></figure>
<p>组件中进行调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; addGame &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> AddGame <span class="keyword">from</span> <span class="string">&#x27;./components/addGame&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageMain</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AddGame addGame=&#123;<span class="built_in">this</span>.props.addGame&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    gameList: state.game,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  addGame: addGame,</span><br><span class="line">&#125;)(PageMain);</span><br></pre></td></tr></table></figure>

<p>这样就完成调用了，子组件使用的时候调用父组件的 addGame 方法即可。</p>
<h3 id="使用-redux-action-处理-action-与-reducer"><a href="#使用-redux-action-处理-action-与-reducer" class="headerlink" title="使用 redux-action 处理 action 与 reducer"></a>使用 redux-action 处理 action 与 reducer</h3><p>redux-action 主要依靠提供的 <strong>createAction</strong>、<strong>handleAction</strong> 完成工作。我们可以依靠 <code>createAction</code> 来帮助我们进行对象的创建：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAction &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addGame = createAction(<span class="string">&#x27;ADD_GAME&#x27;</span>, <span class="function"><span class="params">game</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> game;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>处理的时候也可以借助 <code>handleAction</code> 进行处理，防止出现 switch 等冗余的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; handleAction &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-actions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;addGame&#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gameList = [];</span><br><span class="line"><span class="keyword">const</span> gameReducer = handleAction(<span class="string">&#x27;ADD_GAME&#x27;</span>, <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...state,</span><br><span class="line">	action.game</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, gameList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> gameReducer;</span><br></pre></td></tr></table></figure>
<p>使用的方式和基础的一样，都需要通过 concat 高阶组件进行连接。主要是要熟悉 <strong>createAction</strong>、<strong>handleAction</strong> 两个API的用法：</p>
<ul>
<li><code>createAction</code>: 创建一个 action 工厂的操作，主要用于返回一个 action 工厂。<br>参数一：action 的 type。<br>参数二：用于传递一些参数，方便 reducer 对数据进行处理。</li>
<li><code>handleAction</code>: 用于处理一些 action 请求，返回一个 reducer。<br>参数一：需要处理的 action type。<br>参数二：reducer 处理 store 的函数。<br>参数三：用于初始化的 state 。</li>
</ul>
<h2 id="createActions-与-handleActions"><a href="#createActions-与-handleActions" class="headerlink" title="createActions 与 handleActions"></a>createActions 与 handleActions</h2><p>上述操作只能创建或处理一条 action 。而项目不可能只有一条 action，redux-action 不可能不处理这种情况，所以 redux-action 提供了 createActions 与 handleActions 用来处理多条 action。<br>使用<code>createActions</code>创建 action：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createActions &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createActions(&#123;</span><br><span class="line">  [<span class="string">&#x27;ADD_GAME&#x27;</span>]: <span class="function"><span class="params">game</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> game;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用<code>handleActions</code>创建 reducers：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; handleActions &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gameList = [];</span><br><span class="line"><span class="keyword">const</span> gameReducer = handleActions(&#123;</span><br><span class="line">  [<span class="string">&#x27;ADD_GAME&#x27;</span>]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          ...state,</span><br><span class="line">          action.game</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, gameList);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> gameReducer;</span><br></pre></td></tr></table></figure>
<p>然后在使用的时候和以前一样调用即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; addGame &#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">        gameList: state.game</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    addGame: actions.addGame</span><br><span class="line">&#125;)(...);</span><br></pre></td></tr></table></figure>

<p><strong>handleActions</strong> 返回一个对象，对象针对每个 action 创建了属于自己一些属性，使用的时候下划线去掉，然后采用驼峰式命名。而 <strong>handleActions</strong> 仍然返回一个 reducer 函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redux-action 简写了 redux 发送和处理 action 的操作，并没有引入特别的一些语法和概念，如果项目中 action 和 reducer 冗余代码过多，可以考虑使用其减少代码的书写量。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react-redux</title>
    <url>/react-redux/</url>
    <content><![CDATA[<p>由于在 React 中数据流都是单向的，即只能父组件 -&gt; 子组件，但是开发过程中单向数据流面临着很多问题，所以需要一个框架为我们管理项目的数据流，Redux 便出现了，其主要目的便是管理项目中的数据流。但是我们也有明白 <strong>React 项目并不是一定要用 Redux、而 Redux 也不一定要在React 上使用</strong>。</p>
<a id="more"></a>
<h2 id="你可能不需要它"><a href="#你可能不需要它" class="headerlink" title="你可能不需要它"></a>你可能不需要它</h2><p>这一点官网说的很清楚，Redux 只是一个很好的项目数据流管理工具，但不是非用不可。因为如果不设计到过多的数据需要维护，那么只用 React 就足够了，就算有很多状态需要我们维护，我们也可以使用 Mobx。<br>换句话说如果 UI 层很简单，或者没有太多的数据交互那么便可以放弃使用 Redux，否则只会增加项目难度。<br>但是如果出现下面情况，我们可以考虑进行使用：</p>
<ol>
<li>一些组件的数据需要共享给其它组件。</li>
<li>一些值比较重要，需要在任何组件都可以访问到。</li>
<li>一个组件需要改变其它组件的状态。</li>
</ol>
<p>出现这种情况，我们可以考虑使用 Redux 进行状的管理。</p>
<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><p>Redux 可以用这三个基本原则来描述：</p>
<ol>
<li><code>单一数据源</code>：整个项目有且只有一个Store。</li>
<li><code>State是只读的</code>：唯一改变State的方法就是触发<code>action</code>，action是用来描述发生事件的普通对象。</li>
<li><code>使用纯函数进行修改</code>：Reducer 根据 action 覆盖 state。Reducer 必须是一个纯函数，它接收先前的 state 和 action，并返回新的 state。<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3>主要用于维护应用中的所有的 <strong>state树</strong> 的对象，改变其的唯一方法只能依靠 <code>dispatch</code> 发送 action 对象。<br>但有一点需要注意：<strong>整个项目有且只能有一个 Store</strong>，创建时需要通过 <code>createStore</code> 方法，生成 Store：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>
很简单的方式，但是项目中不可能只有 1 个  Reducer，那么如果有多个 Reducer 怎么办呢？这就需要 React 提供的另外一个方法 <code>combineReducers</code> 来拆分 Reducer：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">    user</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
很简单便将 Reducer 进行了拆分，使用的时候，添加 key 进行访问即可。</li>
</ol>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>state 是项目的主要数据，我们可以通过 <code>store.getState()</code> 来获取项目中的 state 状态树。它与 reducer 的返回值相同。<br>调用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br></pre></td></tr></table></figure>
<p>调用也很简单。</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>准确来说它并不是特定的格式，只是大多数这么写，便默认了其默认的格式。其主要用于描述动作类型。<br>基本格式如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  data: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是一个普通的 JavaScript 的对象。Reducer 会判断类型，然后根据参数，返回新的 state 进行数据的覆盖。</p>
<h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch"></a>store.dispatch</h3><p><code>store.dispatch()</code> 项目中发送 action 的唯一途径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  data: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以很简单的将一个 action 发送出去。</p>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Redux 接收到新的 Action 以后，经过 Reducer 处理之后，返回新的 state，覆盖项目的 store，形成行动 store，最后通知界面视图进行更新。<br>基本格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基本格式如上，Reducer 会使用 <code>switch</code> 判断发送的 action 的 type，执行不同的逻辑，而返回不同的 state。</p>
<h2 id="结合-React"><a href="#结合-React" class="headerlink" title="结合 React"></a>结合 React</h2><p>上面介绍了 Redux 的简单 API，但是还没有和 React 结合使用，和 React 结合其实很简单，但是还需要借助 <code>react-redux</code> 来帮助。<br>项目整理完成后，第一步创建 Store，这是项目的唯一数据源：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">    user</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样 Store 便创建完成了，然后我们需要将数据注入到组件中，默认如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> Store <span class="keyword">from</span> <span class="string">&#x27;./reducer/store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider store=&#123;Store&#125;&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  , <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样便通过 react-redux 提供的组件，将 Store 成功的注入。数据成功注入后需要在相应的组件中进行调用，主要依靠 react-redux  提供的 connect 高阶函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (....)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure>
<p>这样在组件中不论是 state 中定义的变量，还是 dispatch 都能操纵了。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>react-context</title>
    <url>/react-context/</url>
    <content><![CDATA[<p>由于 React 的数据流都是 <strong>单向传递</strong> 的，只能由父级组件定义数据子组件使用，但是只能嵌套一层，如果涉及到多层嵌套，便只能层层向下传递。而 <code>Context</code> 的存在提供了另外一种数据的传输方式，可以在父级定义上下文对象，所有子组件都能获取到上下文对象，从而避免了在每一个层级手动的传递 props 属性。</p>
<a id="more"></a>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>我们可以看下官网提供的 <a href="https://zh-hans.reactjs.org/docs/context.html#gatsby-focus-wrapper">资料</a>，其为我们提供了很多常用的方法。</p>
<h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h3><p>我们需要在父组件中使用 <code>React.createContext(defaultValue)</code> 方法创建 <code>Context</code>对象，defaultValue 表示默认需要共享的数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 通过createContext方法创建</span></span><br><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext();</span><br></pre></td></tr></table></figure>
<h3 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h3><p><code>Context</code> 所返回的对象中包含一个 <code>Provider</code> 组件，该组件包含一个 <code>value</code> 属性，该值可以被所有子组件直接获取，这样就可以避免 props 向深层级的组件传递的问题了，并且当 <code>Context</code> 的值放生变化的时候组件会自动重新render。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Provider value=&#123;<span class="comment">/*共享的数据*/</span>&#125;&gt;</span><br><span class="line">    &#123; <span class="built_in">this</span>.props.children &#125;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure>
<p>简单来说：该组件相当于一个生产者，供所有子组件使用。</p>
<h3 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h3><p><code>Consumer</code> 组件可以帮助我们获取 <code>Provider</code> 里的数据，<code>Consumer</code> 组件的子组件是一个函数，这个函数的第一个参数就是共享的值，函数的返回值必须是一个 React元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">    &#123; <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="xml">&lt;...  /&gt;</span> &#125;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以简单的理解它为消费者，我们可以借此来获取 <code>Provider</code> 中的数据。</p>
<h2 id="结合-React"><a href="#结合-React" class="headerlink" title="结合  React"></a>结合  React</h2><p>上面简单的介绍了一些常用的 API，下面主要还是和 React 简单的结合一起使用。</p>
<h3 id="整理项目"><a href="#整理项目" class="headerlink" title="整理项目"></a>整理项目</h3><p>首先在项目中新建一个 <strong>contexts</strong> 文件夹，里面放入我们需要的 <code>Context</code>，这样更适合我们维护项目。</p>
<h3 id="创建一个简单的Context"><a href="#创建一个简单的Context" class="headerlink" title="创建一个简单的Context"></a>创建一个简单的Context</h3><p>创建一个简单的 <code>Context</code>，方便后面继续使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// 导出 Context 方便后面调用其 API</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UserContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProvider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            name: <span class="string">&#x27;blog&#x27;</span>,</span><br><span class="line">            age: <span class="number">23</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;UserContext.Provider value=&#123;<span class="built_in">this</span>.state.user&#125;&gt;</span><br><span class="line">                &#123; <span class="built_in">this</span>.props.children &#125;</span><br><span class="line">            &lt;/UserContext.Provider&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子元素获取数据"><a href="#子元素获取数据" class="headerlink" title="子元素获取数据"></a>子元素获取数据</h3><p>任何子元素获取上下文对象中的数据，必须依靠 <code>Consumer</code> 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> serviceWorker <span class="keyword">from</span> <span class="string">&#x27;./serviceWorker&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserContext &#125; <span class="keyword">from</span> <span class="string">&#x27;./contexs/userContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;UserContext.Consumer&gt;</span><br><span class="line">        <span class="comment">// 通过这种方法传递给需要的子组件</span></span><br><span class="line">        &#123;<span class="function">(<span class="params">&#123;user&#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">    &lt;/UserContext.Consumer&gt;</span><br><span class="line">, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>这样我们就获取到了 <code>Context</code> 的数据，并通过 props 传递给子组件，子组件通过 props 获取即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以结合上面我们可以得出下面步骤：</p>
<ul>
<li>就是需要创建一个一个 <code>Context</code>。</li>
<li>创建 <code>Provider</code>，提供需要共享的数据，剩余交给 <code>Context</code>。</li>
<li>子组件通过 <code>Consumer</code> 进行访问 <code>Context</code> 管理的数据，但是需要注意函数的返回值必须是一个 React元素。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 4.0</title>
    <url>/webpack4/</url>
    <content><![CDATA[<p>随着前端的开发复杂度越来越庞大，简单的前端开发已经不满足我们需求了，一些代码浏览器并不能进行识别(如jsx、es6、vue…)，只有编译成浏览器能识别的才能使用，那么如果前端开发不使用打包工具，开发效率会大幅下降。而在众多的工具中 webpack 便是较为流行的前端构建工具。<br>webpack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript 模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>
<a id="more"></a>

<h2 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h2><p>自从 webpack <code>4.0+</code> 之后，我们使用 webpack 还需要安装 webpack-cli 用于提供 webpack 的命令行工具。使用下面的命令进行安装：</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> webpack webpack-cli</span><br></pre></td></tr></table></figure>
<p>也可以进行全局安装如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -<span class="built_in">global</span> webpack</span><br></pre></td></tr></table></figure>
<p>可以使用 <strong>webpack -v</strong> 查看版本。<br>全局安装完成后，可以新建一个文件 <strong>/src/index.js</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">global</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello word&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">global</span>();</span><br></pre></td></tr></table></figure>
<p>一个简单的 es6 语法，下面使用 webpack 打包，执行 <strong>webpack</strong> 命令，可以看到打包的一些信息，默认webpack 会打包 <strong>/src/index.js</strong> 文件，输出到 <strong>/dist/main.js</strong> 文件，当然我们也可以自己配置，例如执行下面的命令 <strong>webpack ./src/index.js –output ./dist/index.js</strong> 便能把指定的文件打包到指定路径。</p>
<blockquote>
<p>官网并不太推荐全局进行安装，全局安装不容易管理和升级项目。我们也可以使用 <strong>node_modules/.bin/webpack</strong> 指定相应的 webpack 进行打包处理(当然也可以使用npx解决)。</p>
</blockquote>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>告诉webpack打包模式，以便于内置优化。主要有下面几种模式：</p>
<ul>
<li>production：告诉webpack执行生产模式打包，也就是需要把项目发布到服务器上。</li>
<li>development：开发模式，我们本地的调试，需要一些日志插件、浏览器插件等调试工具。</li>
<li>none：退出任何默认优化选项。</li>
</ul>
<p>我们这些执行进行打包：<strong>webpack –mode=development ./src/index.js –output ./dist/index.js</strong></p>
<h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p>由于上方的 webpack 打包命令过长，运行并不好使，我们可以在 package.json 添加配置，执行 <strong>npm init -y</strong> 初始化，然后再 <strong>scripts</strong> 属性添加配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack --mode=development ./src/index.js --output ./dist/index.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行下面的命令启动 <strong>yarn dev</strong>。</p>
<h2 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h2><p>上面都是在启动命令上添加参数，但项目开发最好还是需要config文件配置，而不是启动命令行进行配置。然后我们可以配置启动入口、和输出入口、打包模式等：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&quot;app.bundle.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样配置便完成了，然后去掉打包命令的参数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可自动读取config文件，添加打包的配置。</p>
<blockquote>
<p>webpack默认的配置文件为 <strong>webpack.config.js</strong> ，我们也可以使用 <strong>webpack –config webpack.config.js</strong> 修改配置文件默认路径。</p>
</blockquote>
<h2 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h2><p>项目有时需要多个入口文件，我们可以修改webpack.config.js文件，用于配置入口文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    hello: <span class="string">&#x27;./src/hello.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&quot;[name].bundle.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入口提供了多个，打包到dits目录[name].bundle.js文件。</p>
<blockquote>
<p>[name] 为项目入口文件的name，例如 app：’./src/index.js’ 文件，那么打包输出的便是 app.bundle.js 文件。</p>
</blockquote>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>webpack进行文件编译的主要配置。webpack可以通过对文件类型进行匹配，对匹配到的文件进行相应的 loading 插件处理，比如处理 scss 有 scss-loader、less 有 less-loader、es6 有 babel、css 有 css-loader、vue-loader…</p>
<h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><p>随着es6越来越火，前端开发也逐渐进行使用，但是浏览器五花八门，有些较好的浏览器开始逐渐识别es6，但是还有一些并不能识别es6，这给前端开发带来许多问题。这时 babel 便出现解决这些问题了，它可以将 es6 代码转换为浏览器可以正常识别的代码，很优雅解决了浏览器不能识别 es6 不能被浏览器识别的问题，并且还可以和webpack进行结合，使项目更加自动化。<br>那么怎么结合呢?我们可以看下webpack的<a href="https://github.com/webpack/webpack">GitHub</a>，提供了和一系列插件结合的方法。babel 通过 <a href="https://github.com/babel/babel-loader">babel-loader</a> 和 webpack 进行结合。</p>
<p>babel-loader主要提供了下面几个插件：</p>
<ul>
<li><code>@babel/core</code>：babel的核心库。</li>
<li><code>babel-loader</code>：webpack和babel结合需要的插件。</li>
<li><code>@babel/preset-env</code>：babel 对es6的常用解析插件集合(可以配置按需加载)。</li>
</ul>
<p>但是安装完成后，根据官网给出的提示复制进 <code>webpack.config.js</code>，发现并没有解析 es6 中的代码，这是为什么呢？经过研究发现 babel 如果要解析特点 es6 代码，需要插件的支持，把es6代码主要分为很多类：</p>
<ul>
<li><code>@babel/plugin-transform-arrow-functions</code>：箭头函数转换为普通的函数</li>
<li><code>@babel/plugin-transform-classes</code>： 解析class。</li>
<li><code>@babel/plugin-proposal-decorators</code>： 解析项目的注解。</li>
<li>…</li>
</ul>
<p>可以根据自己需求选择所需插件，执行下面命令进行安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure>
<p>安装完成后，我们添加 babel 配置 <code>.babelrc</code> 文件，但是我们每一个 es6 都这样配置会非常的麻烦，那么有没有一个已经完成的插件，可以将es6语法常用的插件添加进去。肯定有的：</p>
<ul>
<li><code>@babel/preset-env</code>：将es6常用的语法插件加入到项目中。</li>
</ul>
<p>我们这么配置即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即可将 es6 转换为浏览器能识别的 es5 代码。</p>
<blockquote>
<p><strong>@babel/preset-env</strong>不是es6所有的语法插件，比如注解插件(@babel/plugin-proposal-decorators)便没有，我们可以根据官网将 <strong>debug</strong>设置为<code>true</code>来查看具体包含哪有插件。</p>
</blockquote>
<h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h4><p>上面已经介绍了 <strong>@babel/preset-env</strong> 可以将 es6 语法解析为浏览器能识别的 es5 语法，如果我们使用es6箭头函数( =&gt; )，是正常可以转换的，但是如果使用别的es6语法呢？例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>然后将 <code>devtool</code> 设置为 <code>false</code>，方便我们看打包之后的代码，最后惊奇的发现，wdnmd就转换了一个箭头函数，其余的完全复制过来了，老版本浏览器肯定不能识别的，那么该如何解如何形成的、又该如何决、怎么解决呢、怎么使用？</p>
<ol>
<li><code>问题如何形成</code>：形成是因为Babel默认只转换新的JavaScript语法(比如箭头函数)，但是转化不了新的API(Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象)，以及一些定义在全局对象上的方法(Object.assign)都不会转码，所以造成了该问题。</li>
<li><code>如何解决</code>：可以使用 polyfill 来解决，它的解决方式便是在window上定义全局属性，以后调用便是调用window上的方法，这样便解决这个问题。</li>
<li>我们要使用 polyfill 使它在源代码之前运行，让他成为一个 dependency(生成环境) 的依赖。首先安装依赖：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure>
安装成功后，有两种使用方式：</li>
<li>在 webpack.config.js 定义打包配置： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [<span class="string">&quot;@babel/polyfill&quot;</span>, <span class="string">&#x27;./src/index.js&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改 .babelrc 文件 babel 打包方式： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [[<span class="string">&quot;@babel/preset-env&quot;</span>, &#123; <span class="string">&quot;debug&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;entry&quot;</span> &#125;]],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
配置<code>useBuiltIns</code>属性便可，然后在需要的文件引入 <strong>import “@babel/polyfill”</strong> 这样便完成了。但是由于每个文件都需要引入 <strong>@babel/polyfill</strong> 并且打包面积过大，它是将所有的依赖都加载进去，这样我们项目便会过大，如果需要根据自己的需求进行按需加载该如何配置呢？很简单只需将 <strong>useBuiltIns</strong> 属性设置为 <strong>usage</strong> 即可(设置为usage后，界面需要引入@babel/polyfill 依赖)，这样便在打包前添加了 <strong>@babel/polyfill</strong> 处理文件。</li>
</ol>
<h4 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="@babel/runtime"></a>@babel/runtime</h4><p>上面说了 <strong>@babel/polyfill</strong> 解决babel打包的一些问题，但是它解决问题的同时也代码很多的问题例如：</p>
<ul>
<li><code>全局变量污染</code>：由于它解决问题是在全局变量上定义属性，很容易造成全局变量的污染，比如它在全局变量定义了一个Promise，而一些其他的库也需要定义Promise，这便造成了冲突。</li>
<li><code>修改全局对实例的方法</code>：由于它为了解决全局实例问题(Array.form、Object.assign)，它是之间在全局实例定义方法这也可能造成以后的代码冲突。</li>
</ul>
<p>总体来说便是 <strong>@babel/polyfill</strong> 可以解决我们的问题，但是其侵入性过强。那么我们还有别的更优的选择吗? <a href="https://www.babeljs.cn/docs/babel-runtime">@babel/runtime</a> 便可以解决这样的问题，至于它如何解决并和@babel/polyfill的差异可以看下知乎大牛的<a href="https://zhuanlan.zhihu.com/p/58624930">文章</a>。<br>这里简单说下如何使用。首先安装:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save @babel/runtime</span><br></pre></td></tr></table></figure>
<p>但是为了避免一些代码的重复(代码可能会有多个文件)我们还需要搭配一个插件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure>
<p>然后修改 .babelrc 文件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [[<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="string">&quot;debug&quot;</span>: <span class="literal">true</span> &#125;]],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;corejs&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">&quot;helpers&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;regenerator&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;useESModules&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现还需要安装<code>@babel/runtime-corejs2</code>主要添加项目对Promise的打包支持:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save @babel/runtime-corejs2</span><br></pre></td></tr></table></figure>
<p>最后打包项目，果然全局变量没有那些属性了，并且是按需加载。</p>
<h3 id="css-loader-amp-style-loader"><a href="#css-loader-amp-style-loader" class="headerlink" title="css-loader &amp; style-loader"></a>css-loader &amp; style-loader</h3><p>css样式是前端开发不可缺少的文件，但是一些css样式需要添加浏览器内核前缀，例如<code>-moz-</code>、<code>-webkit-</code>、<code>-o-</code>…这些前缀都非常统一，那么我们可以不可以使用一个插件让其自动给某些属性添加浏览器前缀，并且还可以为我们压缩 css 空格，减少代码体积等，那么 <a href="https://github.com/webpack-contrib/css-loader">css-loader</a> 和 <a href="https://github.com/webpack-contrib/style-loader">style-loader</a> 会是个不错的选择。<br>执行下面的命令安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure>
<p>然后添加webpack配置:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">      ..., &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意执行顺序为 <strong>从右到左</strong>，也就是 css-loader 处理后交给 style-loader。</p>
<h3 id="sass-loader-amp-less-loader"><a href="#sass-loader-amp-less-loader" class="headerlink" title="sass-loader &amp; less-loader"></a>sass-loader &amp; less-loader</h3><p>现在前端预编译样式也是使用者越来越多，但是浏览器并不支持这种语言，也需要webpack插件<a href="https://github.com/webpack-contrib/sass-loader">sass-loader</a> 和 <a href="https://github.com/webpack-contrib/less-loader">less-loader</a> 进行相应的解析，它们可以把 scss 或 less 解析为css。<br>这里只介绍less如何编译，至于scss其实方式一样，只是依赖插件不同。<br>安装插件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install less less-loader --save-dev</span><br></pre></td></tr></table></figure>
<p>成功后，设置webpack配置即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">      ..., &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 webpack 执行顺序为从右向左，也就是 less-loader -&gt; css-loader -&gt; style-loader。顺序不要搞反了。</p>
<h3 id="file-loader-amp-url-loader"><a href="#file-loader-amp-url-loader" class="headerlink" title="file-loader &amp; url-loader"></a>file-loader &amp; url-loader</h3><p>主要用于处理项目中出现的文件，主要靠 <a href="https://github.com/webpack-contrib/url-loader">url-loader</a> 和 <a href="https://github.com/webpack-contrib/file-loader">file-loader</a> 处理项目的文件，这里已 file-loader 为例，首先安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install file-loader --save-dev</span><br></pre></td></tr></table></figure>
<p>成功后，设置webpack配置即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">      ..., &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="image-webpack-loader"><a href="#image-webpack-loader" class="headerlink" title="image-webpack-loader"></a>image-webpack-loader</h3><p>项目中的图片有时候大小过大，打包发布后在生产环境下并不太好的加载，这时我们便需要在打包时压缩一下项目的图片文件。执行下面的命令安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install image-webpack-loader --save-dev</span><br></pre></td></tr></table></figure>
<p>完成后，修改webpack配置文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">      ..., &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">&#x27;[name].[ext]&#x27;</span>,</span><br><span class="line">              outputPath: <span class="string">&#x27;images/&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;image-webpack-loader&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>上面介绍了 webpack 的 Loaders 主要用于解析项目的文件，将一些浏览器不支持的语法(less、scss、es6、jsx、vue…)解析为浏览器可以识别的，而 plugins 则可以给指定文件添加一些拓展。</p>
<h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>html 的拓展插件，可以拓展html的一些功能。例如：我们一般 js 和 css 都是添加 hash 防止浏览器缓存，造成 js 和 css 修改而浏览器不刷新的问题。但是添加 hash 后文件名称一直改变，所以我们需要使用<code>html-webpack-plugin</code>根据一个模板文件动态引入 js 和 css 文件。<br>首先只需下面命令进行安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">yarn add --dev html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>成功后，在webpack进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugins: [</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">          filename: <span class="string">&#x27;./index.html&#x27;</span>,</span><br><span class="line">          template: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单根据模板引入所需文件，它还有其他的一些配置，详细可以看下github上的<a href="https://github.com/jantimon/html-webpack-plugin">介绍</a>。</p>
<blockquote>
<p>也可以进行多界面的配置，可以靠 <strong>chunks</strong> 配置多入口，如果多个界面入口，可以使用该配置，较多用于项目前端一个入口、后端一个入口，最好不要太多的界面入口。</p>
</blockquote>
<h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>应为 webpack 处理样式默认都是设置到了 style 上，但是项目样式一般都提取到一些样式文件(css)中，这些既有利于代码复用，也有利于调整项目的样式。我们可以使用 <strong>mini-css-extract-plugin</strong> 提取 style css 到一个文件中。<br>执行下面的命令进行安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<p>然后再webpack添加配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> devMode = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [...,&#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        devMode ? <span class="string">&#x27;style-loader&#x27;</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">        <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: devMode ? <span class="string">&#x27;[name].css&#x27;</span> : <span class="string">&#x27;[name].[hash].css&#x27;</span>,</span><br><span class="line">      chunkFilename: devMode ? <span class="string">&#x27;[id].css&#x27;</span> : <span class="string">&#x27;[id].[hash].css&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便根据条件进行判断，开发模式下继续使用 style-loader 不会生成css文件，生成环境下会使用 mini-css-extract-plugin 提取 style 到一些文件中。</p>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>项目的开发过程中，不能像上面代码，没修改一下都需要重新打包下，但是真实开发环境中需要开启服务，并监听代码的修改，一旦修改便自动刷新界面。这样便能大大的缩减项目的开发时间。<br>执行下面的命令安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>
<p>然后修改启动命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;npx webpack-dev-server&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以添加一下具体的配置，详细可以看下<a href="https://github.com/webpack/webpack-dev-server">github</a>。</p>
<h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>因为项目文件打包多半文件名打包之后名称含有hash值，这样一旦打包次数过多，会堆积许多hash文件，我们需要每次打包前令项目自己清空文件夹，然后放入打包之后的内容。<br>执行下面的命令安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>然后修改启动命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> pathsToClean = [</span><br><span class="line">  <span class="string">&#x27;dist&#x27;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以添加一下具体的配置，详细可以看下<a href="https://github.com/webpack/webpack-dev-server">github</a>。</p>
<h3 id="webpackbar"><a href="#webpackbar" class="headerlink" title="webpackbar"></a>webpackbar</h3><p>webpack打包时生成进度条，方便查看webpack打包进度和打包时间。<br>执行下面命令安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install webpackbar -D</span><br></pre></td></tr></table></figure>
<p>修改webpack配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> WebpackBar = <span class="built_in">require</span>(<span class="string">&#x27;webpackbar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> WebpackBar()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>主要用于项目的调试，可以在找错的时候给我们一些帮助(可以为我们生成 sourcemap，非常在开发模式下找出错误)。也就是设置项目打包之后的代码。它的值有下面很多种，具体用法可以看官网的<a href="https://webpack.js.org/configuration/devtool/">介绍</a>，它的配置方式很简单，只需在webpack.config.js添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  devtool: ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply、bind区别</title>
    <url>/call-apply-bind/</url>
    <content><![CDATA[<p><strong>call</strong>、<strong>apply</strong>、<strong>bind</strong> 三个函数在 JS 中都可以用来修改函数的上下文对象，并且三个方法作用相同，但使用方式却各不相同。那么它们的区别是什么？以及怎么实现的呢？</p>
<a id="more"></a>
<h2 id="相同和区别"><a href="#相同和区别" class="headerlink" title="相同和区别"></a>相同和区别</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><p>它们都是用来改变函数的上下文，也就是<code>this</code>指向。</p>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><p><code>fn.call</code>：立即调用，返回函数指向结果，<code>this</code>指向第一个参数，后面可以有更多的参数，并且这些都是 fn 函数的参数。<br><code>fn.apply</code>：立即调用，返回函数指向结果，<code>this</code>指向第一个参数，第二个参数是个数组，这个数组内容是 fn 函数的参数。<br><code>fn.bind</code>：不会立即调用，而是返回一个绑定后的新函数，一个典型的 <code>柯里化</code> 函数。</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>如果一个函数接收多个参数，我们可以把这个函数转化为每次只接收一部分参数的多次调用形式，这就是函数的柯里化。<br>听着定义很难懂，但是我们看代码就很简单了。首先如果我们有下面的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>)</span>&#123;<span class="keyword">return</span> a + b + c&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以将上面函数柯里化，那么函数定义为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以使用es6方式定义</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="function">(<span class="params">b, c</span>) =&gt;</span> (a + b + c);</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>项目中还是有些常用的，具体就不介绍了，我们可以总结下柯里化的 4 种功能：</p>
<ol>
<li>性能优化。</li>
<li>代码复用。</li>
<li>使代码清晰，更难以理解。</li>
<li>扩展JS能力。</li>
</ol>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>call 函数接收第一个参数作为上下文，其余参数传递给需要执行的函数。那么我们在调用 call 到底发生了什么：</p>
<ol>
<li>改变 this 的指向，指向第一个参数。</li>
<li>执行相应的函数。</li>
</ol>
<p>我们把上面执行逻辑转换为代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 的 “this” 默认值为 window</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisObj = <span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 this 指向 调用的函数(也就是bar)</span></span><br><span class="line">  thisObj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 处理 arguments 参数，去除第一个(第一个参数为 this)</span></span><br><span class="line">  <span class="keyword">let</span> arg = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 把参数传递给，调用的函数，并修改 this 的指向</span></span><br><span class="line">  <span class="keyword">let</span> result = thisObj.fn(...arg);</span><br><span class="line">  <span class="comment">// 已经构建完成，删除多余的参数</span></span><br><span class="line">  <span class="keyword">delete</span> thisObj.fn;</span><br><span class="line">  <span class="comment">// 返回修改后的对象</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用代码进行验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后得出下面的输出: kevin 18 1</span></span><br><span class="line">bar.myCall(foo, <span class="string">&#x27;kevin&#x27;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p>完成 call 函数。</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>这个和上面的 call 非常的相似，只是参数的传递并不相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 的 “this” 默认值为 window，arr 为参数列表</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">thisObj = <span class="built_in">window</span>, arr</span>)</span>&#123;</span><br><span class="line">  thisObj.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span>(!arr)&#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn(...arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样也可以实现 apply 和上面的 call 及其相似，只是多了一个参数 arr。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>这个和上面的两个(call、bind)都不相同，其创建后不会第一时间执行，还需要用户手动调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisObj</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只有函数类型才能继续执行</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;must be a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里的 this 指向 调用的函数</span></span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 参数，去掉第一个 this</span></span><br><span class="line">  <span class="keyword">let</span> argsArr = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 注意，bind 和 call 参数相似，但是 bind 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 第二次传递的参数</span></span><br><span class="line">    <span class="keyword">let</span> bindFuncArg = [...arguments]</span><br><span class="line">    <span class="comment">// 因为是执行了两次，需要进行数据合并</span></span><br><span class="line">    <span class="keyword">let</span> totalArgs = argsArr.concat(bindFuncArg);</span><br><span class="line">    <span class="comment">// 借助上面定义的 apply 实现</span></span><br><span class="line">    <span class="keyword">return</span> self.apply(thisObj, totalArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面便借助了 call 实现了 bind。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>call、apply、bing 各有各的特点，虽然功能相似但却各有各的长处，如果正常使用还是 <code>call</code> 比较的常用，当然这也是依靠个人的编程习惯。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/js-currying/</url>
    <content><![CDATA[<p>函数的柯里化其实在开发中很常用，其能为我们节约开发的很多的代码，也可以更灵活的封装函数，或许代码中使用过，但并不知道其是柯里化。</p>
<a id="more"></a>

<h2 id="柯里化是什么"><a href="#柯里化是什么" class="headerlink" title="柯里化是什么"></a>柯里化是什么</h2><p>柯里化(Currying)：就是把接收多个参数的函数变换成接收第一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>定义非常的抽象，下面看下简单的一些使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的函数</span></span><br><span class="line"><span class="keyword">const</span> plus = <span class="function">(<span class="params">a ,b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="built_in">console</span>.log(plus(<span class="number">1</span>, <span class="number">3</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化后</span></span><br><span class="line"><span class="keyword">const</span> curryingPlus = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">let</span> currying = curryingPlus(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(currying(<span class="number">3</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上面两个函数返回值相同的，就是<strong>plus</strong>函数 a,、b 两个参数，先接收第一个参数，然后返回一个函数去处理b这个参数。这思路就更清晰了，就是只传递一个第一参数来创建它，让它返回一个函数来处理下面的参数。</p>
<p>但是问题来了，这似乎并没有太大的作用，那包装这一层究竟有什么作用呢？那些技术大牛也不会闲着没事包装一层没有用的函数，下面看下Currying怎么使用。</p>
<h2 id="Currying好处"><a href="#Currying好处" class="headerlink" title="Currying好处"></a>Currying好处</h2><h3 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h3><p>函数的参数复用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的正则表达式匹配函数</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">replace, text</span>) =&gt;</span> replace.test(text);</span><br><span class="line"><span class="built_in">console</span>.log(plus(<span class="regexp">/a/</span>, <span class="string">&#x27;The best things in life are free!&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化后</span></span><br><span class="line"><span class="keyword">const</span> curryingFind = <span class="function"><span class="params">replace</span> =&gt;</span> <span class="function"><span class="params">text</span> =&gt;</span> replace.test(text);</span><br><span class="line"><span class="keyword">let</span> currying = curryingFind(<span class="regexp">/a/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(currying(<span class="string">&#x27;The best things in life are free!&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>两次结果是一致的，但是柯里化后明显比第一个少定义了一次正则表达式。柯里化先用正则表达式创建一个函数，然后传入字符串给返回函数，这样就少定义正则表达式的代码。</p>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>柯里化的延迟执行为不断的传入参数，函数不断收集传入的参数，最后在执行函数。例如累加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingPush</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = [...arguments];</span><br><span class="line">  <span class="keyword">const</span> _sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      list = [...list, ...arguments];</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> list.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> _sum;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> _sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currying = curryingPush(<span class="number">1</span>);</span><br><span class="line">currying(<span class="number">2</span>);</span><br><span class="line">currying(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(currying()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上述例子函数不断收集参数，放入list中，直到我们传入空参数结束循环，最后累加我们的list返回相加的值，并结束柯里化的过程。</p>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h3><p><code>bind</code>函数在开发过程中很常见。那么看下bind怎么实现的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>很明显，bind也是通过Currying来实现的。</p>
<h2 id="有趣的问题"><a href="#有趣的问题" class="headerlink" title="有趣的问题"></a>有趣的问题</h2><p>实现下面的一种结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>这就需要柯里化逐渐收集参数，满足需求后结束函数返回累加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingPush</span>(<span class="params">_sum</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// props_len：需要收集的参数个数；props_list：收集参数列表</span></span><br><span class="line">    <span class="keyword">let</span> props_len = _sum.length, props_list = [];</span><br><span class="line">    <span class="keyword">const</span> _push = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        props_len = props_len - <span class="built_in">arguments</span>.length;</span><br><span class="line">        props_list = [...props_list, ...arguments];</span><br><span class="line">        <span class="keyword">if</span>(props_len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            props_len = _sum.length;</span><br><span class="line">            <span class="keyword">return</span> _sum.apply(<span class="literal">undefined</span>, props_list);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _push;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _push;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">let</span> currying = curryingPush(sum);</span><br><span class="line"><span class="built_in">console</span>.log(currying(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(currying(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(currying(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>其实也很简单，也是通过柯里化逐渐收集参数，只是结束条件修改了一些，然后在结束的时候把<code>props_len</code> 拉回最初状态，以便于下次操作。</p>
<blockquote>
<p>上述柯里化主要依靠<code>arguments</code>属性来实现，如果使用Es6的箭头函数，切记箭头函数里面无法调用<code>arguments</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数字转中文</title>
    <url>/js-number-charts/</url>
    <content><![CDATA[<p>JavaScrip 实现将阿拉伯数字转换为中文读法可以使用对需要处理的数据循环监测的方式处理，在开发过程中有可能遇到，这里简单记录下。</p>
<a id="more"></a>
<h2 id="阿拉伯转中文"><a href="#阿拉伯转中文" class="headerlink" title="阿拉伯转中文"></a>阿拉伯转中文</h2><p>中文数字的一些特点：</p>
<ol>
<li>每个计数数字都跟着一个权位，权位有：十、百、千、万、亿。</li>
<li>以“万”为小节，对应一个节权位，万以下没有节权位。</li>
<li>每个小节内部以“十百千”为权位独立计数。</li>
<li>“十百千”不能连续出现，而“万”和“亿”作为节权位时可以和其他权位连用，如：“二十亿”。</li>
</ol>
<p>中文判断是否需要添加零：</p>
<ol>
<li>以10000为小节，小节的结尾即使是0，也不使用零。</li>
<li>小节内两个非0数字之间要使用“零”。</li>
<li>当小节的“千”位是0时（即：1~999），只要不是首小节，都要补“零”。</li>
</ol>
<p>算法的一些说明：</p>
<ol>
<li>对“零”的第三个规则，把检测放在循环的最前面并默认为false，可以自然的丢弃最高小节的加零判断。</li>
<li>单个数字转换用数组实现，var chnNumChar = [“零”,”一”,”二”,”三”,”四”,”五”,”六”,”七”,”八”,”九”]。</li>
<li>节权位同样用数组实现，var chnUnitSection = [“”,”万”,”亿”,”万亿”,”亿亿”]。</li>
<li>节内权位同样用数组实现，var chnUnitChar = [“”,”十”,”百”,”千”]。</li>
</ol>
<p>小数部分转换如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numToChn</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index =  num.toString().indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> str = num.toString().slice(index);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;点&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">      a += chnNumChar[<span class="built_in">parseInt</span>(str[i])];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a ;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节权位转换如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sectionToChinese</span>(<span class="params">section</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//str:用来存储转换后的中文，chnstr:最终结果，zero:是否需要补零，count:单位</span></span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>, chnstr = <span class="string">&#x27;&#x27;</span>,zero= <span class="literal">false</span>,count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(section &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> v = section % <span class="number">10</span>;  <span class="comment">// 对数字取余10，得到的数即为个位数</span></span><br><span class="line">    <span class="keyword">if</span>(v === <span class="number">0</span>)&#123;           <span class="comment">// 如果数字为零，则对字符串进行补零</span></span><br><span class="line">      <span class="keyword">if</span>(zero)&#123;</span><br><span class="line">        zero = <span class="literal">false</span>;        <span class="comment">// 如果遇到连续多次取余都是0，那么只需补一个零即可</span></span><br><span class="line">        chnstr = chnNumChar[v] + chnstr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      zero = <span class="literal">true</span>;           <span class="comment">// 第一次取余之后，如果再次取余为零，则需要补零</span></span><br><span class="line">      str = chnNumChar[v];</span><br><span class="line">      str += chnUnitChar[count];</span><br><span class="line">      chnstr = str + chnstr;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    section = <span class="built_in">Math</span>.floor(section/<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chnstr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换的主函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TransformToChinese</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 小数部分</span></span><br><span class="line">  <span class="keyword">var</span> a = numToChn(num);</span><br><span class="line">  <span class="comment">//舍入</span></span><br><span class="line">  num = <span class="built_in">Math</span>.floor(num);</span><br><span class="line">  <span class="comment">//用来计算单位</span></span><br><span class="line">  <span class="keyword">var</span> unitPos = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//strIns:权位转换的结果，chnStr:最终结果</span></span><br><span class="line">  <span class="keyword">var</span> strIns = <span class="string">&#x27;&#x27;</span>, chnStr = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">//是否需要补零</span></span><br><span class="line">  <span class="keyword">var</span> needZero = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(num === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> chnNumChar[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//取于得到最后一个节权位</span></span><br><span class="line">    <span class="keyword">var</span> section = num % <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">if</span>(needZero)&#123;</span><br><span class="line">      chnStr = chnNumChar[<span class="number">0</span>] + chnStr;</span><br><span class="line">    &#125;</span><br><span class="line">    strIns = sectionToChinese(section);</span><br><span class="line">    <span class="comment">//用来设置节权位单位，如果节权位全是0则不需要添加单位比如100000(十万)</span></span><br><span class="line">    strIns += (section !== <span class="number">0</span>) ? chnUnitSection[unitPos] : chnUnitSection[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//拼接最终结果</span></span><br><span class="line">    chnStr = strIns + chnStr;</span><br><span class="line">    <span class="comment">//用来判断是否需要进行补零</span></span><br><span class="line">    needZero = (section &lt; <span class="number">1000</span>) &amp;&amp; (section &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//删除这个节权位</span></span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num / <span class="number">10000</span>);</span><br><span class="line">    unitPos++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chnStr+a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中文转阿拉伯"><a href="#中文转阿拉伯" class="headerlink" title="中文转阿拉伯"></a>中文转阿拉伯</h2><p>算法的一些说明：</p>
<ol>
<li>将中文权位转换成10的位数。</li>
<li>对每个权位依次转换成位数并求和。</li>
<li>零可以直接忽略即可。</li>
</ol>
<p>中文转阿拉伯需要下面变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义数字转换变量</span></span><br><span class="line"><span class="keyword">var</span> chnNumChar = &#123;</span><br><span class="line">  零:<span class="number">0</span>,</span><br><span class="line">  一:<span class="number">1</span>,</span><br><span class="line">  二:<span class="number">2</span>,</span><br><span class="line">  三:<span class="number">3</span>,</span><br><span class="line">  四:<span class="number">4</span>,</span><br><span class="line">  五:<span class="number">5</span>,</span><br><span class="line">  六:<span class="number">6</span>,</span><br><span class="line">  七:<span class="number">7</span>,</span><br><span class="line">  八:<span class="number">8</span>,</span><br><span class="line">  九:<span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//中文权位转换成10的位数及节权标志</span></span><br><span class="line"><span class="keyword">var</span> chnNameValue = &#123;</span><br><span class="line">  十:&#123;<span class="attr">value</span>:<span class="number">10</span>, <span class="attr">secUnit</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  百:&#123;<span class="attr">value</span>:<span class="number">100</span>, <span class="attr">secUnit</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  千:&#123;<span class="attr">value</span>:<span class="number">1000</span>, <span class="attr">secUnit</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">  万:&#123;<span class="attr">value</span>:<span class="number">10000</span>, <span class="attr">secUnit</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">  亿:&#123;<span class="attr">value</span>:<span class="number">100000000</span>, <span class="attr">secUnit</span>:<span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换的方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChineseToNumber</span>(<span class="params">chnStr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rtn = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> section = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> secUnit = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> str = chnStr.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> num = chnNumChar[str[i]];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> num !== <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">      number = num;</span><br><span class="line">      <span class="keyword">if</span>(i === str.length - <span class="number">1</span>)&#123;</span><br><span class="line">        section += number;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> unit = chnNameValue[str[i]].value;</span><br><span class="line">      secUnit = chnNameValue[str[i]].secUnit;</span><br><span class="line">      <span class="keyword">if</span>(secUnit)&#123;</span><br><span class="line">        section = (section + number) * unit;</span><br><span class="line">        rtn += section;</span><br><span class="line">        section = <span class="number">0</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        section += (number * unit);</span><br><span class="line">      &#125;</span><br><span class="line">      number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rtn + section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
