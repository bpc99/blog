---
title: 执行机制
subtitle: event-loop
date: 2020-11-07 14:20:36
tags:
  - JavaScript
categories: [web]
---
在 JavaScript 的代码中都是按照一定的顺序去执行的，其每一段的代码执行，都有一定的先后顺序，这种代码的执行顺序一般称之为其执行机制。

<!-- more -->
## 执行机制
JavaScript 的执行机制主要在意下面几点：
1. **JavaScript是一门单线程语言**。
2. **Event Loop(事件循环)是JS的执行机制**。

## 为什么 JS 代码是单线程？
**其实也很好的理解，因为JS是用来在浏览器控制一些DOM的操作的一门脚本语言，如果JS是多线程，那么两个线程同时对一个DOM元素进行相互冲突的操作，那么浏览器将无法去执行。所以JS只能是单线程的**。
既然它只能只能是单线程，但是 JS 需要处理许多的异步请求，例如：请求网络接口、读取一些文件，延迟执行等操作，都需要使用异步去处理，否则一个请求解析时间过长那么代码就会阻塞。
### 单线程 实现 “多线程”
在 JS 中所有的异步以及多线程都可以理解为一种”假象“，例如H5新增的 WebWorker 来说，子线程有诸多的限制，不能控制DOM、不能修改全局对象等，通常只能处理一些数据逻辑。
这些限制并没有违背我们之前的观点，所以说是”假象“。JS异步执行机制就是 **事件循环**(Event Loop)，理解他就理解了异步执行机制。
## Event Loop
JS 代码在执行过程中会先执行同步操作异步操作排在事件队列里，这样的理解并没有什么错误，但是如果在深入理解会发现还有一些其它的概念，比如 event table 和 event queue，具体可以下面的流程：

1. 先判断任务是同步任务还是异步，同步进入主线程运行，异步进入 event table。
2. 异步在 event table 中注册事件，满足触发条件后(触发条件可能是延迟或网络请求成功)，后被推入 event queue。
3. 同步任务进入主线程一直执行，一直到主线程空闲时，才会到 event queue  查看是否有可执行的异常任务，如果有就推入主线程。

JS主线程执行过程中会不断的检查主线程执行栈是否为空，一旦为空，就回去 event queue 检查是否有等待被调用的函数，直至执行完毕。绘制流程图如下所示：

![](https://img.bipch.cn/2021/02/03/56e4181bd3a21.png)

### Ajax
通过上面的描述，可能还不够直观，我们用 Ajax 异步操作，执行顺序如下：
```javascript
$.ajax({
  url: '*****',
  data: [],
  success: () => {
    consoel.log('ajax成功');
  }
})
console.log('代码执行结束');
```
那么它的执行顺序为：
- ajax 进入  **event table**，并注册成功的回调函数 **success**。
- 主线执行完成，执行`console.log('代码执行结束')`代码。
- ajax 事件完成，回调函数进入 **event queue**。
- 主线程从 **event queue** 读取回调函数 **success** 并执行。

### setTimeout
项目中经常出现 `setTimeout`或者`setinterval`并不是特别准时，例如下面代码：
```javascript
setTimeout(() => {
  console.log('setTimeout延迟');
}, 0);

// 同步占用大量的事件
sleep(999999999);
```
如果我们用上面流程解释该代码会很简单，虽然其只是 0s，但是其还是异步，只是将其挂起并不会去执行，只有同步`sleep`执行完成，才会真正的去执行`setTimeout`代码，所以说不管是`setTimeout`还是`setinterval`都不会那么准时，因为 JS 会需要处理所有同步代码才会去执行异步。
## 微任务和宏任务
代码中除了同步和异步任务，还可以对异步任务再细一步的划分，可以再划分为：
- **宏任务**：包含`setTimeout`、`setIntval`异步方式。
- **微任务**：包含`Promsie`异步方式。

### 执行顺序
既然异步可以进一步细分，那细分之后，顺序是怎么样的呢？
其实前面没什么变化，只是对异步进行了区分：不同异步进入对应的 **event queue**，比如 `setTimeout` 和 `setIntval` 会进入宏任务的 **event queue**，而 `Promsie` 进入微任务的 **event queue**，虽然都是异步任务，但是 **宏任务的优先级高于微任务**。
## Promise的事件循环
Promise 在进行初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完成后，继续向下执行代码，在此之前，then 的回调不会执行，同步代码执行完毕后，才会在事件循环中检查是否有可用的 Promise 回调，如果有则执行，否则继续下一个事件循环。
可以总结为下面流程：

1. **宏任务和微任务都是队列**，主线程代码执行完毕后，会执行宏任务中的同步代码。
2. 进入第一轮事件循环的时候，会 **把全部的 js 脚本当成宏任务运行**。
3. 如果执行中遇到`setTimeout`之类的宏任务，那么会将其推入 **[宏任务队列]** 中，下一轮宏任务执行时调用。
4. 如果遇到 `Promise.then()` 之类的微观任务，就会推入到 **[当前宏任务的微观任务]** 中，本轮宏观任务结束后，依次执行所有微观任务。
5. 如果第一轮事件循环中执行完全部的同步以及微观任务队列任务，那么这一轮事件循环便结束了，开始进行下一轮。
6. 依次循环往复。

结合上面定义，我们看下面代码：
```javascript
const first = () => (new Promise((resolve, reject) => {
  console.log(3);
  let p = new Promise((resolve, reject) => {
    console.log(7);
    // 宏任务2
    setTimeout(() => {
      console.log(5);
      resolve(6);
    }, 0);
    resolve(1);
  });

  resolve(2);

  p.then((arg) => {
    // 微任务1
    console.log(arg);
  });
}));

// 宏任务1
first().then((arg) => {
    // 微任务2
    console.log(arg);
});
console.log(4);
```
结合定义一步步上面代码：
1. 第一轮将所有代码作为宏观任务，进入主线程。
2. 首先遇到 new Promise 名称为 first，执行里面同步函数。
3. 遇到 new Promise 名称为 p，执行同步函数，遇到里面含有的 setTimeout 将其回调注册后分发给第二轮宏观任务 event queue，并将 p 的 then 函数发布到当前任务的微任务event queue。
4. 对 first 注册 then 回调，并将回调添加到微任务 event queue。
5. 宏任务执行完毕，开始执行微任务...。
6. 得出结果为：**3**、**7**、**4**、**1**、**2**、**5**。

结合上面叙述，我们得出下面的结论：**宏任务是一个栈，按照先入先执行的原理，微任务也是按照先入先执行的原理。但是每个宏任务对应都有一个微任务栈，宏任务执行过程中会先执行同步代码在执行微任务栈**。