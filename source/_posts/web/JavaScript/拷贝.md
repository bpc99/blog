---
title: 拷贝
subtitle: javascript-copy
date: 2020-11-02 11:48:10
tags:
  - JavaScript
categories: [web]
---
了解拷贝之前，必须先搞清楚 **=**(赋值) 和 **拷贝** 的区别，它们是不会相同的。**赋值** 只能算是"引用"，其引用的任然是同一对象，不能算是真正的拷贝，因为**拷贝**是重新创建了新的对象，所以赋值和拷贝本质还是有区别的。

<!-- more -->

## 赋值与拷贝
JS 中的拷贝可以分为`浅拷贝`和`深拷贝`，它们的主要区别如下所示：

**深拷贝**：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 会 影响原数组。

**浅拷贝**：将 B 对象拷贝到 A 对象中，普通属性进行修改 不会 影响原数组，但是引用属性修改 不会 影响原数组。

所以结合上面的叙述，我们可以绘制出下面的表格：

|  名称   | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象 |
|  ----  | ----  | ----  | ----  |
|  =  | 是 | 改变会使原数据一同改变 | 改变会使原数据一同改变 |
|  浅拷贝  | 否 | 改变 **不** 会使原数据一同改变 | 改变会使原数据一同改变 |
|  深拷贝  | 否 | 改变 **不** 会使原数据一同改变 | 改变 **不会** 会使原数据一同改变 |

## 浅拷贝
我们要区分 `浅拷贝` 和 `赋值` 的区别，我们通过下面的方式进行比较：
```javascript
var obj1 = {
  'name': 'zhangsan',
  'age': '18',
  'language': [
	1,
	[2, 3],
	[4, 5]
  ],
};

var obj2 = obj1;

function shallowCopy(src) {
  var dst = {};
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      dst[prop] = src[prop];
    }
  }
  return dst;
}
var obj3 = shallowCopy(obj1);

obj2.name = "lisi";
obj3.age = "20";
obj2.language[1] = ["二", "三"];
obj3.language[2] = ["四", "五"];

console.log(obj1);
//obj1 = {
//    'name' : 'lisi',
//    'age' :  '18',
//    'language' : [1,["二","三"],["四","五"]],
//};
console.log(obj2);
//obj2 = {
//    'name' : 'lisi',
//    'age' :  '18',
//    'language' : [1,["二","三"],["四","五"]],
//};
console.log(obj3);
//obj3 = {
//    'name' : 'zhangsan',
//    'age' :  '20',
//    'language' : [1,["二","三"],["四","五"]],
//};
```
先定义一个原始对象 obj1，然后使用 **赋值** 得到第二个对象 obj2，然后通过 **浅拷贝** 对象 obj1 得到 obj3 对象。也就是说：

- **obj1**：原始数据。
- **obj2**：赋值操作得到。
- **obj3**：浅拷贝得到。

最后得出：我们在改变 **obj2** 和 **obj3** 的 `name` 属性，最后可以看出改变 **obj2** 会使 **obj1** 进行修改，而 **obj3** 不会修改。这就说明了 **赋值只是复用引用地址**，但引用还是同一对象，而 **拷贝则是新创建了一个对象**。而我们修改 **obj2** 和 **obj3** 的 `language` 属性时，最后是都会发生改变的，这是因为 浅拷贝 只是复制一层的对象属性，并不包括对象中的引用数据。所以修改引用类型的数据，原始数据也会进行修改。

从上面的实例很容易就能区分出 **复制** 和 **浅拷贝** 的真正区别。我们千万不能将 **复制** 直接当成 **浅拷贝** 进行理解。

## 深拷贝
因为前面讲了 **浅拷贝** 至于 **深度拷贝** 其实对对象的所有子对象都进行拷贝。那么怎么实现呢？
其实我们递归调用 **浅拷贝** 对象，把所有属于对象的属性类型都遍历赋给另一个对象即可。比如下面的代码：
```javascript
function deepClone(obj, newObj = {}) {
  for (key in obj) {
      if (typeof obj[key] === 'object') {
          newObj[key] = (obj[key].constructor === Array) ? [] : {};

          deepClone(obj[key], newObj[key]);
      } else {
          newObj[key] = obj[key]
      }
  }
  return newObj;
};
```
可以看出和 **浅拷贝** 非常的相似，只是遍历的时候判断如果是 **对象类型** 的数据，就递归继续拷贝，这样就避免 **浅拷贝** 子对象的问题。