---
title: 闭包
subtitle: closure
date: 2020-10-09 10:48:10
tags:
  - JavaScript
categories: [web]
---
闭包在项目中还是经常会被使用的，或许使用过但是并没有特别在意到，我们可以用一句话来形容闭包为：**可以访问其它函数作用域中变量的函数**。

<!-- more -->
## 闭包本质
闭包的本质源自两点，`作用域`和`私有性`：
- **作用域**：就是我们定义变量的使用范围。内部函数可以访问函数外面的变量，代码执行的过程中通过`作用域链`，可以去访问外围的变量。
- **私有性**：我们可以将函数当作一个变量进行赋值，利用函数内部的 return 返回内部属性，这就相当于返回了一个函数的通道，我们可以使用这个通道访问函数内部定义的变量。但是这样造成一个问题，便是由于里面定义的值会被引用，所以垃圾回收器不会回收这些值，它们会一直保存下去，而且无法直接访问，必须通过对应函数进行访问，这也就是私有性。

显然，闭包的形成很简单，在执行过程完毕后，一旦函数通过作用域链访问外部函数定义一些值，即形成闭包。实际上在 JavaScript 代码中闭包不要太常见。
## 作用域
这个比较容易理解，作用域就是：我们定义的每个变量的使用范围。作用域又分为 全局作用域 和 局部作用域。两个使用范围不同，各有优缺点。
## 作用域链
作用域链就是在函数内部可以访问外部变量的机制，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样**由多个执行上下文的变量对象构成的链表就叫做作用域链**。
## 执行环境
每当程序的执行流进入到一个可执行的代码时，就进入到了一个**执行环境中**（EC），EC 定义变量和函数有权访问的数据。JS 中函数运行都会产生一个执行环境，并且 JS 引擎还会产生一个与当前 EC 相关联的**变量对象**(VO)，EC 中所有定义的变量和方法都包含在 VO 中。

JS引擎会以栈的方式来处理执行上下文，也就是我们通常所说的函数调用栈。栈底永远是全局上下文，栈顶则是当前正在执行的上下文。处于栈顶的执行上下文执行完毕后，会自动出栈。

比如下面的例子可以很好的反应 EC 的执行流程：
```javascript
function declare() {
  var a = 1;
  function update() {
    a = 2;
  }
  update();
}
declare();
```
我们如果使用执行上下文的进栈出栈流程图如下：

![](https://img.bipch.cn/2021/02/03/2ccaa5a6430c3.jpg)

可以看出代码总共经历下面几个步骤：

1. 首先第一步就是全局上下文入栈。
2. 全局上下文入栈后，遇到的第一个可执行代码就是 declare() 函数的调用，此函数一旦调用，就会创建自己的执行上下文，此时 declare EC 入栈。
3. 在新开辟的 declare EC 执行上下文中，执行内部的可执行代码，直到遇到 update() 函数调用时，又会创建一个新的执行上下文，此时 update EC 入栈。
4. 当 update EC 中的可执行代码执行完毕之后，发现不再有其他执行上下文生成的情况，此上下文会自动从栈中弹出。
5. update EC 执行上下文弹出后，会继续执行 declare EC 执行上下文中的可执行代码，直到顺利执行完毕，且没有遇到其他执行上下文，则自动从栈中弹出。
最后执行栈中只剩下全局上下文，若浏览器不关闭，全局上下文会一直存在，直到浏览器窗口关闭，全局上下文才会最终出栈。