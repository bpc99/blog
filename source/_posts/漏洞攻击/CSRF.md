---
title: CSRF
subtitle: csrf
date: 2021-03-21 12:23:00
tags:
  - 跨站请求伪造
categories: [漏洞攻击]
---
CSRF 全称为 Cross-site request forgery 也可以称之为 **跨站请求伪造**，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

<!-- more -->

## 攻击原理
造成该问题的原因是 http 是无状态的，用户登陆指定程序后，攻击者发送恶意连接，骗用户点击，由于前面以进行过登陆，所以被访问的网站会认为是真正的用户操作而去运行。换句话说：**简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的**。

![](https://img.bipch.cn/2021/03/22/61354dc2da001.png)

比如有个银行的接口为`xxx.com/money/transfer?user=87345553ert&money=200`参数中 **user** 表示转账的账户，而 **money** 表示转折的金额，例如我们登陆了一个大型系统，登陆后 token 进行了存储，如果我们此时没有退出并且访问了恶意的链接，链接里的界面访问了`xxx.com/money/transfer?user=87345553ert&money=200`接口，这样可怜的受害者便莫名其妙的转给 **7345553ert** 了 200。

当然这只是简单的举例，因为凡是设计到这类敏感接口，都在需要USB key、验证码、登录密码和支付密码等一系列屏障。

## CSRF的防御
既然 CSRF 危害那么大，那么可以使用什么方式进行防御呢？
### 将 cookie 设置为 HttpOnly
有可能会有一部分恶意网址使用`XSS漏洞`盗取用户浏览器 cookie 数据，获取到 cookie 数据便可很简单的在任意地方进行 CSRF 形式的漏洞攻击了，那么就需要我们防止 `XSS` 漏洞获取关键数据，所以此时便需要`HttpOnly`属性将敏感 token 设置为禁止操作的。

例如使用 koa2 框架当用户登陆成后，在后台可以添加下面代码：
```javascript
ctx.cookies.set(
  'token',
  '8sd95vd9f8dc5d8f78d5c28d.8dc8d2f8d7f48d7fdf.dsf47s4d8s', {
    // cookie有效时长
    maxAge: 60 * 1000 * 60,
    // cookie可用域名
    domain: "localhost",
    // 默认false，设置成true表示只有https可以访问
    secure: false,
    // true，客户端不可读取
    httpOnly: true,
    // 是否覆盖
    overwrite: false
  }
);
```
这样当登陆成功后，浏览器会自动根据 response 保存一个 cookie：

![](https://img.bipch.cn/2021/03/22/b103d96434f55.png)

但是有一点需要注意 `HttpOnly` 的符合，若其为 **√** 则表示该数据客户端是无法获取的，否则可以正常获取，例如我们可以执行下面代码：

![](https://img.bipch.cn/2021/03/22/9aff4b989b4d6.png)

可以看到其只能获取到本域中不被`HttpOnly` 标记的数据。所以其可以有效的防止 cookie 泄露。

这样也能屏蔽掉 利用`XSS漏洞` 盗取数据并配合 `CSRF漏洞` 进行攻击。

### 增加 token 验证
CSRF 只是攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于 cookie 中，所以攻击者可以在不知道用户 cookie 的方式下进行攻击。所以我们可以得出另外一个 CSRF 的防御方式：**在请求中添加另一个无法伪造的字段，并且这个字段不能存在与 cookie 中**。介于此我们可以在提交敏感表单时，添加一个随机的 token，并在服务端进行 token 校验，若失败则认为 CSRF 攻击，从而拒绝该请求。

比如在进入到敏感界面时，后台生成一个 token，前端接收并赋值给一个变量，等到界面提交时，将这个变量添加进请求数据中，后台接收后进行比对，失败就认为是 CSRF漏洞攻击。

这样也能屏蔽掉一些 CSRF 攻击。

### 验证 HTTP Referer
虽然 HTTP 是无状态协议，但其会将当前界面地址传入到后台中，我们可以在`referer`属性获取，只有访问到指定界面，我们才会允许访问，不然拒绝掉此次请求，但是这种方式非常的不灵活，因为后台接口是会提供给多个项目，包括pc端、移动端、微信小程序等调用，所以其路径也基本不会固定，单是如果需要这种效果也还是可以进行 CSRF 拦截的。
```javascript
console.log(ctx.request.headers['referer'])
```

## 总结
CSRF 攻击是利用被攻击者登陆之后的 token，进行一些恶意的操作，因为后台服务无法判断当前请求是不是用户希望的操作，为了解决这一漏洞我们也可以从多个方面进行拦截，上面只是一些较为常用的方法，开发中会遇到更多的需求。