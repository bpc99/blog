---
title: XSS
subtitle: xss
date: 2020-12-10 10:35:40
tags:
  - 跨域脚本攻击
categories: [漏洞攻击]
---
**XSS** 是 **跨域脚本攻击** 的简称，若有人不怀好心在 Web 界面中插入恶意的 Script 代码，用户浏览指定界面后，恶意嵌入的 Script 代码就会被执行，从而达到恶意攻击用户的目的。

<!-- more -->

## XSS攻击方式
恶意插入 JavaScript 代码，主要在一些简单的留言板、富文本展示等界面，如果有用户在代码中恶意添加下面一行代码：
```html
<script>alert("hey!you are attacked")</script>
```
那么后面解析到这一句话的时候，Script 代码便会被执行到，界面便会出现弹框，这便是简单的 XSS 攻击方式。

## 原理
其原理就是在我们渲染 **html** 代码时，传入可执行的 **JavaScript** 代码，例如通过数据库保存为可执行代码，或者路径传参为可执行代码。
例如我们可以在一些文本框中输入下面内容：
![](https://upload-images.jianshu.io/upload_images/7455247-39bd5204a1c40823.png?imageMogr2/auto-orient/strip|imageView2/2/w/630/format/webp)
这样的一段代码一旦保存到数据库中，这个 JavaScript 代码便会立即执行。也就是界面会出现下面的情况：
![](https://upload-images.jianshu.io/upload_images/7455247-7df7eea8d898458c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1038/format/webp)
这便是 XSS 攻击的简单原理，简单来说便是将可执行的恶意 JavaScript 代码插入到界面中，使其被执行，并且它不只可以引入一小段 JS 代码，甚至我们可以直接引入一段可执行的 JS 的脚本：
```html
<script src="*******"></script>
```
这种情况下脚本中代码甚至都会去执行，而在脚本中我们可以随意执行，并且可以获取到项目的私密信息，可以说对项目的危害还是非常大的。

## XSS过滤
既然 **XSS漏洞** 危害那么大，那么  **XSS漏洞** 很好利用吗？肯定不是的，因为我们有许多的方式可以过滤掉 **XSS漏洞** 的攻击。
### 过滤不合法信息
我们可以将输入或者传入的内容中不合法信息都进行过滤，从而保证项目中数据的安全性。
比如移除用户输入的 DOM 属性，例如过滤掉 **onclick**、**onerror**、**onload** 等相关的 DOM 事件，并且移除一些用户定义的节点，例如过滤掉 **&lt;style&gt;**、**&lt;script&gt;**、**&lt;iframe&gt;** 等节点。

> 注意：不是所有的 JavaScript 都要在 &lt;script&gt; 中才能执行，放在 &lt;img onerror="alert(0)" src="wwww" /&gt; 也是可以正常执行的，所以一些 DOM 事件也有必要进行过滤。
### 对特殊字符串进行编码
我们不仅需要对于输入或者传入的数据进行过滤，在前端渲染或后台保存的时候，我们还需要对字符串进行 HTML Entity 的编码处理，因为有时为了攻击网站，还可以使用一些转移的字符如：`"<"`可以替换为`&lt;`、`">"`可以替换为`&gt;`等字符转码可以绕过一些过滤。

> 并且能绕过匹配的不仅有特殊字符串，如果项目中判断不完全甚至可以用大小写绕过，例如我们这样写：&lt;scRIpt&gt;\*\*\*\*\*\*\*\*&lt;scRIpt/&gt; 是能正常运行的，因为 JavaScript 是不区分大小写的。
### httpOnly
不将信息存储到 web Storage，而存储到 **cookie** 中，并且为 cookie 设置为无法被读写的，为其设置上`httpOnly`，这样之后使用 JS 便不能读写 cookie 数据。
### 限制长度
因为需要添加一些可执行的 JS 代码，会是很长的一段代码，所以我们可以限制一些代码的长度，避免出现过长的代码，也可以进行简单的长度限制。

## XSS绕开过滤
道高一尺魔高一丈，项目中有很多避免 XSS 漏洞的方式，但 XSS 的攻击方式也是多种多样。
### 大小写绕过
上面已经介绍过，因为 JavaScript 是一种弱文本语言，并其不区分大小写，所以我们可以利用这点进行攻击，例如添加下面代码：
```html
<scrIPt>alert("hello world")</scrIPt>
```
如果项目判断不谨慎，很容易被该方式偷鸡。
### 利用过滤语句进行攻击
一种技巧，因为大部分项目都对 &lt;script&gt; 标签进行了过滤，那么我们便可以利用这一点对齐进行攻击。例如这样做：
```html
<scRi<script>pt>alert("hello world")</scRi</script>pt>
```
虽然这样代码看起来什么也不是，但是经过其过滤掉 &lt;script&gt; 标签后，会出现下面代码：
```html
<scRipt>alert("hello world")</scRipt>
```
正好利用其过滤形成一条可执行语句，也是一种小技巧。
### 并不是只有 script 标签才能插入可执行代码
我们并不是只有插入 &lt;script&gt;  才能执行 JS 的代码，我们可以使用 DOM标签 绑定事件，事件中可执行 JS 代码。例如我们这样写：
```html
<img src='w.123' onerror='alert("hey!")' />
```
如果输入大意，也是可能对其项目造成危害的。
### 使用转义字符
因为项目都是对指定字符串进行匹配，但是 JS 中有一些特别的转义字符，大部分都是通过 "\" 字符进行转义，而攻击者可以使用转义输入，但是转义之后便是可执行的代码，便能达到攻击项目的目的。
例如这样写：
```html
<script>eval(\u0061\u006c\u0065\u0072\u0074(1))</script>
```
这样转移之后便是：
```html
<script>alert(1)</script>
```
这样也可以绕过一些字符的过滤。

## XSS攻击分类
实际项目中的漏洞是不会这么直观的，我们需要不断的换各种方式去尝试，甚至可以使用多种方式合并起来绕过项目的过滤，以达到我们的目的，而攻击的方式更是多种多样，并且XSS 的攻击大致上可以分为两类：

- 一类是`反射型XSS`，又称为 **非持久型XSS**。
- 一类是`存储型XSS`，也称之为 **持久型XSS**。

### 反射型XSS
**反射型XSS** 一般表示从 **URL** 中传入恶意攻击的代码，而界面不错任何处理便渲染到项目中。
这也就是说攻击相对于访问者是 **一次性** 的，也就是通过 **URL** 将恶意代码传递到界面上，而项目不对数据进行任何处理，将脚本 **"反射"** 到浏览器进行渲染，此时恶意脚本便执行了。
也就是说如果此种形式进行 **XSS攻击**，只能访问特定链接才能实现恶意攻击。
### 储存型XSS
**储存型XSS** 与上面最大的不同是，它是通过将恶意代码保存到数据库中，界面读取到数据库中的恶意代码，直接渲染上面也会造成 **XSS攻击**。
例如我们在数据库中保存了一行恶意代码，然后指定用户访问时，后台将恶意代码读取出并返回到前端浏览器执行。这就意味着该用户登陆的所有地方都会执行这段恶意代码，**因此存储型XSS危害更大**。
只需要登陆指定用户到指定 URL 便可进行攻击，不需要访问特定的 URL。