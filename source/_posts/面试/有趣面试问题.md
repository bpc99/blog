---
title: 有趣面试问题
subtitle: interview
date: 2021-03-25 13:00:54
tags:
  - 面试
categories: [ 面试 ]
---
记录一些有趣平时又不轻易能刷到的一些问题，会持续进行更新。

<!-- more -->

## 2021-03-25
### CSS中 伪类 和 伪元素 作用
**伪元素** 通用用于在文字之前或之后嵌入新的内容，或者设置首字母或首行的样式。例如常用的：`::after`(之后)、`::before`(之前)、`::selection`(选中)等。
**伪类** 经常定义一些特殊样式，如果常用的`:hover`(鼠标移入)、`:focus`(获取到焦点)、`:not(selector)`(非 selector 元素)、`:nth-child(n)`(父元素的第 n 个子元素)等。
### content-box 和 border-box 有什么区别？
听到这两个单词当时有些懵，不过还好反应过来了，都是`box-sizing`的属性，其作用就是告诉浏览器盒模型宽度和高度的计算规则。
- **content-box**(默认)：标准 w3c 盒模型，`width = content`；
- **border-box**：另一种盒模型，包括内边距和边框都计算到宽度中，也就是`width = context + border + padding`。

### 垂直居中如何实现
说实话实现这种样式以及非常简单了：
1. 弹性布局(flex)；
2. 如果父元素高度确定，使用 line-height；
3. 兼容性比较好的方式，对元素使用 **absolute**，top、left 各 **50%**，然后使用 **transform** 上下各 **负** 高度一般(translate(-50%, -50%))；

还有很多，就不多介绍了，方式属实太多。
### 垂直居中后，如何向上偏移 20px
这一点属实挺搞人的，都垂直居中了还要进行偏移，实现方式也很多：
1. 利用 padding，直接内边距就行，不过需要注意盒模型的宽高计算方式，也就是 box-sizing 属性。
2. 利用 transform 中的 translate 属性，该属性主要作用便是进行平移，比如我们可以这样些：translate(-50%, calc(-50% - 20px)) 续上面 -50% 后再垂直再 -20px 即可。

### React 版本号代表什么？
这一点真的没有注意到，回去之后第一时间进行了查询，原来还真有说法的，[官网地址](https://reactjs.bootcss.com/docs/faq-versioning.html)。
版本号主要由 **x.y.z** 三部分组成。
- 当出现严重 bug 并修复时，通过修改 **z** 来发布一个修订版本（如：15.6.2 至 15.6.3）。
- 当发布新功能 或 修复非严重 bug 时，通过修改 **y** 来发布一个次要版本（如：15.6.2 至 15.7.0）。
- 当发布破坏性更新时，通过修改 **x** 来发布一个主版本（如：15.6.2 至 16.0.0）。

### React 中 “艾克藤死” 有什么作用？
说实话，当时面试官英语有些口音，导致我听到时，脑子一片空白，这是什么东西，让重读几次还是不确定，而马上到下一题时我脑子中突然出现一个单词`extends`，经过确认还真是。

当我们创建类组件时，必须继承`React.Component`或`React.PureComponent`任一个，两者区别不大，只是后者对`shouldComponentUpdate`进行浅对比。

至于为什么要继承它们，主要其内部为我们提供了生命周期钩子、setState、render等方法和 state、props 等属性，提供给我们调用和覆盖；在这些属性和方法中 render 方法至关重要，是`必须`要重写的，主要因为 React 中所有组件都是由 jsx 代码组成，此类型的代码可以当作 React virtul DOM 的语法糖，最终这些代码都需要 babel-loader 解析为类似于树状的 **React virtul DOM**(React 虚拟DOM)

![](https://img.bipch.cn/2021/03/25/586c5c64d4ac6.png)

若此时并非第一次渲染，通过 diff 算法对比最新的 虚拟DOM树 和之前的 DOM树，找出经过修改的元素，最终形成一颗新的 virtul DOM 树，最后将这个 DOM树 渲染到客户端界面上，这样极大缩小了更新的 DOM 节点。

最后总结出一句话：不能不继承`React.Component`等去创建一个类组件，即使手动添加了 render 方法，因为 render 中所返回的 jsx 代码浏览器不能解析，必须通过 React 内部的转换。
### React 防止组件不必要的渲染
当时第一时间脱口而出`React.memo`，然后忘记了`React.PureComponent`，当然 PureComponent 只是进行了 **shouldComponentUpdate** 浅对比，真正要避免不必要的重复渲染还是要看 **shouldComponentUpdate** 的。
### 如果 **shouldComponentUpdate** 返回 false，如何强制组件更新？
听到这个问题，也是一脸问号，什么操作？仔细想了下可能考验 React 相关 API？
如果要实现这种效果可以用`forceUpdate`方法，其会跳过`shouldComponentUpdate`直接去更新组件，使用也很简单，在父组件通过 ref 获取到子组件，然后直接调用这个方法即可。
```javascript
//? 父组件
class App extends React.Component{

  constructor(props){
    super(props);
    this.state = {loader: true};
    this.child = React.createRef();
    this.reRender= this.reRender.bind(this);
  }
  
  reRender(){
    //! 强行更新，慎用
    this.child.current.forceUpdate();
  }

  render(){
    return (
      <div>
        <button onClick={ this.reRender }>重新渲染</button>
        <Children ref={this.child} />
      </div>
    )
  }
}

//? 子组件
class Children extends React.Component{

  shouldComponentUpdate(){
    return false;
  }
  componentDidUpdate(){
    console.log("shouldComponentUpdate false 老子照样重新渲染！");
  }

  render(){
    return <div>hello world</div>
  }
}
```
### JS 如何并发执行多个异步请求？
听到这个问题，我还以为听错了，异步请求本来不都是并发的吗？最后确认可能是需要全部执行完成后，在执行回调逻辑，这就非常简单了，根据需求选择 Promsie 中的 `all`或者`race`即可。
### 箭头函数需要注意的点
没什么技术含量的问题，箭头函数中最需要注意的便是`this`的指向问题了，JavaScript 其它函数都根据怎么调用获取 this 的，但是**箭头函数没有 this，它只会从自己的作用域链的上一层继承this**。
### 说出几个 HTTP 缓存的属性
一张图：

![](https://img.bipch.cn/2021/03/29/066c8df413940.png)

厚颜无耻的链接下本人[文章](/http-cache)。

### 说下网站部署后的安全问题
捡了两个简单的说[`XSS`(跨域脚本攻击)](/xss)、[`CSRF`(跨站请求伪造)](/csrf)，至于怎么攻击、怎么防范，网上一抓一大把相似文章，这里就厚颜无耻的链了我的两篇文章。